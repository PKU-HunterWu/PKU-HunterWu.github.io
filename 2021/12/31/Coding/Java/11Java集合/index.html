<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-H.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-H.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-H.png"><link rel="mask-icon" href="/images/favicon-H.png" color="#222"><meta name="msvalidate.01" content="7712DDD8033784B9F5BC335DB79AE423"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"pku-hunterwu.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="第十一章、Java集合 目录  一、Java 集合框架概述 二、Collection 接口方法（抽象方法） 四、Collection 子接口一：List 五、Collection 子接口二：Set（重要性低于 List、Map） 六、Map 接口 七、Collections 工具类 面试题 每日一考"><meta property="og:type" content="article"><meta property="og:title" content="第11章 Java集合"><meta property="og:url" content="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/index.html"><meta property="og:site_name" content="Hunt&#39;s Blog"><meta property="og:description" content="第十一章、Java集合 目录  一、Java 集合框架概述 二、Collection 接口方法（抽象方法） 四、Collection 子接口一：List 五、Collection 子接口二：Set（重要性低于 List、Map） 六、Map 接口 七、Collections 工具类 面试题 每日一考"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/73%20Day%20-%2002.png"><meta property="og:image" content="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/74%20Day%20-%2002.png"><meta property="og:image" content="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/75%20Day%20-%2002.png"><meta property="og:image" content="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/76%20Day%20-%2002.png"><meta property="og:image" content="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/77%20Day%20-%2002.png"><meta property="og:image" content="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/78%20Day%20-%2002.png"><meta property="og:image" content="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/79%20Day%20-%2002.png"><meta property="article:published_time" content="2021-12-31T02:21:47.000Z"><meta property="article:modified_time" content="2021-12-31T02:21:47.000Z"><meta property="article:author" content="Hunt"><meta property="article:tag" content="笔记"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/73%20Day%20-%2002.png"><link rel="canonical" href="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/","path":"2021/12/31/Coding/Java/11Java集合/","title":"第11章 Java集合"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>第11章 Java集合 | Hunt's Blog</title><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Hunt's Blog</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">1</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">18</span></a></li><li class="menu-item menu-item-友链"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0java%E9%9B%86%E5%90%88"><span class="nav-text">第十一章、Java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="nav-text">一、Java集合框架概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E6%A6%82%E8%BF%B0"><span class="nav-text">(一)、概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="nav-text">(二)、集合框架</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8Ccollection%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-text">二、Collection接口方法（抽象方法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-text">三、Iterator迭代器接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9Bcollection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B8%80list"><span class="nav-text">四、Collection子接口一：List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80arraylist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---jdk7%E6%83%85%E5%86%B5%E4%B8%8B"><span class="nav-text">(一)、ArrayList源码分析 - JDK7情况下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8Carraylist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90---jdk8%E6%83%85%E5%86%B5%E4%B8%8B"><span class="nav-text">(二)、ArrayList源码分析 - JDK8情况下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89linkedlist%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">(三)、LinkedList源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9Bvector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">(四)、Vector源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94list%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">(五)、List接口中的常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E6%80%BB%E7%BB%93%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8D%E5%8E%BB%E7%9C%8Bapi%E5%B0%B1%E8%83%BD%E7%94%A8"><span class="nav-text">(六)、总结：常用方法（不去看API就能用）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%BA%8Cset%E9%87%8D%E8%A6%81%E6%80%A7%E4%BD%8E%E4%BA%8Elistmap"><span class="nav-text">五、Collection子接口二：Set（重要性低于List、Map）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80set%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A1%86%E6%9E%B6"><span class="nav-text">(一)、Set接口的框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%90%86%E8%A7%A3set%E7%9A%84%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7"><span class="nav-text">(二)、理解Set的无序性和不可重复性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BB%A5jdk7-hashset%E4%B8%BA%E4%BE%8B"><span class="nav-text">(三)、添加元素的过程：以JDK7 HashSet为例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9Bhashcode%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-text">(四)、hashCode()的重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94linkedhashset"><span class="nav-text">(五)、LinkedHashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%ADtreeset%E4%BA%86%E8%A7%A3"><span class="nav-text">(六)、TreeSet（了解）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%ADmap%E6%8E%A5%E5%8F%A3"><span class="nav-text">六、Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80map%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%A0%91"><span class="nav-text">(一)、Map接口继承树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8Cmap%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">(二)、Map结构的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89hashmap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86jdk7%E4%B8%BA%E4%BE%8B"><span class="nav-text">(三)、HashMap的底层实现原理（JDK7为例）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9Bjdk8%E7%9B%B8%E8%BE%83%E4%BA%8Ejdk7%E5%9C%A8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%96%B9%E9%9D%A2%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-text">(四)、JDK8相较于JDK7在底层实现方面的不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94hashmap%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B8%B8%E9%87%8Fjdk8"><span class="nav-text">(五)、HashMap中的重要常量（JDK8）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%ADlinkedhashmap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">(六)、LinkedHashMap的底层实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83map%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">(七)、Map中定义的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%ABtreemap"><span class="nav-text">(八)、TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9Dproperties"><span class="nav-text">(九)、Properties</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-text">七、Collections工具类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">面试题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E6%97%A5%E4%B8%80%E8%80%83"><span class="nav-text">每日一考</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" alt="Hunt" src="/images/HarryPotter.png"></a><p class="site-author-name" itemprop="name">Hunt</p><div class="site-description" itemprop="description">个人博客，记录、分享计算机编程相关技术，包括Java、MySQL、Web等相关技术内容。</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/PKU-HunterWu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PKU-HunterWu" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1457509769@qq.com" title="E-Mail → mailto:1457509769@qq.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.pku.edu.cn/" title="https:&#x2F;&#x2F;www.pku.edu.cn" rel="noopener external nofollow noreferrer" target="_blank">PKU官网</a></li><li class="links-of-blogroll-item"><a href="https://bbs.pku.edu.cn/v2/home.php" title="https:&#x2F;&#x2F;bbs.pku.edu.cn&#x2F;v2&#x2F;home.php" rel="noopener external nofollow noreferrer" target="_blank">北大未名BBS</a></li><li class="links-of-blogroll-item"><a href="https://github.com/PKU-HunterWu" title="https:&#x2F;&#x2F;github.com&#x2F;PKU-HunterWu" rel="noopener external nofollow noreferrer" target="_blank">PKU-HunterWu</a></li></ul><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),today=(new Date).toLocaleString(),document.getElementById("days").innerHTML=today}function show_running_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("11/21/2021 8:00:00"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="本站已安全运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/PKU-HunterWu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener external nofollow noreferrer" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/HarryPotter.png"><meta itemprop="name" content="Hunt"><meta itemprop="description" content="个人博客，记录、分享计算机编程相关技术，包括Java、MySQL、Web等相关技术内容。"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hunt's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">第11章 Java集合</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-12-31 10:21:47" itemprop="dateCreated datePublished" datetime="2021-12-31T10:21:47+08:00">2021-12-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a> </span></span><span id="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/" class="post-meta-item leancloud_visitors" data-flag-title="第11章 Java集合" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>23k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>21 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="第十一章java集合">第十一章、Java集合</h1><h2 id="目录">目录</h2><ol type="1"><li>一、Java 集合框架概述</li><li>二、Collection 接口方法（抽象方法）</li><li>四、Collection 子接口一：List</li><li>五、Collection 子接口二：Set（重要性低于 List、Map）</li><li>六、Map 接口</li><li>七、Collections 工具类</li><li>面试题</li><li>每日一考</li></ol><span id="more"></span><h2 id="一java集合框架概述">一、Java集合框架概述</h2><h3 id="一概述">(一)、概述</h3><p>集合、数组都是对多个数据进行存储操作的结构，简称为<strong>java容器</strong>【说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt, .jpg ...）】</p><ol type="1"><li>一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。<ul><li>数组在内存存储方面的特点：<ul><li>数组初始化以后，长度就确定了。</li><li>数组声明的类型，就决定了进行元素初始化时的类型</li></ul></li><li>数组在存储数据方面的弊端：<ul><li>数组初始化以后，长度就不可变了，不便于扩展</li><li>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数</li><li>数组存储的数据是有序的、可以重复的。----&gt;存储数据的特点单一。对于无序、不可重复的需求不能满足</li></ul></li></ul></li><li>Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。</li></ol><h3 id="二集合框架">(二)、集合框架</h3><p>Java 集合可分为 Collection 和 Map 两种体系</p><ul><li><p>Collection接口：单列数据，定义了存取一组对象的方法的集合</p><ul><li>List：元素有序、可重复的集合。---&gt; “动态”数组<ul><li>List接口<strong>实现类</strong>：<strong>ArrayList、LinkedList、Vector</strong></li></ul></li><li>Set：元素无序、不可重复的集合。---&gt; 数学上的“集合”<ul><li>Set接口<strong>实现类</strong>：HashSet、LinkedHashSet、TreeSet</li></ul></li></ul></li><li><p>Map接口：双列数据，保存具有映射关系“key-value对”的集合 ---&gt; 数学上的“函数”：y = f(x) 【value = f(key)】</p><ul><li>Map接口<strong>实现类</strong>：<strong>HashMap</strong>、LinkedHashMap、TreeMap、Hashtable、Properties</li></ul></li><li><p>Collection接口继承树</p><figure><img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/73%20Day%20-%2002.png" alt="Collection接口继承树"><figcaption aria-hidden="true">Collection接口继承树</figcaption></figure></li><li><p>Map接口继承树</p><figure><img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/74%20Day%20-%2002.png" alt="Collection接口继承树"><figcaption aria-hidden="true">Collection接口继承树</figcaption></figure></li></ul><h2 id="二collection接口方法抽象方法">二、Collection接口方法（抽象方法）</h2><ol type="1"><li><p>add(Object e)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(Object e): 将元素e添加到集合中</span><br></pre></td></tr></table></figure><p></p></li><li><p>size()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size(): 获取添加的元素个数</span><br></pre></td></tr></table></figure><p></p></li><li><p>addAll(Collection coll1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addAll(Collection coll1): 将coll1集合中的元素添加到当前的集合中</span><br></pre></td></tr></table></figure><p></p></li><li><p>isEmpty()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isEmpty(): 判断当前集合是否为空</span><br></pre></td></tr></table></figure><p></p></li><li><p>clear()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear(): 清空集合中的所有元素</span><br></pre></td></tr></table></figure><p></p></li><li><p>contains(Object obj)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contains(Object obj): 判断当前集合中是否包含obj</span><br><span class="line"><span class="comment">// 在判断时，会调用obj的equals()方法</span></span><br><span class="line"><span class="comment">// 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals()方法</span></span><br></pre></td></tr></table></figure><p></p><ul><li><strong>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals()方法</strong></li></ul></li><li><p>containsAll(Collection coll1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">containsAll(Collection coll1): 判断形参coll1中的所有元素是否都存在于当前集合中</span><br></pre></td></tr></table></figure><p></p></li><li><p>remove(Object obj)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove(Object obj): 从当前集合中移除obj元素，且在移除前使用equals()方法判断是否存在于当前集合中</span><br></pre></td></tr></table></figure><p></p></li><li><p>removeAll(Collection coll1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeAll(Collection coll1): 从当前集合中移除coll1中的所有元素（移除的是当前集合和coll1的交集元素，同样在移除前会调用各元素的equals()方法），差集</span><br></pre></td></tr></table></figure><p></p></li><li><p>retainAll(Collection coll1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retainAll(Collection coll1): 交集，获取当前集合和coll1的交集，并直接将当前集合修改为结果</span><br></pre></td></tr></table></figure><p></p></li><li><p>equals(Object obj)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equals(Object obj): 判断当前集合和形参是否相同（当形参为集合时，需要元素是相同的顺序且调用对应元素的equals()方法）</span><br></pre></td></tr></table></figure><p></p></li><li><p>hashCode()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashCode(): 返回当前对象的哈希值（Object类中已定义hashCode()方法）</span><br></pre></td></tr></table></figure><p></p></li><li><p>toArray()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">toArray(): 集合 --&gt; 数组，方法返回一个Object[]类型</span><br><span class="line">Arrays.asList(T... a): 数组 --&gt; 集合，调用Arrays类的静态方法asList()，形参为可变形参</span><br><span class="line">    List&lt;String&gt; arr = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, String.valueOf(<span class="number">123</span>), <span class="string">&quot;BB&quot;</span>&#125;);</span><br><span class="line">        System.out.println(arr); <span class="comment">//[AA, 123, BB]</span></span><br><span class="line"></span><br><span class="line">        List arr1 = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">12</span>, <span class="number">45</span>, <span class="number">78</span>&#125;); </span><br><span class="line">		<span class="comment">//提示：Call to &#x27;asList()&#x27; with only one argument</span></span><br><span class="line">		<span class="comment">// 被识别为一个参数</span></span><br><span class="line">        System.out.println(arr1); <span class="comment">//[[I@4f8e5cde]</span></span><br><span class="line"></span><br><span class="line">        List arr2 = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">12</span>, <span class="number">45</span>, <span class="number">78</span>&#125;);</span><br><span class="line">        System.out.println(arr2); <span class="comment">//[12, 45, 78]</span></span><br><span class="line"></span><br><span class="line">        List arr3 = Arrays.asList(<span class="number">12</span>, <span class="number">45</span>, <span class="number">78</span>);</span><br><span class="line">        System.out.println(arr3); <span class="comment">//[12, 45, 78]</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>toArray(T[] a)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toArray(T[] a)</span><br></pre></td></tr></table></figure><p></p></li><li><p>iterator()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator(): 返回Iterator接口的实例，用于遍历集合元素。放在IteratorTest.java中测试</span><br></pre></td></tr></table></figure><p></p></li></ol><h2 id="三iterator迭代器接口">三、Iterator迭代器接口</h2><ul><li>Iterator对象称为迭代器(设计模式的一种)，主要<strong>用于遍历 Collection 集合</strong>中的元素。（无法遍历Map中的元素）</li><li>GOF给迭代器模式的定义为：<strong>提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生</strong>。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。</li><li>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</li><li><strong>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。</strong></li><li><strong>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</strong></li></ul><figure><img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/75%20Day%20-%2002.png" alt="alt"><figcaption aria-hidden="true">alt</figcaption></figure><ol type="1"><li><p>next()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next(): 返回迭代器中的下一个元素</span><br><span class="line">    <span class="comment">// 执行next时：①指针下移 ②将下移后集合位置上的元素返回</span></span><br><span class="line">    <span class="comment">// Throws: NoSuchElementException - if the iteration has no more elements </span></span><br></pre></td></tr></table></figure><p></p></li><li><p>hasNext()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasNext(): 判断是否还有下一个元素</span><br></pre></td></tr></table></figure><p></p></li><li><p>方法使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="string">&quot;Aa&quot;</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> Date());</span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">Iterator iterator = coll.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐写法</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; coll.size(); i++)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐写法</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk 5.0新增了foreach循环</span></span><br><span class="line"><span class="comment">// for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line"><span class="comment">// 内部仍然调用了迭代器 iterator</span></span><br><span class="line"><span class="keyword">for</span> (Object obj: coll) &#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for(集合元素的类型 局部变量 : 数组对象)</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i :</span><br><span class="line">     arr) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 笔试题</span></span><br><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MM&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用增强for循环（或foreach）</span></span><br><span class="line"><span class="keyword">for</span> (String s :</span><br><span class="line">     arr) &#123;</span><br><span class="line">    s = <span class="string">&quot;GG&quot;</span>; <span class="comment">// 使用的局部变量进行赋值，不改变原有元素值</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr)); <span class="comment">//[MM, MM, MM]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一：普通for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    arr[i] = <span class="string">&quot;GG&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr)); <span class="comment">//[GG, GG, GG]</span></span><br></pre></td></tr></table></figure></li><li><p>remove()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove(): 可在遍历时删除集合中的元素，删除当前iterator指针指向的元素。此方法不同于集合中的remove()方法。</span><br></pre></td></tr></table></figure><p></p><ul><li>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</li><li>如果还未调用过next()或在上一次调用 next 方法之后已经调用过了 remove 方法，再调用remove都会报<strong>IllegalStateException</strong>。</li></ul></li></ol><h2 id="四collection子接口一list">四、Collection子接口一：List</h2><ul><li>鉴于Java中数组用来存储数据的局限性，我们通常<strong>使用List替代数组</strong></li><li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li><li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。<ul><li>同：三个类都实现了List接口，存储数据的特点相同：存储有序、可重复的数据</li><li>异：<ul><li>ArrayList：<ul><li>作为List接口的主要实现类</li><li>线程不安全，因此效率高</li><li><strong>底层使用Object[] elementData存储</strong></li></ul></li><li>LinkedList：<ul><li>对于频繁的插入、删除操作，使用此类效率比ArrayList高</li><li><strong>底层使用双向链表</strong></li></ul></li><li>Vector：<ul><li>作为List接口的古老实现类。【JDK1.0时即存储有序、可重复的数据，JDK1.2后出现的List接口，且紧接着出现了两个实现类ArrayList、LinkedList，后把Vector归入List接口的实现类】</li><li><strong>线程安全</strong>，效率低</li><li><strong>底层使用Object[] elementData存储</strong></li></ul></li></ul></li></ul></li></ul><h3 id="一arraylist源码分析---jdk7情况下">(一)、ArrayList源码分析 - JDK7情况下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 空参构造器创建了一个长度为10的Object数组</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// elementData[0] = new Integer(123);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">11</span>); <span class="comment">// 如果此次的添加导致底层elementData数组容量不足，则扩容；默认情况下，扩容为原来的1.5倍，同时需将原有数组中的数据复制到新的数组中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：建议开发中使用带参构造器</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(<span class="keyword">int</span> capacity);</span><br></pre></td></tr></table></figure><h3 id="二arraylist源码分析---jdk8情况下">(二)、ArrayList源码分析 - JDK8情况下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 底层Object[] elementData初始化为&#123;&#125;。并没有创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 后续添加和扩容操作与JDK7无异</span></span><br></pre></td></tr></table></figure><p>JDK7中的ArrayList的创建类似于单例模式的饿汉式，而JDK8中的ArrayList的创建类似于单例模式的懒汉式，延迟了数组的创建，节省内存。</p><h3 id="三linkedlist源码分析">(三)、LinkedList源码分析</h3><p>JDK7和JDK8中的LinkedList底层无差别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList(); <span class="comment">//内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 将123封装到Node中，创建了Node对象</span></span><br></pre></td></tr></table></figure><p>其中Node类为LinkedList的内部静态类，其定义体现了LinkedList的双向链表结构，定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四vector源码分析">(四)、Vector源码分析</h3><p>JDK7和JDK8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组；在扩容方面，默认每次扩容为当前数组长度的2倍</p><p>Stack类即栈是Vector子类</p><h3 id="五list接口中的常用方法">(五)、List接口中的常用方法</h3><ol type="1"><li><p>add</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span></span>; <span class="comment">//在index位置插入ele元素</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>addAll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Boolean <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection eles)</span></span>; <span class="comment">// 从index位置开始将eles中的所有元素加入到当前集合中</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">//获取指定index位置的元素</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>indexOf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>; <span class="comment">//返回obj在集合中首次出现的位置，若不存在返回-1</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>lastIndexOf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object obj)</span></span>; <span class="comment">//返回obj在集合中末次出现的位置，若不存在返回-1</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>remove</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">//移除指定index位置的元素，并返回此元素。是Collection中remove方法的重载</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span></span>; <span class="comment">//设置指定index位置的元素为ele</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>subList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>; <span class="comment">//返回从fromIndex到toIndex位置的左闭右开区间内的元素</span></span><br></pre></td></tr></table></figure><p></p><p>即List接口在Collection接口定义的方法基础上有定义了新的方法</p></li></ol><h3 id="六总结常用方法不去看api就能用">(六)、总结：常用方法（不去看API就能用）</h3><ol type="1"><li><p>增：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(Object obj)</span><br></pre></td></tr></table></figure></li><li><p>删</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove(<span class="keyword">int</span> index); / remove(Object obj)</span><br></pre></td></tr></table></figure></li><li><p>改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(<span class="keyword">int</span> index, Object ele);</span><br></pre></td></tr></table></figure></li><li><p>查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="keyword">int</span> index);</span><br></pre></td></tr></table></figure></li><li><p>插</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="keyword">int</span> index, Object ele)</span><br></pre></td></tr></table></figure></li><li><p>长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size()</span><br></pre></td></tr></table></figure></li><li><p>遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iterator迭代器方式</span><br><span class="line">增强<span class="keyword">for</span>循环</span><br><span class="line">普通循环</span><br></pre></td></tr></table></figure></li></ol><h2 id="五collection子接口二set重要性低于listmap">五、Collection子接口二：Set（重要性低于List、Map）</h2><h3 id="一set接口的框架">(一)、Set接口的框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">    /----Set接口：存储无序的、不可重复的数据</span><br><span class="line">    	/----HashSet：作为Set接口的主要实现类；线程不安全；可存储<span class="keyword">null</span>值</span><br><span class="line">    		/----LinkedHashSet：作为HashSet的子类；遍历其内部数据时可按照添加的顺序遍历</span><br><span class="line">    	/----TreeSet：底层使用二叉树中的红黑树存储数据；只能添加同一个类<span class="keyword">new</span>的对象，且可按照添加对象的指定属性进行排序</span><br></pre></td></tr></table></figure><p>Set接口中没有额外定义的新方法，使用的都是Collection中声明过的方法</p><h3 id="二理解set的无序性和不可重复性">(二)、理解Set的无序性和不可重复性</h3><p>以HashSet为例：</p><ol type="1"><li>无序性：不等于随机性<ul><li>存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值确定其位置</li><li>即不按照程序调用顺序添加元素</li></ul></li><li>不可重复性：保证添加的元素按照equals()方法判断时，不能返回true，即相同的元素只能添加一个</li></ol><h3 id="三添加元素的过程以jdk7-hashset为例">(三)、添加元素的过程：以JDK7 HashSet为例</h3><p>向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出此元素在HashSet底层数组中的存放位置（即为索引位置），判断数组此位置上是否已经有元素：</p><ul><li>如果此位置上没有其他元素，则元素a添加成功 ----&gt; 情况1</li><li>如果此位置上有其他元素b（或以链表形式存在的多个元素），则比较元素a与元素b的hash值：<ul><li>如果hash值不同，则元素a添加成功 ----&gt; 情况2</li><li>如果hash值相同，进而需要调用元素a所在类的equals()方法<ul><li>若equals()返回true，元素a添加失败</li><li>若equals()返回false，元素a添加成功 ----&gt; 情况3</li></ul></li></ul></li></ul><p>对于添加成功的情况2和3而言：元素a与已经存在保存在指定索引位置上的数据以链表方式存储。JDK7中元素a放在数组中，指向原来的所有元素的first；JDK8中原来的元素在数组或链表中，原来的元素的last指向元素a</p><p><strong>HashSet底层：数组+链表的结构</strong>，new的HashSet实际上内部new 的HashMap，而HashSet中的add()方法实际上调用的是HashMap的put()方法。（JDK7的底层数据，与HashMap相关）</p><h3 id="四hashcode的重写">(四)、hashCode()的重写</h3><figure><img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/76%20Day%20-%2002.png" alt="HashCode"><figcaption aria-hidden="true">HashCode</figcaption></figure><p>要求：</p><ul><li><p><strong>向Set中添加的数据，其所在类一定要重写hashCode()和equals()</strong></p></li><li><p><strong>重写的hashCode()和equals()尽可能保持一致性：相等的对象(equals()返回true)必须具有相等的散列码</strong></p><ul><li>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值</li><li>推荐使用IDE自动重写的方法</li></ul></li></ul><h3 id="五linkedhashset">(五)、LinkedHashSet</h3><p>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。</p><p>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p><h3 id="六treeset了解">(六)、TreeSet（了解）</h3><ol type="1"><li><p>向TreeSet中添加的数据，要求是相同类的对象，不能添加不同类的对象。从而实现按属性对对象排序（二叉树中的红黑树，排序复杂度为O(1)）</p></li><li><p>排序的两种方式：<strong>自然排序（实现Comparable接口） &amp; 定制排序 （实现Comparator接口）</strong></p><ul><li><p>自然排序（添加到TreeSet中的对象所属类实现Comparable接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.javapack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hunt Wu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-10-21:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        User user = (User) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != user.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(user.name) : user.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照姓名从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            User user = (User) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(user.name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TreeSetTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeSet treeSet = <span class="keyword">new</span> TreeSet();</span><br><span class="line"></span><br><span class="line">    treeSet.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> User(<span class="string">&quot;Jhon&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">15</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> User(<span class="string">&quot;Taylor&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> User(<span class="string">&quot;Hunt&quot;</span>, <span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = treeSet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Hunt&#x27;, age=24&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Jack&#x27;, age=15&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Jhon&#x27;, age=22&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Taylor&#x27;, age=25&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定制排序（）</p><ul><li>使用TreeSet构造函数的Comparator参数构造器，将匿名实现类的对象或匿名实现类的匿名对象作为参数</li></ul><figure><img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/77%20Day%20-%2002.png" alt="TreeSet"><figcaption aria-hidden="true">TreeSet</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TreeSetTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeSet treeSet2 = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">        <span class="comment">// 年龄从小到大排序</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                User user1 = (User) o1;</span><br><span class="line">                User user2 = (User) o2;</span><br><span class="line">                <span class="comment">// return ((Integer)user1.getAge()).compareTo(user2.getAge());</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(user1.getAge(), user2.getAge());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;比较类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    treeSet2.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">    treeSet2.add(<span class="keyword">new</span> User(<span class="string">&quot;Jhon&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    treeSet2.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">15</span>));</span><br><span class="line">    treeSet2.add(<span class="keyword">new</span> User(<span class="string">&quot;Taylor&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    treeSet2.add(<span class="keyword">new</span> User(<span class="string">&quot;Hunt&quot;</span>, <span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = treeSet2.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Jack&#x27;, age=15&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Jhon&#x27;, age=22&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Hunt&#x27;, age=24&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Taylor&#x27;, age=25&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>TreeSet中判断添加的两个对象是否相同</strong>：</p><ul><li>自然排序中比较两个对象是否相同的标准：compareTo()方法返回0，不再是equals()</li><li>定制排序中比较两个对象是否相同的标准：compare()方法返回0，不再是equals()</li></ul></li></ol><h2 id="六map接口">六、Map接口</h2><p>与Collection接口并列</p><h3 id="一map接口继承树">(一)、Map接口继承树</h3><figure><img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/78%20Day%20-%2002.png" alt="Map"><figcaption aria-hidden="true">Map</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/----Map：双列数据，保存具有映射关系“key-value对”的集合 ---&gt; 数学上的“函数”：y = f(x) 【value = f(key)】</span><br><span class="line">    /----HashMap:作为Map的主要实现类，线程不安全，效率高；可存储<span class="keyword">null</span>的key和value，健壮性好。底层使用 数组+链表(JDK7)、数组+链表+红黑树(JDK8)</span><br><span class="line">		/----LinkedHashMap：保证遍历map元素时，可按照添加的顺序实现遍历输出</span><br><span class="line">        				原因：在原有的HashMap底层结构基础上，添加了一对引用分别记录当前HashMap节点的前一个和后一个元素</span><br><span class="line">        				对于频繁的遍历操作，此类的执行效率高于HashMap</span><br><span class="line">	/----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历；按照key排序（考虑key的自然排序和定制排序），底层使用红黑树</span><br><span class="line">	/----Hashtable:作为Map的古老实现类，线程安全，效率低；不可存储<span class="keyword">null</span>的key和value</span><br><span class="line">		/----Properties:常用来处理配置文件；特点：key和value都是String类型</span><br><span class="line">先出现的Hashtble，后出现Map接口来规范键值对的规则，并使用HashMap作为其主要实现类，TreeMap针对有顺序的Map，由于HashMap的插删数据不方便，因此出现了LinkedHashMap</span><br></pre></td></tr></table></figure><h3 id="二map结构的理解">(二)、Map结构的理解</h3><p>Map中的key：无序的、不可重复的，使用Set存储所有的key ----&gt; key所在的类要重写equals()和hashCode()（以HashMap为例）</p><p>Map中的value：无序的、可重复的，使用Collection存储所有的value ----&gt; key所在的类要重写equals()（以HashMap为例）</p><p>一个键值对：key-value构成一个Entry对象</p><p>Map中的entry：无序的、不可重复的，使用Set存储所有的entry</p><h3 id="三hashmap的底层实现原理jdk7为例">(三)、HashMap的底层实现原理（JDK7为例）</h3><ol type="1"><li><p>实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">// 在实例化后，底层创建了长度是16的一维数组Entry[] table。</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>添加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">....<span class="comment">// 已经执行过0次或多次put方法</span></span><br><span class="line">map.put(key1, value1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先，调用key1所在类的hashCode方法，计算key1哈希值，此哈希值经过某种算法计算后，得到在Entry数组中的存放位置</span></span><br><span class="line"><span class="comment">// 如果此位置上数据为空，此时的(key1, value1)添加成功。 ----情况1</span></span><br><span class="line"><span class="comment">// 如果此位置上的数据不为空，（此位置上存在着一个或多个数据（以链表形式存在）），比较key1和已经存在的一个或多个数据的哈希值：</span></span><br><span class="line"><span class="comment">// 		如果key1的哈希值与已经存在的数据的哈希值都不相同，此时的key1-value1添加成功 ----情况2</span></span><br><span class="line"><span class="comment">// 		如果key1的哈希值与已经存在的某一个数据(key2-value2)的哈希值相同，则调用key1所在类的equals(key2)方法</span></span><br><span class="line"><span class="comment">// 			如果equals(key2)方法返回false，则key1-value1添加成功  ----情况3</span></span><br><span class="line"><span class="comment">// 			如果equals(key2)方法返回true，则value2被替换为value1（put具有修改功能）</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>情况2和情况3：新添加的数据和原来的数据以链表的方式存储，新添加数据在数组中(JDK7)，或新添加数据放在最后(JDK8)，同一位置多个元素以单向链表形式存储</p></li><li><p>不断添加过程中，会涉及扩容问题，当当前数组中的已存元素超过临界值（且当前key-value要存放的位置非空时）则扩容。默认的添加方式：数组扩容为原来的2倍，并将原来的数据重新计算哈希值Map到新数组中。</p></li></ol><h3 id="四jdk8相较于jdk7在底层实现方面的不同">(四)、JDK8相较于JDK7在底层实现方面的不同</h3><ol type="1"><li><p>实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">// 底层没有创建一个长度为16的数组。</span></span><br><span class="line"><span class="comment">// 底层的数组为Node[]，而不是Entry[]数组</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>首次调用put方法时，底层创建长度为16的数组</p></li><li><p>JDK7底层结构只有 数组+链表；JDK8底层结构有 数组+链表+红黑树</p><ul><li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所有数据改为使用红黑树存储（优化查找效率）</li></ul></li></ol><h3 id="五hashmap中的重要常量jdk8">(五)、HashMap中的重要常量（JDK8）</h3><blockquote><p><strong>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</strong> MAXIMUM_CAPACITY ： HashMap的最大支持容量，2^30 <strong>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子</strong></p><p><strong>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树</strong></p><p>UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表</p><p><strong>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。）</strong> table：存储元素的数组，总是2的n次幂 entrySet：存储具体元素的集 size：HashMap中存储的键值对的数量 modCount：HashMap扩容和结构改变的次数。 **threshold：扩容的临界值，=容量*填充因子** loadFactor：填充因子</p></blockquote><h3 id="六linkedhashmap的底层实现原理">(六)、LinkedHashMap的底层实现原理</h3><p>LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap。区别在于LinkedHashMap内部提供了Entry，替换HashMap中的Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after; <span class="comment">// 记录添加元素的先后顺序</span></span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七map中定义的方法">(七)、Map中定义的方法</h3><p>添加、删除、修改操作</p><ol type="1"><li><p>put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">put</span><span class="params">(Object key, Object value)</span>: 将指定key-value添加到（或修改）当前map对象中</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>putAll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map m)</span>: 将m中所有的key-value对添加到当前map中</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>remove</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(Object key)</span>: 移除指定key的key-value对，并返回value</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>clear</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>：清空当前map中的所有数据</span></span><br></pre></td></tr></table></figure><p></p></li></ol><p>元素查询的操作</p><ol type="1"><li><p>get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object key)</span>：获取指定key对应的value</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>containsKey</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span>：是否包含指定的key</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>containsValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span>：是否包含指定的value</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>size</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>：返回map中key-value对的个数</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>isEmpty</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：判断当前map是否为空</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>equals</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：判断当前map和参数对象obj是否相等</span></span><br></pre></td></tr></table></figure><p></p></li></ol><p>元视图操作的方法</p><ol type="1"><li><p>keySet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Set <span class="title">keySet</span><span class="params">()</span>：返回所有key构成的Set集合</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>values</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Collection <span class="title">values</span><span class="params">()</span>：返回所有value构成的Collection集合</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>entrySet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Set <span class="title">entrySet</span><span class="params">()</span>：返回所有key-value对构成的Set集合</span></span><br></pre></td></tr></table></figure><p></p></li></ol><p>总结：常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">添加：<span class="function">Object <span class="title">put</span><span class="params">(Object key, Object value)</span></span></span><br><span class="line"><span class="function">删除：Object <span class="title">remove</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">修改：Object <span class="title">put</span><span class="params">(Object key, Object value)</span></span></span><br><span class="line"><span class="function">查询：Object <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">长度：<span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">遍历：Set <span class="title">keySet</span><span class="params">()</span> / Collection <span class="title">values</span><span class="params">()</span> / Set <span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br></pre></td></tr></table></figure><h3 id="八treemap">(八)、TreeMap</h3><p>向TreeMap中添加key-value，要求key必须是由用一个类创建的对象。因为要按照key进行排序：自然排序、定制排序</p><h3 id="九properties">(九)、Properties</h3><ol type="1"><li>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</li><li>在程序中加载配置文件使用Properties对象的load(InputStream instream)方法</li><li>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key和 value 都是字符串类型</li><li>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法</li></ol><p>IDEA下的配置文件：</p><ul><li>一般在当前工程文件夹下</li><li>新建配置文件：右键工程名 -- New -- File 或者 Resource Bundle，扩展名为.properties</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置文件 jdbc.properties</span></span><br><span class="line">name=Tom</span><br><span class="line">password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><ul><li>java代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProperties</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;../jdbc.properties&quot;</span>);</span><br><span class="line">    properties.load(fis); <span class="comment">// 加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">    String name = properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    <span class="comment">// name = Tom, password = 123456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七collections工具类">七、Collections工具类</h2><ul><li>Collections 是一个<strong>操作 Collection 和 Map 等集合</strong>的工具类（操作数组的工具类：Arrays）</li><li>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</li></ul><p>排序操作：（均为static方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reverse(List)：反转 List 中元素的顺序</span><br><span class="line">shuffle(List)：对 List 集合元素进行随机排序</span><br><span class="line">sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span><br><span class="line">sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line">swap(List，<span class="keyword">int</span>， <span class="keyword">int</span>)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br></pre></td></tr></table></figure><p>查找、替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection)</span>：根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection，Comparator)</span>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection)</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection，Comparator)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection，Object)</span>：返回指定集合中指定元素的出现次数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span>：将src中的内容复制到dest中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list，Object oldVal，Object newVal)</span>：使用新值替换List 对象的所有旧值</span></span><br></pre></td></tr></table></figure><ul><li><p>Copy()方法：要求dest的size要大于list的size，否则抛异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCollections</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        // java.lang.IndexOutOfBoundsException: Source does not fit in dest</span></span><br><span class="line">    <span class="comment">//        List dest = new ArrayList();</span></span><br><span class="line">    <span class="comment">//        Collections.copy(dest, list);</span></span><br><span class="line">    List dest = Arrays.asList(<span class="keyword">new</span> Object[list.size()]);</span><br><span class="line">    Collections.copy(dest, list);</span><br><span class="line"></span><br><span class="line">    System.out.println(dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>同步控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</span><br></pre></td></tr></table></figure><figure><img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/79%20Day%20-%2002.png" alt="synchronized"><figcaption aria-hidden="true">synchronized</figcaption></figure><h2 id="面试题">面试题</h2><ol type="1"><li><p>ArrayList、LinkedList、Vector三者异同</p><ul><li>同：三个类都实现了List接口，存储数据的特点相同：存储有序、可重复的数据</li><li>异：<ul><li>ArrayList：<ul><li>作为List接口的主要实现类</li><li>线程不安全，因此效率高</li><li>底层使用Object[] elementData存储</li></ul></li><li>LinkedList：<ul><li>对于频繁的插入、删除操作，使用此类效率比ArrayList高</li><li>底层使用双向链表</li></ul></li><li>Vector：<ul><li>作为List接口的古老实现类。【JDK1.0时即存储有序、可重复的数据，JDK1.2后出现的List接口，且紧接着出现了两个实现类ArrayList、LinkedList，后把Vector归入List接口的实现类】</li><li>线程安全，效率低</li><li>底层使用Object[] elementData存储</li></ul></li></ul></li></ul></li><li><p>区分List中的remove(int index)和remove(Object obj)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListRemove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    updateList(list);</span><br><span class="line">    System.out.printl(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">    list.remove(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HashMap的底层实现原理？</p></li><li><p>HashMap和Hashtable的异同？</p></li><li><p>CurrentHashMap和Hashtable的异同？</p></li><li><p>Collection和Collections的区别？</p></li><li><p>负载因子值的大小，对HashMap有什么影响</p><blockquote><ul><li>负载因子的大小决定了HashMap的数据密度。</li><li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。</li><li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</li><li>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。</li></ul></blockquote></li></ol><h2 id="每日一考">每日一考</h2><ol type="1"><li><p>说说你所理解的集合框架都有哪些接口，存储数据的特点是什么？</p><ul><li>Collection：单列集合，用于存储一个一个的对象<ul><li>List：有序的、可重复的集合</li><li>Set：无序的、不可重复的集合</li></ul></li><li>Map：双列数据，保存具有映射关系“key-value对”的集合</li></ul></li><li><p>比较throw和throws的异同</p><ul><li>throw：生成一个异常对象并抛出（手动抛出异常），使用在方法内部；和自动抛出异常对应</li><li>throws：异常处理的一种方式。和try-catch-finally对象</li></ul></li><li><p>谈谈你对同步代码块中同步监视器和共享数据的理解及各自要求</p><p>同步监视器：俗称锁，任何一个类的对象都可充当锁。多个线程共用一把锁</p><p>共享数据：多个线程共同操作的数据</p><p>需要使用同步机制将操作共享数据的代码包起来，既不能包多、也不能包少</p></li><li><p>集合Collection中存储的如果是自定义类的对象，需要自定义类重写哪个方法？为什么？‘</p><p>需要重写equals()方法，当集合对象调用contains方法时，会调用集合存储元素的equals()方法，如自定义类未重写equals()方法则默认使用Object类中的equals()方法即使用 == 符号判断</p><ul><li>List：重写equals()方法</li><li>Set：<ul><li>HashSet、LinkedHashSet：重写equals()、hashCode()</li><li>TreeSet：Comparable接口( compareTo(Object o) )、Comparator接口( compare(Object o1, Object o2) )</li></ul></li></ul></li><li><p>ArrayList、LinkedList、Vector三者的相同点与不同点？【面试题】</p></li><li><p>List接口的常用方法有哪些？(增、删、改、查、插、长度、遍历)</p><ul><li>增：add(Object obj)</li><li>删：remove(int index) / remove(Object obj)</li><li>改：set(int index, Object ele)</li><li>查：get(int index)</li><li>插：add(int index, Object ele)</li><li>长度：size()</li><li>遍历：itertor()，for循环 或增强for循环</li></ul></li><li><p>如何使用Iterator和增强for循环遍历List</p></li><li><p>Set存储数据的特点是什么？常见的实现类有什么？说明彼此的特点</p><ul><li>特点：存储无序、不可重复数据</li><li>实现类：HashSet、LinkedHashSet、TreeSet<ul><li>HashSet：底层使用HashMap</li><li>LinkedHashSet：底层使用LinkedHashMap</li><li>TreeSet：底层使用TreeMap</li></ul></li></ul></li><li><p>练习</p><ul><li><p>在List内去除重复数字值，要求尽量简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDuplicateList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">4</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    List list2 = duplicateList(list);</span><br><span class="line">    Iterator iterator = list2.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayList <span class="title">duplicateList</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    HashSet hashSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">    hashSet.addAll(list);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(hashSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// User类重写了HashCode和equals</span></span><br><span class="line">    HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    User u1 = <span class="keyword">new</span> User(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    User u2 = <span class="keyword">new</span> User(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set.add(u1);</span><br><span class="line">    set.add(u2);</span><br><span class="line">    u1.setName(<span class="string">&quot;CC&quot;</span>);<span class="comment">// 属性变动，Hash值也会变，但add后变化不会检查</span></span><br><span class="line">    set.remove(u1); <span class="comment">// remove需要先判断</span></span><br><span class="line">    System.out.println(set); <span class="comment">//u1 u2</span></span><br><span class="line">    <span class="comment">// [User&#123;name=&#x27;CC&#x27;, age=1001&#125;, User&#123;name=&#x27;BB&#x27;, age=1002&#125;]</span></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    <span class="comment">// [User&#123;name=&#x27;CC&#x27;, age=1001&#125;, User&#123;name=&#x27;CC&#x27;, age=1001&#125;, User&#123;name=&#x27;BB&#x27;, age=1002&#125;]</span></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    <span class="comment">// [User&#123;name=&#x27;CC&#x27;, age=1001&#125;, User&#123;name=&#x27;CC&#x27;, age=1001&#125;,</span></span><br><span class="line">    <span class="comment">// User&#123;name=&#x27;AA&#x27;, age=1001&#125;, User&#123;name=&#x27;BB&#x27;, age=1002&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Map存储数据的特点？并指明key、value、entry存储数据的特点</p><ul><li>双列数据，存储key-value对数据</li><li>key：无序的、不可重复的。相当于使用Set存储</li><li>value：无序的、可重复的。相当于使用Collection存储</li><li>entry：无序的、不可重复的。相当于使用Set存储</li></ul></li><li><p>描述HashMap的底层实现原理（JDK8）</p></li><li><p>Map中常用实现类有哪些？各自有什么特点？</p><blockquote><p>/----Map：双列数据，保存具有映射关系“key-value对”的集合 ---&gt; 数学上的“函数”：y = f(x) 【value = f(key)】 /----HashMap:作为Map的主要实现类，线程不安全，效率高；可存储null的key和value，健壮性好。底层使用 数组+链表(JDK7)、数组+链表+红黑树(JDK8) /----LinkedHashMap：保证遍历map元素时，可按照添加的顺序实现遍历输出 原因：在原有的HashMap底层结构基础上，添加了一对引用分别记录当前HashMap节点的前一个和后一个元素 对于频繁的遍历操作，此类的执行效率高于HashMap /----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历；按照key排序（考虑key的自然排序和定制排序），底层使用红黑树 /----Hashtable:作为Map的古老实现类，线程安全，效率低；不可存储null的key和value /----Properties:常用来处理配置文件；特点：key和value都是String类型</p></blockquote></li><li><p>如何遍历Map中的key-value对，代码实现</p></li><li><p>Map中的常用方法</p></li><li><p>Collection和Collections的区别</p></li></ol></div><div class="popular-posts-header">相关文章推荐</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2022/02/20/Coding/Java/17Java9&Java10&Java11新特性/" rel="bookmark">第17章 Java9&Java10&Java11新特性</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2022/02/15/Coding/Java/16Java8的其他新特性/" rel="bookmark">第16章 Java8的其他新特性</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2022/02/11/Coding/Java/15Java反射机制/" rel="bookmark">第15章 Java反射机制</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2022/01/25/Coding/Java/14网络编程/" rel="bookmark">第14章 网络编程</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2022/01/13/Coding/Java/12泛型/" rel="bookmark">第12章 泛型与File</a></div></li></ul><footer class="post-footer"><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作</div><button>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="Hunt 微信"> <span>微信</span></div><div><img src="/images/alipay.png" alt="Hunt 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Hunt</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/" title="第11章 Java集合">https://pku-hunterwu.github.io/2021/12/31/Coding/Java/11Java集合/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a></div><div class="post-widgets"><div class="wpac-rating-container"><div id="wpac-rating"></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/12/25/Coding/Java/10%E6%9E%9A%E4%B8%BE%E7%B1%BB/" rel="prev" title="第10章 枚举类与注解"><i class="fa fa-chevron-left"></i> 第10章 枚举类与注解</a></div><div class="post-nav-item"><a href="/2022/01/07/Coding/Java/11dot5Java%E7%89%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/" rel="next" title="第11.5章 Java版数据结构概述">第11.5章 Java版数据结构概述 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81NDc1Ny8zMTIyOA=="></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Hunt</span> &nbsp &nbsp <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("11/21/2021 8:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">271k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">4:06</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://embed.widgetpack.com/widget.js" async></script><script class="next-config" data-name="rating" type="application/json">{"enable":"ftrue","id":32964,"color":"#fc6423"}</script><script src="/js/third-party/rating.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"HGG0QbARovy9h4uJosLzs6RE-gzGzoHsz","app_key":"UncCQE6nDIEgxN0iPiz1UVSQ","server_url":"https://hgg0qbar.lc-cn-n1-shared.com","security":false}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script><script src="/js/third-party/math/mathjax.js"></script><div class="livere-card card" data-aos="fade-up"><style>#taboola-livere{display:none}</style><div id="lv-container" class="card-content" data-id="city" data-uid="<%- theme.livere.uid %>"><script type="text/javascript">(function (d, s) { let j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') { return; } j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript。</noscript></div></div><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item" onclick="back2bottom()"><i class="fa fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item" onclick="back2top()"><i class="fa fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><script async src="/js/cursor/fireworks.js"></script></body></html>