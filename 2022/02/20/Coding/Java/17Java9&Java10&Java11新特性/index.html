<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-H.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-H.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-H.png"><link rel="mask-icon" href="/images/favicon-H.png" color="#222"><meta name="msvalidate.01" content="7712DDD8033784B9F5BC335DB79AE423"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"pku-hunterwu.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="第17章、Java9&amp;Java10&amp;Java11新特性 目录  一、Java9 的新特性 二、Java10 的新特性 三、Java11 的新特性 四、当前 JDK 中看不到什么 五、展望"><meta property="og:type" content="article"><meta property="og:title" content="第17章 Java9&amp;Java10&amp;Java11新特性"><meta property="og:url" content="https://pku-hunterwu.github.io/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/index.html"><meta property="og:site_name" content="Hunt&#39;s Blog"><meta property="og:description" content="第17章、Java9&amp;Java10&amp;Java11新特性 目录  一、Java9 的新特性 二、Java10 的新特性 三、Java11 的新特性 四、当前 JDK 中看不到什么 五、展望"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pku-hunterwu.github.io/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/102%20Day%20-%2002.png"><meta property="og:image" content="https://pku-hunterwu.github.io/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/103%20Day%20-%2002.png"><meta property="og:image" content="https://pku-hunterwu.github.io/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/104%20Day%20-%2002.png"><meta property="article:published_time" content="2022-02-20T02:38:43.000Z"><meta property="article:modified_time" content="2022-02-20T02:38:43.000Z"><meta property="article:author" content="Hunt"><meta property="article:tag" content="笔记"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pku-hunterwu.github.io/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/102%20Day%20-%2002.png"><link rel="canonical" href="https://pku-hunterwu.github.io/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://pku-hunterwu.github.io/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/","path":"2022/02/20/Coding/Java/17Java9&Java10&Java11新特性/","title":"第17章 Java9&Java10&Java11新特性"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>第17章 Java9&Java10&Java11新特性 | Hunt's Blog</title><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Hunt's Blog</h1><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">1</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">18</span></a></li><li class="menu-item menu-item-友链"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC17%E7%AB%A0java9java10java11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">第17章、Java9&amp;Java10&amp;Java11新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80java9%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">一、Java9的新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9Fjigsaw---modularity"><span class="nav-text">(二)、模块化系统(Jigsaw -&gt; Modularity)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89java%E7%9A%84repl%E5%B7%A5%E5%85%B7-jshell%E5%91%BD%E4%BB%A4"><span class="nav-text">(三)、Java的REPL工具： jShell命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E8%AF%AD%E6%B3%95%E6%94%B9%E8%BF%9B%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-text">(四)、语法改进：接口的私有方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E8%AF%AD%E6%B3%95%E6%94%B9%E8%BF%9B%E9%92%BB%E7%9F%B3%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BD%BF%E7%94%A8%E5%8D%87%E7%BA%A7"><span class="nav-text">(五)、语法改进：钻石操作符使用升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E8%AF%AD%E6%B3%95%E6%94%B9%E8%BF%9Btry%E8%AF%AD%E5%8F%A5"><span class="nav-text">(六)、语法改进：try语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83string%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%98%E6%9B%B4"><span class="nav-text">(七)、String存储结构变更</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E5%8F%AA%E8%AF%BB%E9%9B%86%E5%90%88"><span class="nav-text">(八)、集合工厂方法：快速创建只读集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9Dinputstream-%E5%8A%A0%E5%BC%BA"><span class="nav-text">(九)、InputStream 加强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E5%A2%9E%E5%BC%BA%E7%9A%84stream-api"><span class="nav-text">(十)、增强的Stream API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%B8%80optional%E8%8E%B7%E5%8F%96stream%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">(十一)、Optional获取Stream的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%BA%8Cjavascript%E5%BC%95%E6%93%8E%E5%8D%87%E7%BA%A7nashorn"><span class="nav-text">(十二)、Javascript引擎升级：Nashorn</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8Cjava10%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">二、Java10的新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-text">(一)、局部变量类型推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E9%9B%86%E5%90%88%E6%96%B0%E5%A2%9E%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">(二)、集合新增创建不可变集合的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89java11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">三、Java11的新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80jdk-11-%E6%98%AF%E4%B8%80%E4%B8%AA%E9%95%BF%E6%9C%9F%E6%94%AF%E6%8C%81%E7%89%88%E6%9C%AClts-long-term-support"><span class="nav-text">(一)、JDK 11 是一个长期支持版本（LTS, Long-Term-Support）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%AE%98%E7%BD%91%E5%85%AC%E5%BC%80%E7%9A%84-17-%E4%B8%AA-jepjdk-enhancement-proposal-%E7%89%B9%E6%80%A7%E5%A2%9E%E5%BC%BA%E6%8F%90%E8%AE%AE"><span class="nav-text">(二)、官网公开的 17 个 JEP（JDK Enhancement Proposal 特性增强提议）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%96%B0%E5%A2%9E%E4%BA%86%E4%B8%80%E7%B3%BB%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-text">(三)、新增了一系列字符串处理方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9Boptional-%E5%8A%A0%E5%BC%BA"><span class="nav-text">(四)、Optional 加强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E5%8D%87%E7%BA%A7"><span class="nav-text">(五)、局部变量类型推断升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E5%85%A8%E6%96%B0%E7%9A%84http-%E5%AE%A2%E6%88%B7%E7%AB%AFapi"><span class="nav-text">(六)、全新的HTTP 客户端API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E6%9B%B4%E7%AE%80%E5%8C%96%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-text">(七)、更简化的编译运行程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E5%BA%9F%E5%BC%83nashorn%E5%BC%95%E6%93%8E"><span class="nav-text">(八)、废弃Nashorn引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9Dzgc"><span class="nav-text">(九)、ZGC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">(十)、其他新特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E5%BD%93%E5%89%8Djdk%E4%B8%AD%E7%9C%8B%E4%B8%8D%E5%88%B0%E4%BB%80%E4%B9%88"><span class="nav-text">四、当前JDK中看不到什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E5%8C%96%E5%92%8C%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84json-api"><span class="nav-text">(一)、一个标准化和轻量级的JSON API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E6%96%B0%E7%9A%84%E8%B4%A7%E5%B8%81api"><span class="nav-text">(二)、新的货币API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E5%B1%95%E6%9C%9B"><span class="nav-text">五、展望</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" alt="Hunt" src="/images/HarryPotter.png"></a><p class="site-author-name" itemprop="name">Hunt</p><div class="site-description" itemprop="description">个人博客，记录、分享计算机编程相关技术，包括Java、MySQL、Web等相关技术内容。</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/PKU-HunterWu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PKU-HunterWu" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1457509769@qq.com" title="E-Mail → mailto:1457509769@qq.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.pku.edu.cn/" title="https:&#x2F;&#x2F;www.pku.edu.cn" rel="noopener external nofollow noreferrer" target="_blank">PKU官网</a></li><li class="links-of-blogroll-item"><a href="https://bbs.pku.edu.cn/v2/home.php" title="https:&#x2F;&#x2F;bbs.pku.edu.cn&#x2F;v2&#x2F;home.php" rel="noopener external nofollow noreferrer" target="_blank">北大未名BBS</a></li><li class="links-of-blogroll-item"><a href="https://github.com/PKU-HunterWu" title="https:&#x2F;&#x2F;github.com&#x2F;PKU-HunterWu" rel="noopener external nofollow noreferrer" target="_blank">PKU-HunterWu</a></li></ul><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),today=(new Date).toLocaleString(),document.getElementById("days").innerHTML=today}function show_running_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("11/21/2021 8:00:00"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="本站已安全运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒"}function setzero(e){return e<10&&(e="0"+e),e}show_date_time()</script></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/PKU-HunterWu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener external nofollow noreferrer" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://pku-hunterwu.github.io/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/HarryPotter.png"><meta itemprop="name" content="Hunt"><meta itemprop="description" content="个人博客，记录、分享计算机编程相关技术，包括Java、MySQL、Web等相关技术内容。"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hunt's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">第17章 Java9&Java10&Java11新特性</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-02-20 10:38:43" itemprop="dateCreated datePublished" datetime="2022-02-20T10:38:43+08:00">2022-02-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">程序设计</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a> </span></span><span id="/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/" class="post-meta-item leancloud_visitors" data-flag-title="第17章 Java9&Java10&Java11新特性" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>18k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>16 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="第17章java9java10java11新特性">第17章、Java9&amp;Java10&amp;Java11新特性</h1><h2 id="目录">目录</h2><ol type="1"><li>一、Java9 的新特性</li><li>二、Java10 的新特性</li><li>三、Java11 的新特性</li><li>四、当前 JDK 中看不到什么</li><li>五、展望</li></ol><span id="more"></span><h2 id="一java9的新特性">一、Java9的新特性</h2><blockquote><ul><li>经过4次跳票，历经曲折的Java 9 终于终于在2017年9月21日发布。</li><li>从Java 9 这个版本开始，Java 的计划发布周期是6 个月，下一个Java 的主版本将于2018 年3 月发布，命名为Java 18.3，紧接着再过六个月将发布Java 18.9。</li><li>这意味着Java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的（6 个月为周期）发布模式，并逐步的将Oracle JDK 原商业特性进行开源。</li><li>针对企业客户的需求，Oracle 将以三年为周期发布长期支持版本（long term support）。</li></ul></blockquote><p>Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。可以说Java 9是一个庞大的系统工程，完全做了一个整体改变。</p><blockquote><p><strong>模块化系统</strong> <strong>jShell命令</strong></p><p>多版本兼容jar包</p><p>接口的私有方法</p><p>钻石操作符的使用升级</p><p>语法改进：try语句</p><p>String存储结构变更</p><p>便利的集合特性：of()</p><p>增强的StreamAPI</p><p>全新的HTTP客户端API</p><p>Deprecated的相关API</p><p>javadoc的HTML 5支持</p><p>Javascript引擎升级：Nashorn</p><p>java的动态编译器</p></blockquote><p>JDK8之前目录：</p><figure><img src="/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/102%20Day%20-%2002.png" alt="JDK8"><figcaption aria-hidden="true">JDK8</figcaption></figure><p>JDK9之后目录结构：</p><figure><img src="/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/103%20Day%20-%2002.png" alt="JDK8"><figcaption aria-hidden="true">JDK8</figcaption></figure><h3 id="二模块化系统jigsaw---modularity">(二)、模块化系统(Jigsaw -&gt; Modularity)</h3><ul><li>谈到 Java 9 大家往往第一个想到的就是 Jigsaw 项目。众所周知，Java 已经发展超过 20 年（95 年最初发布），Java 和相关生态在不断丰富的同时也越来越暴露出一些问题：<ul><li><strong>Java 运行环境的膨胀和臃肿</strong>。每次JVM启动的时候，至少会有30～60MB的内存加载，主要原因是<strong>JVM需要加载rt.jar</strong>，不管其中的类是否被classloader加载，第一步整个jar都会被JVM加载到内存当中去（而模块化可以根据模块的需要加载程序运行需要的class）</li><li><strong>当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长</strong>。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了 Java 开发和运行效率的提升。</li><li>很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。<strong>每一个公共类都可以被类路径之下任何其它的公共类所访问到，这样就会导致无意中使用了并不想被公开访问的API。</strong></li></ul></li><li>本质上讲也就是说，用模块来管理各个package，通过声明某个package暴露，，模块(module)的概念，其实就是package外再裹一层，不声明默认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪些部分可以暴露，哪些部分隐藏。</li><li>实现目标<ul><li>模块化的主要目的在于减少内存的开销</li><li>只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开发和维护</li><li>改进 Java SE 平台，使其可以适应不同大小的计算设备</li><li>改进其安全性，可维护性，提高性能</li></ul></li><li>模块将由通常的类和新的模块<strong>声明文件（module-info.java）</strong>组成。该文件是位于java代码结构的顶层，<strong>该模块描述符明确地定义了我们的模块需要什么依赖关系，以及哪些模块被外部使用。在exports子句中未提及的所有包默认情况下将封装在模块中，不能在外部使用</strong>。</li></ul><h3 id="三java的repl工具-jshell命令">(三)、Java的REPL工具： jShell命令</h3><ul><li>产生背景 像Python 和 Scala 之类的语言早就有交互式编程环境 REPL (read - evaluate - print -loop)了，以交互式的方式对语句和表达式进行求值。开发者只需要输入一些代码，就可以在编译前获得对程序的反馈。而之前的Java版本要想执行代码，必须创建文件、声明类、提供测试方法方可实现。</li><li>设计理念 即写即得、快速运行</li><li>实现目标<ul><li>Java 9 中终于拥有了 REPL工具：jShell。让Java可以像脚本语言一样运行，从控制台启动jShell，利用jShell在没有创建类的情况下直接声明变量，计算表达式，执行语句。即开发时可以在命令行里直接运行Java的代码，而无需创建Java文件，无需跟人解释”public static void main(String[] args)”这句废话。</li><li>jShell也可以从文件中加载语句或者将语句保存到文件中。</li><li>jShell也可以是tab键进行自动补全和自动添加分号。</li></ul></li></ul><h3 id="四语法改进接口的私有方法">(四)、语法改进：接口的私有方法</h3><ul><li>Java 8中规定接口中的方法除了抽象方法之外，还可以定义静态方法和默认的方法。一定程度上，扩展了接口的功能，此时的接口更像是一个抽象类。<ul><li>Java 8中的接口中的方法（抽象、默认、静态）都是public的</li><li><strong>Java 8中，接口中的静态方法只能由接口自己调用，接口的实现类不可调用</strong></li></ul></li><li>在Java 9中，接口更加的灵活和强大，连方法的访问权限修饰符都可以声明为private的了，此时方法将不会成为你对外暴露的API的一部分<ul><li>Java 9中，接口中的私有方法不能在接口外调用</li></ul></li></ul><h3 id="五语法改进钻石操作符使用升级">(五)、语法改进：钻石操作符使用升级</h3><p>我们将能够与匿名实现类共同使用钻石操作符（diamond operator）在Java 8中如下的操作是会报错的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Object&gt; com = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 编译报错信息：Cannot use “&lt;&gt;” with anonymous inner classes</span></span><br></pre></td></tr></table></figure><p>与之相应的类型推断是在jdk7中提出的，但类型推断和匿名实现类不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>匿名实现类报错的原因是：jdk8中编译器的优化不好，因此需要在jdk8下匿名实现类的钻石操作符需要显式声明泛型类型。Java 9中已经优化了，以上匿名实现类不会报错</p><h3 id="六语法改进try语句">(六)、语法改进：try语句</h3><p>Java 8之前资源关闭操作：try {} catch() {} finally{}，资源关闭需要手动放在finally体中</p><p>Java 8 中，可以实现资源的自动关闭，但是要求执行后必须关闭的所有资源必须在try子句中初始化，否则编译不通过。如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try()中的资源会自动关闭</span></span><br><span class="line"><span class="comment">// 要求自动关闭的资源的实例化必须放在try的小括号中</span></span><br><span class="line"><span class="keyword">try</span>(InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in))&#123;</span><br><span class="line"><span class="comment">//读取数据细节省略</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 9 中，用资源语句编写try将更容易，我们可以在try子句中使用已经初始化过的资源，此时的资源是final的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时的资源变量是final的，不可在try结构中修改</span></span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in); OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(System.out); <span class="keyword">try</span> (reader; writer) &#123;</span><br><span class="line">    <span class="comment">//reader是final的，不可再被赋值</span></span><br><span class="line">    <span class="comment">//reader = null;</span></span><br><span class="line">	<span class="comment">//具体读写操作省略</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七string存储结构变更">(七)、String存储结构变更</h3><ul><li><p>Motivation</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The current implementation of the String <span class="class"><span class="keyword">class</span> <span class="title">stores</span> <span class="title">characters</span> <span class="title">in</span> <span class="title">a</span> <span class="title">char</span> <span class="title">array</span>, <span class="title">using</span> <span class="title">two</span> <span class="title">bytes</span> (<span class="title">sixteen</span> <span class="title">bits</span>) <span class="title">for</span> <span class="title">each</span> <span class="title">character</span>. <span class="title">Data</span> <span class="title">gathered</span> <span class="title">from</span> <span class="title">many</span> <span class="title">different</span> <span class="title">applications</span> <span class="title">indicates</span> <span class="title">that</span> <span class="title">strings</span> <span class="title">are</span> <span class="title">a</span> <span class="title">major</span> <span class="title">component</span> <span class="title">of</span> <span class="title">heap</span> <span class="title">usage</span> <span class="title">and</span>, <span class="title">moreover</span>, <span class="title">that</span> <span class="title">most</span> <span class="title">String</span> <span class="title">objects</span> <span class="title">contain</span> <span class="title">only</span> <span class="title">Latin</span>-1 <span class="title">characters</span>. <span class="title">Such</span> <span class="title">characters</span> <span class="title">require</span> <span class="title">only</span> <span class="title">one</span> <span class="title">byte</span> <span class="title">of</span> <span class="title">storage</span>, <span class="title">hence</span> <span class="title">half</span> <span class="title">of</span> <span class="title">the</span> <span class="title">space</span> <span class="title">in</span> <span class="title">the</span> <span class="title">internal</span> <span class="title">char</span> <span class="title">arrays</span> <span class="title">of</span> <span class="title">such</span> <span class="title">String</span> <span class="title">objects</span> <span class="title">is</span> <span class="title">going</span> <span class="title">unused</span>.</span></span><br></pre></td></tr></table></figure></li><li><p>Description</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We propose to change the internal representation of the String <span class="class"><span class="keyword">class</span> <span class="title">from</span> <span class="title">a</span> <span class="title">UTF</span>-16 <span class="title">char</span> <span class="title">array</span> <span class="title">to</span> <span class="title">a</span> <span class="title">byte</span> <span class="title">array</span> <span class="title">plus</span> <span class="title">an</span> <span class="title">encoding</span>-<span class="title">flag</span> <span class="title">field</span>. <span class="title">The</span> <span class="title">new</span> <span class="title">String</span> <span class="title">class</span> <span class="title">will</span> <span class="title">store</span> <span class="title">characters</span> <span class="title">encoded</span> <span class="title">either</span> <span class="title">as</span> <span class="title">ISO</span>-8859-1/<span class="title">Latin</span>-1 (<span class="title">one</span> <span class="title">byte</span> <span class="title">per</span> <span class="title">character</span>), <span class="title">or</span> <span class="title">as</span> <span class="title">UTF</span>-16 (<span class="title">two</span> <span class="title">bytes</span> <span class="title">per</span> <span class="title">character</span>), <span class="title">based</span> <span class="title">upon</span> <span class="title">the</span> <span class="title">contents</span> <span class="title">of</span> <span class="title">the</span> <span class="title">string</span>. <span class="title">The</span> <span class="title">encoding</span> <span class="title">flag</span> <span class="title">will</span> <span class="title">indicate</span> <span class="title">which</span> <span class="title">encoding</span> <span class="title">is</span> <span class="title">used</span>.</span></span><br></pre></td></tr></table></figure></li><li><p>结论</p><p>结论：String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约了一些空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>StringBuffer和StringBuilder变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM‘<span class="function">s <span class="title">intrinsic</span><span class="params">(固有的、内置的)</span> string operations.</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="八集合工厂方法快速创建只读集合">(八)、集合工厂方法：快速创建只读集合</h3><p>要创建一个只读、不可改变的集合，必须构造和分配它，然后添加元素，最后包装成一个不可修改的集合。Java 8中的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; namesList = <span class="keyword">new</span> ArrayList &lt;&gt;(); namesList.add(<span class="string">&quot;Joe&quot;</span>);</span><br><span class="line">namesList.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">namesList.add(<span class="string">&quot;Bill&quot;</span>);</span><br><span class="line"><span class="comment">// 返回的namesList是只读集合，不可添加、删除、修改等写入操作</span></span><br><span class="line">namesList = Collections.unmodifiableList(namesList); System.out.println(namesList);</span><br></pre></td></tr></table></figure><ul><li>Arrays.asList()返回的List也是只读集合</li></ul><p>Java 9中创建只读集合</p><figure><img src="/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/104%20Day%20-%2002.png" alt="List"><figcaption aria-hidden="true">List</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List firsnamesList = List.of(“Joe”,”Bob”,”Bill”);</span><br></pre></td></tr></table></figure><p>调用集合中静态方法of()，可以将不同数量的参数传输到此工厂方法中。此<strong>功能可用于Set和List，也可用于Map的类似形式</strong>。此时得到的集合，是不可变的：在创建后，继续添加元素到这些集合会导致“UnsupportedOperationException” 。 由于Java 8中接口方法的实现，可以直接在List，Set和Map的接口内定义这些方法，便于调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map1 = Map.of(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="number">21</span>, <span class="string">&quot;Lilei&quot;</span>, <span class="number">33</span>, <span class="string">&quot;HanMeimei&quot;</span>, <span class="number">18</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map2 = Map.ofEntries(Map.entry(<span class="string">&quot;Tom&quot;</span>, <span class="number">89</span>), </span><br><span class="line">Map.entry(<span class="string">&quot;Jim&quot;</span>, <span class="number">78</span>), Map.entry(<span class="string">&quot;Tim&quot;</span>, <span class="number">98</span>));</span><br></pre></td></tr></table></figure><ul><li>Map还具有一个和of类似的方法Map.ofEntries()</li></ul><h3 id="九inputstream-加强">(九)、InputStream 加强</h3><p>InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line"><span class="keyword">try</span> (InputStream is = cl.getResourceAsStream(<span class="string">&quot;hello.txt&quot;</span>); OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src\\hello1.txt&quot;</span>)) &#123;</span><br><span class="line">    is.transferTo(os); <span class="comment">// 把输入流中的所有数据直接自动地复制到输出流中 &#125; catch (IOException e) &#123;</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十增强的stream-api">(十)、增强的Stream API</h3><ul><li><strong>Java 的Steam API 是java标准库最好的改进之一，让开发者能够快速运算，从而能够有效的利用数据并行计算</strong>。Java 8 提供的Steam 能够利用多核架构实现声明式的数据处理。</li><li>在Java 9 中，Stream API 变得更好，Stream 接口中添加了4 个新的方法：<strong>takeWhile, dropWhile, ofNullable，还有个iterate 方法的新重载方法</strong>，可以让你提供一个Predicate (判断条件)来指定什么时候结束迭代。</li><li>除了对Stream 本身的扩展，Optional 和Stream 之间的结合也得到了改进。现在可以<strong>通过Optional 的新方法stream() 将一个Optional 对象转换为一个(可能是空的) Stream 对象</strong>。</li></ul><ol type="1"><li><p>takeWhile()的使用</p><p>用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的Stream 中，takeWhile 返回从开头开始的按照指定规则尽量多的元素。【从头开始，直到遇到一个不满足规则的元素就停止】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>); </span><br><span class="line">list.stream().takeWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">list.stream().takeWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p>dropWhile()的使用</p><p>dropWhile 的行为与takeWhile 相反，返回剩余的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>); list.stream().dropWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">list.stream().dropWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p>ofNullable()的使用</p><p>Java 8 中Stream 不能完全为null，否则会报空指针异常。of()参数中的多个元素，可以包含null值；但不能存储<strong>单个</strong>null（多个null是可以的）</p><p>而Java 9 中的ofNullable 方法允许我们创建一个<strong>单元素 Stream</strong>，可以包含一个非空元素，也可以创建一个空Stream。</p></li><li><p>iterate()重载的使用</p><p>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的控制终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 现在的终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i &lt; <span class="number">100</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li></ol><h3 id="十一optional获取stream的方法">(十一)、Optional获取Stream的方法</h3><p>Optional类中stream()的使用</p><p>Optional也可看做容器，因此也提供了stream()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list); Stream&lt;List&lt;String&gt;&gt; stream = optional.stream();</span><br><span class="line">stream.flatMap(x -&gt; x.stream()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="十二javascript引擎升级nashorn">(十二)、Javascript引擎升级：Nashorn</h3><ul><li>Nashorn 项目在 <strong>JDK 9 中得到改进，它为 Java 提供轻量级的 Javascript 运行时</strong>。 Nashorn 项目跟随 Netscape 的 Rhino 项目，目的是为了在 Java 中实现一个高性能但轻量级的 Javascript 运行时。Nashorn 项目使得 Java 应用能够嵌入Javascript。它在JDK 8 中为Java 提供一个Javascript 引擎。</li><li><strong>JDK 9 包含一个用来解析 Nashorn 的 ECMAScript 语法树的 API</strong>。这个 API 使得IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类，就能够分析ECMAScript 代码。</li></ul><h2 id="二java10的新特性">二、Java10的新特性</h2><ul><li><p>2018年3月21日，Oracle官方宣布Java10正式发布。</p></li><li><p>需要注意的是 Java 9 和 Java 10 都不是 LTS (Long-Term-Support) 版本。和过去的 Java 大版本升级不同，这两个只有半年左右的开发和维护期。<strong>而未来的 Java 11，也就是 18.9 LTS，才是 Java 8 之后第一个 LTS 版本</strong>。</p></li><li><p>JDK10一共定义了109个新特性，其中包含12个JEP（<strong>对于程序员来讲，真正的新特性其实就一个</strong>），还有一些新API和JVM规范以及JAVA语言规范上的改动。</p></li><li><p>JDK10的12个JEP（JDK Enhancement Proposal特性加强提议）参阅官方文档：http://openjdk.java.net/projects/jdk/10/</p></li><li><blockquote><p><strong>286: Local-Variable Type Inference 局部变量类型推断</strong> 296: Consolidate the JDK Forest into a Single Repository JDK库的合并 304: Garbage-Collector Interface 统一的垃圾回收接口 307: Parallel Full GC for G1 为G1提供并行的Full GC 310: Application Class-Data Sharing 应用程序类数据（AppCDS）共享 312: Thread-Local Handshakes ThreadLocal握手交互 313: Remove the Native-Header Generation Tool (javah) 移除JDK中附带的javah工具314: Additional Unicode Language-Tag Extensions 使用附加的Unicode语言标记扩展316: Heap Allocation on Alternative Memory Devices 能将堆内存占用分配给用户指定的备用内存设备 317: Experimental Java-Based JIT Compiler 使用基于Java的JIT编译器 319: Root Certificates 根证书 322: Time-Based Release Versioning 基于时间的发布版本</p></blockquote></li></ul><h3 id="一局部变量类型推断">(一)、局部变量类型推断</h3><p>声明变量时，根据所附的值，推断变量的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.局部变量的初始化</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//2.增强for循环中的索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v : list) &#123;</span><br><span class="line">System.out.println(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.传统for循环中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不适用的结构：</p><ul><li>局部变量不赋值，就不能实现类型推断；或初始值为null，不能实现类型推断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num; <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">null</span>; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><ul><li><p>Lambda表达式，等号左侧的函数式接口名不可被var代替，否则无法实现类型推断</p></li><li><p>方法引用中，等号左边的函数式接口名不能被var代替</p></li><li><p>数组的静态初始化中，不可使用var代替类型</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><ul><li>情况1：没有初始化的局部变量声明 情况2：方法的返回类型 情况3：方法的参数类型 情况4：构造器的参数类型 情况5：属性 情况6：catch块</li></ul><p><strong>工作原理</strong></p><p>在处理 var时，编译器先是查看表达式右边部分，并根据右边变量值的类型进行推断，作为左边变量的类型，然后将该类型写入字节码当中。</p><p><strong>注意</strong></p><ul><li>var不是一个关键字 你不需要担心变量名或方法名会与 var发生冲突，因为 var实际上并不是一个关键字，而是一个类型名，只有在编译器需要知道类型的地方才需要用到它。除此之外，它就是一个普通合法的标识符。也就是说，除了不能用它作为类名，其他的都可以，但极少人会用它作为类名。</li><li>这不是JavaScript 首先我要说明的是，var并不会改变Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。</li></ul><h3 id="二集合新增创建不可变集合的方法">(二)、集合新增创建不可变集合的方法</h3><p>自 Java 9 开始，Jdk 里面为<strong>集合（List / Set / Map）都添加了 of (jdk9新增)和copyOf (jdk10新增)方法，它们两个都用来创建不可变的集合</strong>，来看下它们的使用和区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例1：</span></span><br><span class="line"><span class="keyword">var</span> list1 = List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>); <span class="keyword">var</span> copy1 = List.copyOf(list1);</span><br><span class="line">System.out.println(list1 == copy1); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//示例2：</span></span><br><span class="line"><span class="keyword">var</span> list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">var</span> copy2 = List.copyOf(list2);</span><br><span class="line">System.out.println(list2 == copy2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1和2代码基本一致，为什么一个为true, 一个是false</span></span><br><span class="line"><span class="comment">// 如果copyOf(Xxx coll)的参数coll本身就是一个只读集合，则该方法返回值即为当前的coll；如果参数coll不是一个只读集合，则该方法返回一个新的集合，且新的集合是一个只读的集合</span></span><br></pre></td></tr></table></figure><blockquote><p>从 源 码 分 析 ， 可以 看出 copyOf 方 法 会 先 判 断 来 源 集 合 是 不 是AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创建一个新的集合。 示例2因为用的 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类，所以copyOf 方法又创建了一个新的实例，所以为false。 注意：使用of和copyOf创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报java.lang.UnsupportedOperationException 异常。 上面演示了List 的of 和copyOf 方法，Set 和Map 接口都有。</p></blockquote><h2 id="三java11的新特性">三、Java11的新特性</h2><p>北京时间 2018年9 月 26 日， Oracle 官方宣布 Java 11 正式发布。这是<strong>Java 大版本周期变化后的第一个长期支持版本</strong>，非常值得关注。从官网即可下载,最新发布的 Java11 将带来 ZGC、 Http Client 等重要特性，一共包含 17 个 JEP（JDK Enhancement Proposals，JDK 增强提案）。其实，总共更新不止17个，只是我们更关注如下的17个JEP更新。</p><h3 id="一jdk-11-是一个长期支持版本lts-long-term-support">(一)、JDK 11 是一个长期支持版本（LTS, Long-Term-Support）</h3><ul><li>对于企业来说，选择 11 将意味着长期的、可靠的、可预测的技术路线图。其中免费的OpenJDK11 确定将得到 OpenJDK 社区的长期支持， LTS 版本将是可以放心选择的版本。</li><li>从JVM GC 的角度，<strong>JDK11 引入了两种新的GC(Epsilon、ZGC)，其中包括也许是划时代意义的ZGC</strong>，虽然其目前还是实验特性，但是从能力上来看，这是JDK 的一个巨大突破，为特定生产环境的苛刻需求提供了一个可能的选择。例如，对部分企业核心存储等产品，如果能够保证不超过 10ms 的 GC 暂停，可靠性会上一个大的台阶，这是过去我们进行 GC 调优几乎做不到的，是能与不能的问题。</li></ul><h3 id="二官网公开的-17-个-jepjdk-enhancement-proposal-特性增强提议">(二)、官网公开的 17 个 JEP（JDK Enhancement Proposal 特性增强提议）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">181</span>: Nest-Based Access Control（基于嵌套的访问控制）</span><br><span class="line"><span class="number">309</span>: Dynamic Class-File Constants（动态的类文件常量）</span><br><span class="line"><span class="number">315</span>: Improve Aarch64 Intrinsics（改进Aarch64 Intrinsics）</span><br><span class="line"><span class="number">318</span>: Epsilon: A No-Op Garbage Collector（Epsilon 垃圾回收器，又被称为<span class="string">&quot;No-Op（无操作） &quot;</span>回收器）</span><br><span class="line"><span class="number">320</span>: Remove the Java EE and CORBA Modules（移除 Java EE 和 CORBA 模块，JavaFX 也已被移除）</span><br><span class="line"><span class="number">321</span>: <span class="function">HTTP <span class="title">Client</span> <span class="params">(Standard)</span></span></span><br><span class="line"><span class="function">323: Local-Variable Syntax <span class="keyword">for</span> Lambda Parameters（用于 Lambda 参数的局部变量语法） 324: Key Agreement with Curve25519 and Curve448（采用 Curve25519 和 Curve448 算法实现的密钥协议）</span></span><br><span class="line"><span class="function">327: Unicode 10</span></span><br><span class="line"><span class="function">328: Flight Recorder（飞行记录仪）</span></span><br><span class="line"><span class="function">329: ChaCha20 and Poly1305 Cryptographic Algorithms（实现 ChaCha20 和 Poly1305 加密算法）</span></span><br><span class="line"><span class="function">330: Launch Single-File Source-Code Programs（启动单个 Java 源代码文件的程序）</span></span><br><span class="line"><span class="function">331: Low-Overhead Heap Profiling（低开销的堆分配采样方法）</span></span><br><span class="line"><span class="function">332: Transport Layer <span class="title">Security</span> <span class="params">(TLS)</span> 1.3（对 TLS 1.3 的支持）</span></span><br><span class="line"><span class="function">333: ZGC: A Scalable Low-Latency Garbage <span class="title">Collector</span> <span class="params">(Experimental)</span>（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</span></span><br><span class="line"><span class="function">335: Deprecate the Nashorn JavaScript Engine（弃用 Nashorn JavaScript 引擎）</span></span><br><span class="line"><span class="function">336: Deprecate the Pack200 Tools and API（弃用 Pack200 工具及其API）</span></span><br></pre></td></tr></table></figure><h3 id="三新增了一系列字符串处理方法">(三)、新增了一系列字符串处理方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串是否为空白</span></span><br><span class="line"><span class="string">&quot; \t \n &quot;</span>.isBlank(); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//去除首尾空白</span></span><br><span class="line"><span class="string">&quot; \t \n Javastack \t \n &quot;</span>.strip(); <span class="comment">// &quot;Javastack&quot;</span></span><br><span class="line"><span class="comment">//去除尾部空格</span></span><br><span class="line"><span class="string">&quot; \t \n Javastack &quot;</span>.stripTrailing(); <span class="comment">// &quot; Javastack&quot;</span></span><br><span class="line"><span class="comment">//去除首部空格</span></span><br><span class="line"><span class="string">&quot; Javastack &quot;</span>.stripLeading(); <span class="comment">// &quot;Javastack &quot;</span></span><br><span class="line"><span class="comment">//复制字符串</span></span><br><span class="line"><span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>);<span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line"><span class="comment">//行数统计</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().count(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="四optional-加强">(四)、Optional 加强</h3><p>Optional 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个Stream, 或者当一个空Optional 时给它一个替代的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">//判断value是否为空, JDK11</span></span><br><span class="line">ifPresentOrElse​(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Runnable emptyAction); <span class="comment">//value非空，执行参数1功能；如果value为空，执行参数2功能, JDK9</span></span><br><span class="line">Optional&lt;T&gt; or​(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier); <span class="comment">//value非空，返回对应的Optional；value为空，返回形参封装的Optional, JDK9</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">()</span></span>; <span class="comment">//value非空，返回仅包含此value的Stream；否则，返回一个空的Stream, JDK9</span></span><br><span class="line"><span class="function">T <span class="title">orElseThrow</span><span class="params">()</span></span>; <span class="comment">//value非空，返回value；否则抛异常NoSuchElementException, JDK10</span></span><br></pre></td></tr></table></figure><h3 id="五局部变量类型推断升级">(五)、局部变量类型推断升级</h3><p>在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样的语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的形式: 注解修饰必须要有类型, jdk10时不可在var上加注解</span></span><br><span class="line"><span class="comment">//Consumer&lt;String&gt; con1 = (@Deprecated t) -&gt; System.out.println(t.toUpperCase());</span></span><br><span class="line"><span class="comment">//正确的形式:</span></span><br><span class="line"><span class="comment">//使用var的好处是在使用lambda表达式时给参数加上注解。 </span></span><br><span class="line">Consumer&lt;String&gt; con2 = (<span class="meta">@Deprecated</span> <span class="keyword">var</span> t) -&gt; System.out.println(t.toUpperCase());</span><br></pre></td></tr></table></figure><h3 id="六全新的http-客户端api">(六)、全新的HTTP 客户端API</h3><p>JDK 9中引入的Http Client API</p><ul><li>HTTP，用于传输网页的协议，早在1997年就被采用在目前的1.1版本中。直到2015年，HTTP2才成为标准</li><li>HTTP/1.1和HTTP/2的主要区别是如何在客户端和服务器之间构建和传输数据。 <strong>HTTP/1.1依赖于请求/响应周期。 HTTP/2允许服务器“push”数据：它可以发送比客户端请求更多的数据</strong>。这使得它可以优先处理并发送对于首先加载网页至关重要的数据。</li><li>这是 Java 9 开始引入的一个处理 HTTP 请求的的 HTTP Client API，该API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在java.net 包中找到这个API。</li><li><strong>它将 替 代 仅 适 用 于 blocking 模式的HttpURLConnection</strong> （HttpURLConnection是在HTTP 1.0的时代创建的，并使用了协议无关的方法），并<strong>提供对WebSocket 和 HTTP/2的支持</strong>。</li></ul><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">HttpRequest request = </span><br><span class="line">HttpRequest.newBuilder(URI.create(<span class="string">&quot;http://127.0.0.1:8080/test/&quot;</span>)).build(); BodyHandler&lt;String&gt; responseBodyHandler = BodyHandlers.ofString(); HttpResponse&lt;String&gt; response = client.send(request, responseBodyHandler); String body = response.body();</span><br><span class="line">System.out.println(body);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">HttpRequest request = </span><br><span class="line">HttpRequest.newBuilder(URI.create(<span class="string">&quot;http://127.0.0.1:8080/test/&quot;</span>)).build(); BodyHandler&lt;String&gt; responseBodyHandler = BodyHandlers.ofString(); CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; sendAsync = </span><br><span class="line">client.sendAsync(request, responseBodyHandler);</span><br><span class="line">sendAsync.thenApply(t -&gt; t.body()).thenAccept(System.out::println);</span><br><span class="line"><span class="comment">//HttpResponse&lt;String&gt; response = sendAsync.get();</span></span><br><span class="line"><span class="comment">//String body = response.body();</span></span><br><span class="line"><span class="comment">//System.out.println(body);</span></span><br></pre></td></tr></table></figure><h3 id="七更简化的编译运行程序">(七)、更简化的编译运行程序</h3><p>看下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译</span></span><br><span class="line">javac Javastack.java</span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line">java Javastack</span><br></pre></td></tr></table></figure><p>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在未来的Java 11 版本中，通过一个java 命令就直接搞定了，如以下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Javastack.java</span><br></pre></td></tr></table></figure><p><strong>一个命令编译运行源代码的注意点：</strong></p><ul><li><strong>执行源文件中的第一个类, 第一个类必须包含主方法</strong>。包含主方法的第一个类可以不是主类，</li><li>并且<strong>不可以使用其它源文件中的自定义类, 本文件中的自定义类是可以使用的</strong>。</li></ul><h3 id="八废弃nashorn引擎">(八)、废弃Nashorn引擎</h3><p>废除Nashorn javascript引擎，在后续版本准备移除掉，有需要的可以考虑使用GraalVM。</p><h3 id="九zgc">(九)、ZGC</h3><p>Java两大利器：JVM(即可跑Java，也可跑其他程序，可以说是最强的虚拟机)，GC</p><ul><li><strong>GC是java主要优势之一</strong>。 然而, 当GC停顿太长, 就会开始影响应用的响应时间。<strong>消除或者减少GC停顿时长, java将对更广泛的应用场景是一个更有吸引力的平台</strong>。此外, 现代系统中可用内存不断增长,用户和程序员希望JVM能够以高效的方式充分利用这些内存, 并且无需长时间的GC暂停时间。</li><li><strong>ZGC, A Scalable Low-Latency Garbage Collector(Experimental) ZGC, 这应该是JDK11最为瞩目的特性, 没有之一</strong>。 但是后面带了Experimental,说明这还不建议用到生产环境。</li><li>ZGC是一个并发, 基于region, 压缩型的垃圾收集器, 只有root扫描阶段会STW(stop the world), 因此GC停顿时间不会随着堆的增长和存活对象的增长而变长。</li><li>优势：<ul><li>GC暂停时间(STW)不会超过10ms</li><li>既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)</li><li>和G1相比, 应用吞吐能力不会下降超过15%</li><li>为未来的GC功能和利用colord指针以及Load barriers优化奠定基础</li><li>初始只支持64位系统</li></ul></li><li>ZGC的<strong>设计目标</strong>是：<strong>支持TB级内存容量</strong>，<strong>暂停时间低</strong>（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。</li></ul><h3 id="十其他新特性">(十)、其他新特性</h3><ul><li>Unicode 10</li><li>Deprecate the Pack200 Tools and API</li><li>新的Epsilon垃圾收集器</li><li>完全支持Linux容器（包括Docker）</li><li>支持G1上的并行完全垃圾收集</li><li>最新的HTTPS安全协议TLS 1.3</li><li>Java Flight Recorder</li></ul><h2 id="四当前jdk中看不到什么">四、当前JDK中看不到什么</h2><h3 id="一一个标准化和轻量级的json-api">(一)、一个标准化和轻量级的JSON API</h3><p>一个标准化和轻量级的JSON API被许多Java开发人员所青睐。但是由于资金问题无法在Java当前版本中见到，但并不会削减掉。Java平台首席架构师Mark Reinhold在JDK 9邮件列中说：“这个JEP将是平台上的一个有用的补充，但是在计划中，它并不像Oracle资助的其他功能那么重要，可能会重新考虑JDK 10或更高版本中实现。”</p><p>需要加载第三方JSON API</p><h3 id="二新的货币api">(二)、新的货币API</h3><ul><li>对许多应用而言货币价值都是一个关键的特性，但JDK对此却几乎没有任何支持。严格来讲，现有的java.util.Currency类只是代表了当前ISO 4217货币的一个数据结构，但并没有关联的值或者自定义货币。JDK对货币的运算及转换也没有内建的支持，更别说有一个能够代表货币值的标准类型了。</li><li>此前，Oracle 公布的JSR 354定义了一套新的Java货币API：JavaMoney，计划会在Java 9中正式引入。但是目前没有出现在JDK 新特性中。</li><li>不过，如果你用的是Maven的话，可以做如下的添加，即可使用相关的API处理货币：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.javamoney&lt;/groupId&gt; 		</span><br><span class="line">    &lt;artifactId&gt;moneta&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.9</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="五展望">五、展望</h2><ul><li>随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展方向。<strong>传统的大型企业或互联网应用，正在被云端、容器化应用、模块化的微服务甚至是函数(FaaS，Function-as-a-Service)所替代</strong>。<ul><li>Java在大数据方面运用较为成功，SPARK主要开发语言Scalar，Scalar可跑在JVM上，且大数据操作框架和Java后台框架融合度较高</li><li>但在云计算方面不如Go语言(语法和性能方面)，Go语言可直接讲代码翻译为二进制</li></ul></li><li>Java虽然标榜面向对象编程，却毫不顾忌的加入面向接口编程思想，又扯出匿名对象之概念，每增加一个新的东西，对Java的根本所在的面向对象思想的一次冲击。反观Python，抓住面向对象的本质，又能在函数编程思想方面游刃有余。<strong>Java对标C/C++，以抛掉内存管理为卖点，却又陷入了JVM优化的噩梦</strong>。选择比努力更重要，选择Java的人更需要对它有更清晰的认识。</li><li><strong>Java 需要在新的计算场景下，改进开发效率</strong>。这话说的有点笼统，我谈一些自己的体会，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等，但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向。</li></ul></div><div class="popular-posts-header">相关文章推荐</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2022/02/15/Coding/Java/16Java8的其他新特性/" rel="bookmark">第16章 Java8的其他新特性</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2022/02/11/Coding/Java/15Java反射机制/" rel="bookmark">第15章 Java反射机制</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2022/01/25/Coding/Java/14网络编程/" rel="bookmark">第14章 网络编程</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2022/01/18/Coding/Java/13IO流/" rel="bookmark">第13章 IO流</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/2022/01/13/Coding/Java/12泛型/" rel="bookmark">第12章 泛型与File</a></div></li></ul><footer class="post-footer"><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作</div><button>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="Hunt 微信"> <span>微信</span></div><div><img src="/images/alipay.png" alt="Hunt 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Hunt</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://pku-hunterwu.github.io/2022/02/20/Coding/Java/17Java9&Java10&Java11%E6%96%B0%E7%89%B9%E6%80%A7/" title="第17章 Java9&amp;Java10&amp;Java11新特性">https://pku-hunterwu.github.io/2022/02/20/Coding/Java/17Java9&Java10&Java11新特性/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a></div><div class="post-widgets"><div class="wpac-rating-container"><div id="wpac-rating"></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/02/15/Coding/Java/16Java8%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7/" rel="prev" title="第16章 Java8的其他新特性"><i class="fa fa-chevron-left"></i> 第16章 Java8的其他新特性</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81NDc1Ny8zMTIyOA=="></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Hunt</span> &nbsp &nbsp <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("11/21/2021 8:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">271k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">4:06</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="https://embed.widgetpack.com/widget.js" async></script><script class="next-config" data-name="rating" type="application/json">{"enable":"ftrue","id":32964,"color":"#fc6423"}</script><script src="/js/third-party/rating.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"HGG0QbARovy9h4uJosLzs6RE-gzGzoHsz","app_key":"UncCQE6nDIEgxN0iPiz1UVSQ","server_url":"https://hgg0qbar.lc-cn-n1-shared.com","security":false}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script><script src="/js/third-party/math/mathjax.js"></script><div class="livere-card card" data-aos="fade-up"><style>#taboola-livere{display:none}</style><div id="lv-container" class="card-content" data-id="city" data-uid="<%- theme.livere.uid %>"><script type="text/javascript">(function (d, s) { let j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') { return; } j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); })(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript。</noscript></div></div><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item" onclick="back2bottom()"><i class="fa fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item" onclick="back2top()"><i class="fa fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script><script async src="/js/cursor/fireworks.js"></script></body></html>