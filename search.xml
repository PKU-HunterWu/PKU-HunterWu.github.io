<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第15章 Java反射机制</title>
    <url>/2022/02/11/Coding/Java/15Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="第15章java反射机制">第15章、Java反射机制</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、java 反射机制概述</li>
<li>二、理解 Class 类并获取 Class 实例 (掌握)</li>
<li>三、类的加载与 ClassLoader 的理解 (了解)</li>
<li>四、创建运行时类的对象 (掌握)</li>
<li>五、获取运行时类的完整结构 (了解)</li>
<li>六、调用运行时类的指定结构 (掌握)</li>
<li>七、反射的应用：动态代理 (此处了解，框架部分会细讲)</li>
<li>每日一考</li>
<li>总结</li>
</ol>
<span id="more"></span>
<h2 id="一java反射机制概述">一、java反射机制概述</h2>
<h3 id="一概述">(一)、概述</h3>
<ul>
<li><p>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
<ul>
<li><p>运行时取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p></li>
<li><p>动态语言：编译过程不能确定要实现什么类的对象，需要运行时确定</p>
<ul>
<li><p>动态语言</p>
<p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是<strong>在运行时代码可以根据某些条件改变自身结构</strong>。</p>
<p>主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。</p></li>
<li><p>静态语言 与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、 C++。</p></li>
<li><p>Java不是动态语言，但Java可以称之为“<strong>准动态语言</strong>”。即Java有一定的动态性，我们可以<strong>利用反射机制、字节码操作获得类似动态语言的特性。 Java的动态性让编程的时候更加灵活！</strong></p></li>
</ul></li>
</ul></li>
<li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。<strong>这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</strong>。</p></li>
</ul>
<h3 id="二java反射机制研究及应用">(二)、Java反射机制研究及应用</h3>
<p>Java反射机制提供的功能</p>
<ul>
<li>Java反射机制提供的功能</li>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<h3 id="三反射相关的主要api">(三)、反射相关的主要API</h3>
<ul>
<li>java.lang.Class:代表一个类</li>
<li>java.lang.reflect.Method:代表类的方法</li>
<li>java.lang.reflect.Field:代表类的成员变量</li>
<li>java.lang.reflect.Constructor:代表类的构造器</li>
<li>… …</li>
</ul>
<h2 id="二理解class类并获取class实例掌握">二、理解Class类并获取Class实例(掌握)</h2>
<h3 id="一class类的理解">(一)、Class类的理解</h3>
<p>类的加载过程</p>
<ul>
<li>程序经过javac.exe命令后，会生成一个或多个字节码文件(.class结尾)。</li>
<li>接着我们使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为<strong>类的加载</strong>。</li>
<li>加载到内存中的类称为运行时类，此<strong>运行时类就作为Class的一个实例</strong></li>
<li><strong>Class的实例</strong>就对应着一个<strong>运行时类</strong>。</li>
<li>加载到内存中的运行时类，会缓存一定的时间。在此时间内，我们可以通过不同的方式来获取此运行时类</li>
</ul>
<h3 id="二获取class实例">(二)、获取Class实例</h3>
<ol type="1">
<li><p>方式一：调用运行时类的属性—— .class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二：通过运行类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class pClass = p.getClass();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>方式三：调用Class的静态方法：forName(String classPath)</strong>【使用较多】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class forName = Class.forName(<span class="string">&quot;com.atguigu.reflection.Person&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>方式四：使用类的加载器：ClassLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">Class loadClass = classLoader.loadClass(<span class="string">&quot;com.atguigu.reflection.Person&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>获取</strong>运行时类，而不是<strong>创建</strong>运行时类</p></li>
</ol>
<h3 id="三具有class对象的类型">(三)、具有Class对象的类型</h3>
<ul>
<li>class： 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[]：数组
<ul>
<li>只要数组元素类型与维度一样，就是同一个Class实例</li>
</ul></li>
<li>enum：枚举</li>
<li>annotation：注解@interface</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<h3 id="四class类的常用方法">(四)、Class类的常用方法</h3>
<figure>
<img src="/2022/02/11/Coding/Java/15Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/93%20Day%20-%2002.png" alt="Class Load"><figcaption aria-hidden="true">Class Load</figcaption>
</figure>
<h2 id="三类的加载与classloader的理解了解">三、类的加载与ClassLoader的理解(了解)</h2>
<h3 id="一类的加载">(一)、类的加载</h3>
<p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</p>
<figure>
<img src="/2022/02/11/Coding/Java/15Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/90%20Day%20-%2002.png" alt="Class Load"><figcaption aria-hidden="true">Class Load</figcaption>
</figure>
<ul>
<li>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。
<ul>
<li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
</ul></li>
<li>初始化：
<ul>
<li>执行类构造器&lt;clinit&gt;()方法的过程。类构造器&lt;clinit&gt;()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。</li>
</ul></li>
</ul>
<h3 id="二类加载器">(二)、类加载器</h3>
<ul>
<li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</li>
<li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</li>
</ul>
<figure>
<img src="/2022/02/11/Coding/Java/15Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/91%20Day%20-%2002.png" alt="Class Load"><figcaption aria-hidden="true">Class Load</figcaption>
</figure>
<h3 id="三classloader">(三)、ClassLoader</h3>
<ol type="1">
<li>类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器。</li>
</ol>
<figure>
<img src="/2022/02/11/Coding/Java/15Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/92%20Day%20-%2002.png" alt="Class Load"><figcaption aria-hidden="true">Class Load</figcaption>
</figure>
<ol start="2" type="1">
<li><p>获取类加载器</p>
<ul>
<li>对于自定义类，使用系统类加载器进行加载</li>
<li>调用系统类加载器的getParent()，获取扩展类加载器</li>
<li>调用扩展类加载器的getParent()，无法获得引导类加载器</li>
<li>引导类加载器，主要负责Java的核心类库的加载，无法加载自定义类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取一个系统类加载器</span></span><br><span class="line">ClassLoader classloader = ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//2.获取系统类加载器的父类加载器，即扩展类加载器</span></span><br><span class="line">classloader = classloader.getParent();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//3.获取扩展类加载器的父类加载器，即引导类加载器</span></span><br><span class="line">classloader = classloader.getParent();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//4.测试当前类由哪个类加载器进行加载</span></span><br><span class="line">classloader = Class.forName(<span class="string">&quot;exer2.ClassloaderDemo&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//5.测试JDK提供的Object类由哪个类加载器加载</span></span><br><span class="line">classloader =</span><br><span class="line">Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//*6.关于类加载器的一个主要方法：getResourceAsStream(String str):获取类路径下的指定文件的输入流</span></span><br><span class="line">InputStream in = <span class="keyword">null</span>;</span><br><span class="line">in = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;exer2\\test.properties&quot;</span>);</span><br><span class="line">System.out.println(in);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>getResourceAsStream(String str)</strong>:获取类路径下的指定文件的输入流。【需掌握】</p>
<ul>
<li>使用此方法获取的文件输入流的文件默认路径为当前module的src下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProperties</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 读取配置文件的方式一：</span></span><br><span class="line">    <span class="comment">// 此种方式的文件默认在当前的Module下</span></span><br><span class="line">    <span class="comment">//        FileInputStream fileInputStream = new FileInputStream(&quot;ClassLoaderTest.properties&quot;);</span></span><br><span class="line">    <span class="comment">//        properties.load(fileInputStream);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">    <span class="comment">// 配置文件默认识别为：当前Module的src下</span></span><br><span class="line">    ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">    InputStream resourceAsStream = classLoader.getResourceAsStream(<span class="string">&quot;ClassLoaderTest-1.properties&quot;</span>);</span><br><span class="line">    properties.load(resourceAsStream);</span><br><span class="line"></span><br><span class="line">    String username = properties.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        fileInputStream.close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h2 id="四创建运行时类的对象掌握">四、创建运行时类的对象(掌握)</h2>
<ol type="1">
<li><p>调用运行时类的newInstance()方法：创建对应的运行时类对象。内部实际上调用了运行时类的空参构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;com.atguigu.reflection.Person&quot;</span>);</span><br><span class="line">Object p = clazz.newInstance();</span><br><span class="line">System.out.println(p);</span><br></pre></td></tr></table></figure>
<ul>
<li>要想此方法正常的创建运行时类的对象，要求：
<ul>
<li>运行时类必须提供空参的构造器（通常95%场景会通过反射调用空参构造器，且javabean中要求提供一个public的空参构造器）</li>
<li>空参构造器的访问权限要够：通常设置为public</li>
</ul></li>
<li>javabean中要求提供一个public的空参构造器。原因：
<ul>
<li>便于通过反射，创建运行时类的对象</li>
<li>便于子类继承此运行时类时，子类构造器默认调用super()时，需保证父类有此构造器，否则需要显式调用父类的带参构造器</li>
</ul></li>
</ul></li>
<li><p>没有无参的构造器的类也可创建对象</p>
<ul>
<li>通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器</li>
<li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li>
<li>通过Constructor实例化对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.根据全类名获取对应的Class对象</span></span><br><span class="line">String name = “atguigu.java.Person<span class="string">&quot;;</span></span><br><span class="line"><span class="string">Class clazz = null;</span></span><br><span class="line"><span class="string">clazz = Class.forName(name);</span></span><br><span class="line"><span class="string">//2.调用指定参数结构的构造器，生成Constructor的实例</span></span><br><span class="line"><span class="string">Constructor con = clazz.getConstructor(String.class,Integer.class); //3.通过Constructor的实例创建对应类的对象，并初始化类属性Person p2 = (Person) con.newInstance(&quot;</span>Peter<span class="string">&quot;,20);</span></span><br><span class="line"><span class="string">System.out.println(p2);</span></span><br></pre></td></tr></table></figure></li>
<li><p>java反射的动态性体现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDynamizationOfReflection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">        String classPath = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (num) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classPath = <span class="string">&quot;com.atguigu.reflection.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object instance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            instance = getInstance(classPath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(classPath);</span><br><span class="line">    Object o = clazz.newInstance();</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="五获取运行时类的完整结构了解">五、获取运行时类的完整结构(了解)</h2>
<p>Field、Method、Constructor、Superclass、Interface、Annotation</p>
<ul>
<li><p>实现的全部接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getInterfaces()</span><br></pre></td></tr></table></figure>
<p>确定此对象所表示的类或接口实现的接口。</p></li>
<li><p>所继承的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;? Super T&gt; getSuperclass()</span><br><span class="line">getGenericSuperClass() <span class="comment">//获取带泛型的父类</span></span><br></pre></td></tr></table></figure>
<p>返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的Class。</p></li>
<li><p>全部的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getConstructors()</span><br><span class="line">获取当前运行时类中声明为<span class="keyword">public</span>的构造方法。（不包括父类构造器）</span><br><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getDeclaredConstructors()获取当前运行时类中声明的所有构造方法。</span><br></pre></td></tr></table></figure>
<p>Constructor类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">取得修饰符: <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span>;</span><br><span class="line">取得方法名称: <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">取得参数的类型：<span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes();</span><br></pre></td></tr></table></figure></li>
<li><p>全部的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods()</span><br><span class="line">获取当前运行时类中声明的全部方法(不包含父类中声明的方法)</span><br><span class="line"><span class="keyword">public</span> Method[] getMethods()</span><br><span class="line">获取当前运行时类及其所有父类中声明为<span class="keyword">public</span>权限的方法</span><br></pre></td></tr></table></figure>
<p>Method类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getReturnType()取得全部的返回值类型</span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes()取得全部的参数</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span>取得修饰符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class&lt;?&gt;[] <span class="title">getExceptionTypes</span><span class="params">()</span>取得异常信息</span></span><br></pre></td></tr></table></figure></li>
<li><p>全部的Field</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Field[] getFields()</span><br><span class="line">获取当前运行时类及其所有父类中声明为<span class="keyword">public</span>权限的Field。</span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields()</span><br><span class="line">获取当前运行时类中声明的全部Field(不包含父类中声明的属性)。</span><br></pre></td></tr></table></figure>
<p>Field类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span>  以整数形式返回此Field的修饰符<span class="params">(权限修饰符)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class&lt;?&gt; <span class="title">getType</span><span class="params">()</span>  得到Field的属性类型（数据类型）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span>  返回Field的名称。</span></span><br></pre></td></tr></table></figure></li>
<li><p>Annotation相关</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getAnnotation(Class&lt;T&gt; annotationClass)</span><br><span class="line">getAnnotations()</span><br><span class="line">getDeclaredAnnotations()</span><br></pre></td></tr></table></figure></li>
<li><p>泛型相关</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取带泛型类型的父类：<span class="function">Type <span class="title">getGenericSuperclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">泛型类型：ParameterizedType</span></span><br><span class="line"><span class="function">获取实际的泛型类型参数数组：<span class="title">getActualTypeArguments</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>类所在的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Package <span class="title">getPackage</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="六调用运行时类的指定结构掌握">六、调用运行时类的指定结构(掌握)</h2>
<p>重点：属性、<strong>方法</strong>、构造器</p>
<p>调用对象的属性、方法、构造器，因此需要先获得运行时类，通过运行时类获得对象</p>
<h3 id="一调用指定的属性">(一)、调用指定的属性</h3>
<ol type="1">
<li><p>获取指定的属性</p>
<ul>
<li><p>getField(String name)</p>
<p>要求运行时类中属性声明为public【通常不采用】</p></li>
<li><p>getDeclaredField(String name)</p>
<p>【开发中常用】</p>
<p>配合 setAccessible(true);使用， 禁用访问安全检查的开关，可以访问private等权限属性</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String name)</span> 返回此Class对象表示的类或接口的指定的<span class="keyword">public</span>的Field。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getDeclaredField</span><span class="params">(String name)</span>返回此Class对象表示的类或接口的指定的Field。</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置当前属性的值</p>
<ul>
<li>set(): 参数1-指明设置那个对象的属性；参数2-将此属性值设置为多少</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object obj)</span> 取得指定对象obj上此Field的属性内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj,Object value)</span> 设置指定对象obj上此Field的属性内容</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="二调用指定的方法">(二)、调用指定的方法</h3>
<ol type="1">
<li><p>获取指定的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> getDeclaredMethod(): 参数<span class="number">1</span>-指明获取的方法名；参数<span class="number">2</span>-指明获取的方法的形参列表</span><br><span class="line"><span class="number">2.</span> 通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</span><br></pre></td></tr></table></figure></li>
<li><p>保证当前方法是可访问的：setAccessible(true);</p></li>
<li><p>之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。 参数1-方法的调用者；参数2-给方法形参赋值的实参 invoke()的返回值即为对应类中调用方法的返回值 1). Object 对应原方法的返回值，若原方法无返回值，此时返回null 2). 若原方法若为静态方法，此时形参Object obj可为null 3). 若原方法形参列表为空，则Object[] args为null 4). 若原方法声明为private,则需要在调用此invoke()方法前，显式调用</p></li>
<li><p>若需调用静态方法</p>
<p>以上步骤相同，只有invoke()方法的参数一指定为运行时类或null</p></li>
</ol>
<h3 id="三调用指定的构造器">(三)、调用指定的构造器</h3>
<ol type="1">
<li><p>获取指定的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getDeclaredConstructor(): 参数需要指明构造器参数列表</span><br></pre></td></tr></table></figure></li>
<li><p>保证此构造器是可访问的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setAccessible(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>调用此构造器创建运行时类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获得的构造器调用newInstance(参数列表)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="七反射的应用动态代理此处了解框架部分会细讲">七、反射的应用：动态代理(此处了解，框架部分会细讲)</h2>
<h3 id="一代理设计模式的原理">(一)、代理设计模式的原理</h3>
<p>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p>
<p>之前为大家讲解过代理机制的操作，属于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能。</p>
<p>静态代理举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClothFactory clothFactory; <span class="comment">// 用被代理类对象进行实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyClothFactory</span><span class="params">(ClothFactory clothFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clothFactory = clothFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些准备工作&quot;</span>);</span><br><span class="line">        clothFactory.produceCloth();</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些后续收尾工作&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nike生产一批运动服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建被代理类对象</span></span><br><span class="line">        NikeClothFactory nike = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">        <span class="comment">// 2. 创建代理类对象</span></span><br><span class="line">        ProxyClothFactory proxyClothFactory = <span class="keyword">new</span> ProxyClothFactory(nike);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特点：代理类和被代理类在编译期间就被确定下来</li>
</ul>
<h3 id="二动态代理">(二)、动态代理</h3>
<ul>
<li>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</li>
<li>动态代理使用场合:
<ul>
<li>调试</li>
<li>远程方法调用</li>
</ul></li>
<li>动态代理相比于静态代理的优点：
<ul>
<li>抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。</li>
</ul></li>
</ul>
<h3 id="三动态代理步骤">(三)、动态代理步骤</h3>
<p>根据内存中的被代理类实现的接口，动态生成代理类</p>
<ol type="1">
<li><p><strong>实现动态代理需要解决的问题</strong>：</p>
<ul>
<li>如何根据加载到内存中的被代理类，动态创建一个代理类及其对象
<ul>
<li>getProxyInstance()</li>
</ul></li>
<li>当通过代理类的对象调用方法时，如何动态的调用被代理类中的同名方法
<ul>
<li>使用invocationHandler</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getBelief</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成代理类对象的代理类，通过调用静态方法获取代理类对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过调用此方法返回一个代理类对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">// obj: 被代理类对象</span></span><br><span class="line"></span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line">        handler.bind(obj); <span class="comment">// 传入handler被代理类对象，以实现动态调用</span></span><br><span class="line"></span><br><span class="line">        Object proxyInstance = Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);</span><br><span class="line">        <span class="keyword">return</span> proxyInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当我们通过代理类的对象，调用方法a时，就会自动调用如下方法：invoke()</span></span><br><span class="line">    <span class="comment">// 将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// method: 即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">// obj:被代理类对象</span></span><br><span class="line">        Object returnValue = method.invoke(obj, args);</span><br><span class="line">        <span class="comment">// 上述方法的返回值就作为当前类的invoke()返回值</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line">        <span class="comment">// proxyInstance: 代理类对象</span></span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">// 当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        System.out.println(proxyInstance.getBelief());</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;火锅&quot;</span>);</span><br><span class="line"></span><br><span class="line">        NikeClothFactory nikeClothFactory = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">        ClothFactory nikeProxy = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line">        nikeProxy.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="四动态代理与aopaspect-orient-programming">(四)、动态代理与AOP(Aspect Orient Programming)</h3>
<p>前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下面介绍一种更实用的动态代理机制</p>
<figure>
<img src="/2022/02/11/Coding/Java/15Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/95%20Day%20-%2002.png" alt="AOP"><figcaption aria-hidden="true">AOP</figcaption>
</figure>
<figure>
<img src="/2022/02/11/Coding/Java/15Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/96%20Day%20-%2002.png" alt="AOP"><figcaption aria-hidden="true">AOP</figcaption>
</figure>
<p>改进后的说明：代码段1、代码段2、代码段3和深色代码段分离开了，但代码段1、2、3又和一个特定的方法A耦合了！<strong>最理想的效果是：代码块1、2、3既可以执行方法A，又无须在程序中以硬编码的方式直接调用深色代码的方法</strong></p>
<ul>
<li>使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理</li>
<li>这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异：AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理</li>
</ul>
<figure>
<img src="/2022/02/11/Coding/Java/15Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/94%20Day%20-%2002.png" alt="AOP"><figcaption aria-hidden="true">AOP</figcaption>
</figure>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li><p>写出获取Class实例的三种常见方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 调用运行时类的属性：类.class</span><br><span class="line"><span class="number">2.</span> 通过对象方法获取：对象.getClass()</span><br><span class="line"><span class="number">3.</span> Class类的静态方法：Class.forName()</span><br></pre></td></tr></table></figure></li>
<li><p>谈谈你对Class类的理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class类的实例对应着加载到内存中的一个运行时类。通过运行时类即可调用运行时类中的结构</span><br></pre></td></tr></table></figure></li>
<li><p>创建Class对应运行时类的对象的通用方法，代码实现。以及这样操作，需要对应的运行时类构造器方面满足的要求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建对应运行时类的对象：</span></span><br><span class="line">newInstance();</span><br><span class="line"><span class="comment">// 要求:</span></span><br><span class="line"><span class="comment">// 必须有空参构造器</span></span><br><span class="line"><span class="comment">// 空参构造器的权限要够，通常设置为public</span></span><br></pre></td></tr></table></figure></li>
<li><p>在工程或Module的src下有名为"jdbc.properties"的配置文件，文件内容为：name=Tom。如何在程序中通过代码获取Tom这个变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Properties类读取配置文件</span></span><br><span class="line">Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 方式一：使用FileInputStream获取输入文件流</span></span><br><span class="line"><span class="comment">// 方式二：使用ClassLoader获取输入流</span></span><br></pre></td></tr></table></figure></li>
<li><p>如何调用方法show()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类声明如下</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.java;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;我是一个中国人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方式一：直接new一个user对象，通过对象调用show()方法</li>
<li>方式二：通过反射调用方法</li>
</ul></li>
</ol>
<h2 id="总结">总结</h2>
<h3 id="创建类的对象的方式">创建类的对象的方式</h3>
<ol type="1">
<li>new + 构造器</li>
<li>要创建Xxx类的对象，可考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有静态方法存在。可以调用其静态方法创建Xxx对象</li>
<li>通过反射</li>
</ol>
<h3 id="如何看待反射和封装性两个技术">如何看待反射和封装性两个技术</h3>
<p>通过直接new的方式或反射的方式都可以调用公共结构，开发中到底用哪个</p>
<ul>
<li>建议：直接new的方式</li>
<li>什么时候会使用反射：编译时不确定要实例化哪个类的对象时。
<ul>
<li>例如，当前端访问...，因为后端代码是已经运行起来的，因此需要提供login类的对象；而当前端访问...，则需要提供register类的对象</li>
</ul></li>
</ul>
<p>反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术</p>
<p>反射可以操作private等权限的属性或方法与new出的对象不能操作private等权限的属性或方法矛盾吗？</p>
<ol type="1">
<li>不矛盾</li>
<li>原因：
<ul>
<li>封装性：封装性表示的是private等权限的属性、方法都已经提供了相应的public权限的方法来操作，且这些已经封装好的public方法能更好的控制边界、使代码更健壮等，因此这些private权限的属性、方法在类外用不到，就不再暴露到类外，且建议调用已经封装好的public权限的属性或方法</li>
<li>反射：反射只是可以（能力上能够）访问、操作private等权限的属性、方法，但同样不建议访问或操作private等权限的属性或方法</li>
<li>封装性给出的是建议调用的问题；而反射给出的是能不能调的问题</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第14章 网络编程</title>
    <url>/2022/01/25/Coding/Java/14%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="第14章网络编程">第14章、网络编程</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、网络编程概述</li>
<li>二、网络通信要素概述</li>
<li>三、通信要素 1：IP 和端口号</li>
<li>四、通信要素 2：网络协议</li>
<li>五、TCP 网络编程</li>
<li>六、UDP 网络编程</li>
<li>七、URL 编程</li>
<li>考题</li>
</ol>
<span id="more"></span>
<h2 id="一网络编程概述">一、网络编程概述</h2>
<p>Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。</p>
<p>Java提供的网络类库，可以实现无痛的(无需关注底层实现)网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java 实现了一个跨平台的网络库，<strong>程序员面对的是一个统一的网络编程环境。</strong></p>
<h3 id="网络基础">网络基础</h3>
<ol type="1">
<li><p>计算机网络</p>
<blockquote>
<p>把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。</p>
</blockquote></li>
<li><p>网络编程的目的</p>
<blockquote>
<p>直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</p>
</blockquote></li>
<li><p>网络编程中有两个主要的问题：</p>
<ul>
<li>如何准确地定位网络上一台或多台主机；</li>
<li>定位主机上的特定的应用</li>
<li>找到主机后如何可靠高效地进行数据传输</li>
</ul></li>
</ol>
<h2 id="二网络通信要素概述">二、网络通信要素概述</h2>
<h3 id="一如何实现网络中的主机互相通信">(一)、如何实现网络中的主机互相通信</h3>
<ul>
<li><p>通信双方地址()</p>
<ul>
<li>IP：定位网络中的主机</li>
<li>端口号：区分一台主机上的不同应用，定位主机上的特定应用</li>
</ul></li>
<li><p>一定的规则（即：网络通信协议。有两套参考模型）</p>
<ul>
<li>OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广</li>
<li>TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准。</li>
</ul>
<figure>
<img src="/2022/01/25/Coding/Java/14%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/86%20Day%20-%2002.png" alt="Network"><figcaption aria-hidden="true">Network</figcaption>
</figure></li>
</ul>
<h3 id="二网络编程中的两个要素">(二)、网络编程中的两个要素</h3>
<ol type="1">
<li>对应问题一：IP和端口号</li>
<li>对应问题二：提供网络协议：TCP/IP参考模型(应用层、传输层、网络层、物理+数据链路层)</li>
</ol>
<h2 id="三通信要素1ip和端口号">三、通信要素1：IP和端口号</h2>
<h3 id="一ip地址">(一)、IP地址</h3>
<blockquote>
<p>IP 地址：InetAddress</p>
<ul>
<li>唯一的标识 Internet 上的计算机（通信实体）</li>
<li>本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost</li>
<li>IP地址分类方式1：IPV4 和 IPV6
<ul>
<li>IPV4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如192.168.0.1</li>
<li>IPV6：128位（16个字节），写成8个无符号整数，每个整数用四个十六进制位表示，数之间用冒号（：）分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984</li>
</ul></li>
<li>IP地址分类方式2：<strong>公网地址(万维网使用)</strong>和<strong>私有地址(局域网使用)</strong>。192.168.开头的就是私有址址，范围即为192.168.0.0--192.168.255.255，专门为组织机构内部使用</li>
<li>特点：不易记忆</li>
</ul>
</blockquote>
<ol type="1">
<li><p>IP：唯一标识Internet上的计算机（通信实体）</p></li>
<li><p>在java中使用InetAddress类代表IP</p></li>
<li><p>IP分类：</p>
<ul>
<li>IPV4和IPV6</li>
<li>万维网和局域网</li>
</ul></li>
<li><p>域名：www.baidu.com, www.mi.com, ...</p></li>
<li><p>本地回路地址：127.0.0.1，对应着localhost</p>
<p>InetAddress.getLocalHost()</p></li>
<li><p>实例化InetAddress</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InetAddress将构造器进行了私有化，因此需调用类的方法实现实例化</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">InetAddress.getLocalHost();</span><br></pre></td></tr></table></figure></li>
<li><p>InetAddress常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHostAddress</span><span class="params">()</span><span class="comment">//返回 IP 地址字符串（以文本表现形式）。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHostName</span><span class="params">()</span><span class="comment">//获取此 IP 地址的主机名</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReachable</span><span class="params">(<span class="keyword">int</span> timeout)</span><span class="comment">//测试是否可以达到该地址</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="二端口号">(二)、端口号</h3>
<blockquote>
<ul>
<li>端口号：端口号标识正在计算机上运行的进程（程序）</li>
<li>不同的进程有不同的端口号</li>
<li>被规定为一个 16 位的整数 0~65535。</li>
<li>端口分类：
<ul>
<li>公认端口：0~1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23）</li>
<li>注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。</li>
<li>动态/私有端口：49152~65535。</li>
</ul></li>
<li><strong>端口号与IP地址的组合得出一个网络套接字：Socket。</strong></li>
</ul>
</blockquote>
<ul>
<li>端口号：端口号标识正在计算机上运行的进程（程序）
<ul>
<li>要求：不同的进程有不同的端口号</li>
<li>范围：被规定为一个16位的整数：0~65535</li>
</ul></li>
<li><strong>端口号与IP地址的组合得出一个网络套接字：Socket。</strong></li>
</ul>
<h2 id="四通信要素2网络协议">四、通信要素2：网络协议</h2>
<h3 id="一概述">(一)、概述</h3>
<ul>
<li><p>网络通信协议</p>
<p>计算机网络中实现通信必须有一些约定，即通信协议，<strong>对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准</strong>。</p></li>
<li><p>问题：网络协议太复杂</p>
<p>计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢？</p></li>
<li><p>通信协议分层的思想</p>
<p>在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即<strong>同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系</strong>。各层互不影响，利于系统的开发和扩展。</p></li>
</ul>
<h3 id="二tcpip协议簇">(二)、TCP/IP协议簇</h3>
<ul>
<li>传输层协议中有两个非常重要的协议：
<ul>
<li>传输控制协议TCP(Transmission Control Protocol)</li>
<li>用户数据报协议UDP(User Datagram Protocol)。</li>
</ul></li>
<li><strong>TCP/IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)</strong>而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议。【协议簇包含了传输层和网络层的协议】
<ul>
<li>IP(Internet Protocol)协议是网络层的主要协议，支持网间互连的数据通信。</li>
<li>TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层、IP层、传输层和应用层。</li>
</ul></li>
</ul>
<h3 id="三tcp和udp">(三)、TCP和UDP</h3>
<ul>
<li>TCP协议：类似于打电话
<ul>
<li>使用TCP协议前，须先建立TCP连接，形成传输数据通道</li>
<li>传输前，采用“<strong>三次握手</strong>”方式，点对点通信，<strong>是可靠的</strong>
<ul>
<li>理论上可以多次握手，但三次以上效率变低</li>
<li>三次可保证双方是在线的</li>
</ul></li>
<li>TCP协议进行通信的两个应用进程：客户端、服务端。</li>
<li>在连接中<strong>可进行大数据量的传输</strong></li>
<li>传输完毕，<strong>需释放已建立的连接，效率低</strong></li>
</ul></li>
</ul>
<figure>
<img src="/2022/01/25/Coding/Java/14%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/87%20Day%20-%2002.png" alt="Network"><figcaption aria-hidden="true">Network</figcaption>
</figure>
<figure>
<img src="/2022/01/25/Coding/Java/14%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/88%20Day%20-%2002.png" alt="Network"><figcaption aria-hidden="true">Network</figcaption>
</figure>
<ul>
<li>UDP协议：类似于发送短信
<ul>
<li>将数据、源、目的封装成数据包，<strong>不需要建立连接</strong></li>
<li>每个数据报的大小限制在<strong>64K</strong>内</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是<strong>不可靠的</strong></li>
<li>可以广播发送</li>
<li>发送数据结束时<strong>无需释放资源，开销小，速度快</strong></li>
</ul></li>
</ul>
<h3 id="四socket">(四)、Socket</h3>
<ul>
<li><p>利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。</p></li>
<li><p>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。</p></li>
<li><p>通信的两端都要有Socket，是两台机器间通信的端点。</p></li>
<li><p>网络通信其实就是Socket间的通信。</p></li>
<li><p>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</p></li>
<li><p>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。</p></li>
<li><p>Socket分类：</p>
<ul>
<li>流套接字（stream socket）：使用TCP提供可依赖的字节流服务</li>
<li>数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务</li>
</ul></li>
<li><p>Socket类常用构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(InetAddress address,<span class="keyword">int</span> port)</span>创建一个流套接字并将其连接到指定IP 地址的指定端口号。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host,<span class="keyword">int</span> port)</span>创建一个流套接字并将其连接到指定主机上的指定端口号。</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure></li>
<li><p>Socket类的常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span>返回此套接字的输入流。可以用于接收网络消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span>返回此套接字的输出流。可以用于发送网络消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InetAddress <span class="title">getInetAddress</span><span class="params">()</span>此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回<span class="keyword">null</span>。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InetAddress <span class="title">getLocalAddress</span><span class="params">()</span>获取套接字绑定的本地地址。即本端的IP地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span>此套接字连接到的远程端口号；如果尚未连接套接字，则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLocalPort</span><span class="params">()</span>返回此套接字绑定到的本地端口。 如果尚未绑定套接字，则返回 -1。即本端的端口号。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和OutputStream。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownInput</span><span class="params">()</span>如果在套接字上调用 <span class="title">shutdownInput</span><span class="params">()</span> 后从套接字输入流读取内容，则流将返回EOF（文件结束符）。即不能在从此套接字的输入流中接收任何数据。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownOutput</span><span class="params">()</span>禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 <span class="title">shutdownOutput</span><span class="params">()</span> 后写入套接字输出流，则该流将抛出IOException。即不能通过此套接字的输出流发送任何数据。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="五tcp网络编程">五、TCP网络编程</h2>
<h3 id="一基于socket的tcp编程">(一)、基于Socket的TCP编程</h3>
<figure>
<img src="/2022/01/25/Coding/Java/14%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/89%20Day%20-%2002.png" alt="Network"><figcaption aria-hidden="true">Network</figcaption>
</figure>
<ul>
<li><p>客户端Socket的工作过程包含以下四个基本的步骤：</p>
<ul>
<li><strong>创建Socket</strong>：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li>
<li><strong>打开连接到Socket 的输入/出流</strong>：使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输</li>
<li><strong>按照一定的协议对Socket 进行读/写操作</strong>：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程。</li>
<li><strong>关闭Socket</strong>：断开客户端到服务器的连接，释放线路</li>
</ul></li>
<li><p><strong>客户端创建Socket对象</strong></p>
<ul>
<li>客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器方发起连接。Socket的构造器是：
<ul>
<li>Socket(String host,int port) throws UnknownHostException, IOException：向服务器(域名是host。端口号为port)发起TCP连接，若成功，则创建Socket对象，否则抛出异常。</li>
<li>Socket(InetAddress address,int port)throws IOException：根据InetAddress对象所表示的IP地址以及端口号port发起连接。</li>
</ul></li>
<li>客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket s = <span class="keyword">new</span> Socket(“<span class="number">192.168</span><span class="number">.40</span><span class="number">.165</span>”,<span class="number">9999</span>); </span><br><span class="line">OutputStream out = s.getOutputStream(); </span><br><span class="line">out.write(<span class="string">&quot; hello&quot;</span>.getBytes());</span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>服务器端TCP编程</strong></p>
<ul>
<li>调用 <strong>ServerSocket(int port)</strong> ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li>
<li>调用 <strong>accept()</strong>：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</li>
<li>调用 该<strong>Socket类对象的 getOutputStream() 和 getInputStream ()</strong>：获取输出流和输入流，开始网络数据的发送和接收。</li>
<li><strong>关闭ServerSocket和Socket对象</strong>：客户端访问结束，关闭通信套接字。</li>
</ul>
<blockquote>
<ul>
<li>ServerSocket 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口中的业务员。也就是说，<strong>服务器必须事先建立一个等待客户请求建立套接字连接的ServerSocket对象</strong>。</li>
<li>所谓“接收”客户的套接字请求，就是accept()方法会返回一个 Socket 对象</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">Socket s = ss.accept ();</span><br><span class="line">InputStream in = s.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可使用循环接收数据，但这种方式可能会在控制台输出中文时乱码</span></span><br><span class="line"><span class="comment">// 可使用ByteArrayOutputStream储存数据，再一并输出至控制台</span></span><br><span class="line"><span class="keyword">int</span> num = in.read(buf);</span><br><span class="line">String str = <span class="keyword">new</span> String(buf,<span class="number">0</span>,num);</span><br><span class="line">System.out.println(s.getInetAddress().toString()+”:”+str);</span><br><span class="line"></span><br><span class="line">s.close();</span><br><span class="line">ss.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二tcp网络编程例题">(二)、TCP网络编程例题</h3>
<ol type="1">
<li><p>客户端发送内容给服务端，服务端将内容打印到控制台上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClientTCP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InetAddress server = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        socket = <span class="keyword">new</span> Socket(server, <span class="number">8889</span>);</span><br><span class="line"></span><br><span class="line">        outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;客户端&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(outputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ServerTCP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8889</span>);</span><br><span class="line">        socket = serverSocket.accept();</span><br><span class="line">        inputStream = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不建议这样写，当传输的是中文字符时，显示在控制台上会有可能乱码</span></span><br><span class="line">        <span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line">        <span class="comment">//        int len;</span></span><br><span class="line">        <span class="comment">//        while ((len = inputStream.read(buffer)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//            System.out.println(new String(buffer, 0, len));</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ByteArrayOutputStream</span></span><br><span class="line">        byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            byteArrayOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            <span class="comment">// 只管写即可，实际写到了ByteArrayOutputStream内的数组中</span></span><br><span class="line">            <span class="comment">// 最后整体转化为字符串，避免乱码问题</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(byteArrayOutputStream.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (byteArrayOutputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                byteArrayOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>客户端发送文件给服务端，服务端将文件保存在本地</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端发送文件给服务端，服务端将文件保存在本地</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clientTCP2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Socket server = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建Socket</span></span><br><span class="line">        server = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">8889</span>);</span><br><span class="line">        <span class="comment">// 2. 通过socket对象获得InputStream或OutputStream</span></span><br><span class="line">        outputStream = server.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.写出数据</span></span><br><span class="line">        <span class="comment">// 3.1. 通过节点流读取文件数据</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;GenshinImpact.png&quot;</span>);</span><br><span class="line">        byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">// 使用ByteArrayOutputStream的目的是实现一次写入</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            byteArrayOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.2. 通过socket的outputStream写出数据</span></span><br><span class="line">        outputStream.write(byteArrayOutputStream.toByteArray());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 关闭资源</span></span><br><span class="line">        <span class="keyword">if</span> (byteArrayOutputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                byteArrayOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fileInputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serverTCP2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建ServerSocket</span></span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8889</span>);</span><br><span class="line">        <span class="comment">// 2. accept()接受连接，获得本次连接的socket套接字</span></span><br><span class="line">        socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">// 3. 使用socket的InputStream和OutputStream进行读取或写入</span></span><br><span class="line">        inputStream = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4. 读取或写入操作</span></span><br><span class="line">        <span class="comment">// 4.1. 通过节点流写入文件</span></span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;GenshinImpact-Network.png&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 4.2. 通过socket的InputStream读取网络通信数据</span></span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fileOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 5. 关闭资源</span></span><br><span class="line">        <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。（涉及到阻塞IO）</p>
<ul>
<li>socket.shutdownOutput();// 明确表示停止输出，server端的read函数将会在读完后退出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clientTCP3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Socket server = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建Socket</span></span><br><span class="line">        server = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">8889</span>);</span><br><span class="line">        <span class="comment">// 2. 通过socket对象获得InputStream或OutputStream</span></span><br><span class="line">        outputStream = server.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.写出数据</span></span><br><span class="line">        <span class="comment">// 3.1. 通过节点流读取文件数据</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;GenshinImpact.png&quot;</span>);</span><br><span class="line">        byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">// 使用ByteArrayOutputStream的目的是实现一次写入</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            byteArrayOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.2. 通过socket的outputStream写出数据</span></span><br><span class="line">        outputStream.write(byteArrayOutputStream.toByteArray());</span><br><span class="line">        server.shutdownOutput();<span class="comment">// 明确表示停止输出，server端的read函数将会在读完后退出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.接收数据</span></span><br><span class="line">        InputStream inputStream = server.getInputStream();</span><br><span class="line">        byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();<span class="comment">// 使用ByteArrayOutputStream的目的是实现一次写入</span></span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            byteArrayOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(byteArrayOutputStream.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 关闭资源</span></span><br><span class="line">        <span class="keyword">if</span> (byteArrayOutputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                byteArrayOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fileInputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serverTCP3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建ServerSocket</span></span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8889</span>);</span><br><span class="line">        <span class="comment">// 2. accept()接受连接，获得本次连接的socket套接字</span></span><br><span class="line">        socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">// 3. 使用socket的InputStream和OutputStream进行读取或写入</span></span><br><span class="line">        inputStream = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4. 读取或写入操作</span></span><br><span class="line">        <span class="comment">// 4.1. 通过节点流写入文件</span></span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;GenshinImpact-Network-2.png&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 4.2. 通过socket的InputStream读取网络通信数据</span></span><br><span class="line">        <span class="comment">// socket的InputStream的read()方法在没有读取到明确的client端中止发送消息时将会阻塞在此处</span></span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fileOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server端完成文件接收&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.服务器端给予客户端反馈</span></span><br><span class="line">        <span class="comment">// 5.1. 通过socket对象获取OutputStream进行写入</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;发送成功&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 6. 关闭资源</span></span><br><span class="line">        <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三客户端-服务端">(三)、客户端-服务端</h3>
<ul>
<li>客户端：
<ul>
<li>自定义</li>
<li>浏览器</li>
</ul></li>
<li>服务端：
<ul>
<li>自定义</li>
<li>Tomcat服务器</li>
<li>java Web阶段将是在Tomcat基础上对前后端的设计</li>
</ul></li>
</ul>
<h2 id="六udp网络编程">六、UDP网络编程</h2>
<h3 id="一udp网络通信">(一)、UDP网络通信</h3>
<ul>
<li>类 <strong>DatagramSocket</strong> 和 <strong>DatagramPacket</strong> 实现了基于 UDP 协议网络程序。</li>
<li>UDP数据报<strong>通过数据报套接字 DatagramSocket 发送和接收</strong>，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</li>
<li><strong>DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</strong></li>
<li>UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。</li>
</ul>
<h3 id="二datagramsocket类的常用方法">(二)、DatagramSocket类的常用方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatagramSocket</span><span class="params">(<span class="keyword">int</span> port)</span>创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatagramSocket</span><span class="params">(<span class="keyword">int</span> port,InetAddress laddr)</span>创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>关闭此数据报套接字。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramPacket p)</span>从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的IP 地址和远程主机的端口号。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(DatagramPacket p)</span>从此套接字接收数据报包。当此方法返回时，DatagramPacket的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InetAddress <span class="title">getLocalAddress</span><span class="params">()</span>获取套接字绑定的本地地址。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLocalPort</span><span class="params">()</span>返回此套接字绑定的本地主机上的端口号。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InetAddress <span class="title">getInetAddress</span><span class="params">()</span>返回此套接字连接的地址。如果套接字未连接，则返回<span class="keyword">null</span>。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span>返回此套接字的端口。如果套接字未连接，则返回-1。</span></span><br></pre></td></tr></table></figure>
<h3 id="三datagrampacket类常用方法">(三)、DatagramPacket类常用方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatagramPacket</span><span class="params">(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> length)</span>构造 DatagramPacket，用来接收长度为length 的数据包。length 参数必须小于等于buf.length。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatagramPacket</span><span class="params">(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> length,InetAddress address,<span class="keyword">int</span> port)</span>构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length参数必须小于等于buf.length。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InetAddress <span class="title">getAddress</span><span class="params">()</span>返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span>返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">getData</span><span class="params">()</span>返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量offset 处开始，持续length 长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span>返回将要发送或接收到的数据的长度。</span></span><br></pre></td></tr></table></figure>
<h3 id="四例子">(四)、例子</h3>
<p>发送端传送图片，接收端接受图片且发送反馈，发送端接收 接收端返回的反馈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">    FileInputStream picFileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建socket对象</span></span><br><span class="line">        datagramSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 装载数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        picFileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;GenshinImpact.png&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((len = picFileInputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>, len, InetAddress.getLocalHost(), <span class="number">9090</span>);</span><br><span class="line">            <span class="comment">// 3. 发送数据</span></span><br><span class="line">            datagramSocket.send(datagramPacket);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 接收反馈数据</span></span><br><span class="line">        datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">9091</span>);</span><br><span class="line">        DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>], <span class="number">1024</span>);</span><br><span class="line">        datagramSocket.receive(datagramPacket);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(datagramPacket.getData(), <span class="number">0</span>, datagramPacket.getLength()));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(datagramSocket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4. 释放资源</span></span><br><span class="line">            datagramSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(picFileInputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                picFileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建socket对象</span></span><br><span class="line">        datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 装载数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 接收数据</span></span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            datagramSocket.receive(datagramPacket);</span><br><span class="line">            byteArrayOutputStream.write(datagramPacket.getData(), <span class="number">0</span>, datagramPacket.getLength());</span><br><span class="line">        &#125;<span class="keyword">while</span> (datagramPacket.getLength() &gt;= buffer.length);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有数据接收完毕&quot;</span>);</span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;GenshinImpact-UDP.png&quot;</span>);</span><br><span class="line">        fileOutputStream.write(byteArrayOutputStream.toByteArray(), <span class="number">0</span>, byteArrayOutputStream.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 给予发送端反馈</span></span><br><span class="line">        buffer = <span class="string">&quot;UDP服务端已收到&quot;</span>.getBytes();</span><br><span class="line">        datagramPacket = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>, buffer.length, InetAddress.getLocalHost(), <span class="number">9091</span>);</span><br><span class="line">        datagramSocket.send(datagramPacket);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(datagramSocket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4. 释放资源</span></span><br><span class="line">            datagramSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fileOutputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五udp网络通信流程">(五)、UDP网络通信流程</h3>
<ul>
<li>流 程：
<ul>
<li>DatagramSocket与DatagramPacket</li>
<li>建立发送端，接收端</li>
<li>建立数据包</li>
<li>调用Socket的发送、接收方法</li>
<li>关闭Socket</li>
</ul></li>
<li>发送端与接收端是两个独立的运行程序</li>
</ul>
<h2 id="七url编程">七、URL编程</h2>
<h3 id="一url类">(一)、URL类</h3>
<ul>
<li><p><strong>URL(Uniform Resource Locator)：统一资源定位符</strong>，它表示 Internet 上某一资源的地址。</p></li>
<li><p>它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p></li>
<li><p>通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。</p></li>
<li><p>URL的基本结构由5部分组成：<code>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表</code></p>
<ul>
<li>例如: <code>http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123</code></li>
<li>#片段名：即锚点，例如看小说，直接定位到章节</li>
<li>参数列表格式：参数名=参数值&amp;参数名=参数值....</li>
</ul></li>
<li><p>URL：统一资源定位符，对应着互联网的某一资源地址</p></li>
<li><p>格式：</p>
<ul>
<li><code>http           ://localhost:8080       /example/pic.png?username=Tom</code></li>
<li><code>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表</code></li>
</ul></li>
<li><p>为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span> <span class="params">(String spec)</span>：通过一个表示URL地址的字符串可以构造一个URL对象。例如：URL url </span>= <span class="keyword">new</span> URL (<span class="string">&quot;http://www. atguigu.com/&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(URL context, String spec)</span>：通过基 URL 和相对 URL 构造一个 URL 对象。例如：URL downloadUrl </span>= <span class="keyword">new</span> URL(url, “download.html<span class="string">&quot;)</span></span><br><span class="line"><span class="string">public URL(String protocol, String host, String file); 例如：new URL(&quot;</span>http<span class="string">&quot;,&quot;</span>www.atguigu.com<span class="string">&quot;, “download. html&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String protocol, String host, <span class="keyword">int</span> port, String file)</span></span>; 例如: URL gamelan = <span class="keyword">new</span> URL(<span class="string">&quot;http&quot;</span>, <span class="string">&quot;www.atguigu.com&quot;</span>, <span class="number">80</span>, “download.html<span class="string">&quot;);</span></span><br></pre></td></tr></table></figure>
<p>URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获。</p></li>
<li><p>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProtocol</span><span class="params">()</span>  获取该URL的协议名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">()</span>获取该URL的主机名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPort</span><span class="params">()</span>获取该URL的端口号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span>获取该URL的文件路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFile</span><span class="params">()</span>获取该URL的文件名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getQuery</span><span class="params">()</span>获取该URL的查询名</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二针对http协议的urlconnection类">(二)、针对HTTP协议的URLConnection类</h3>
<ul>
<li><p>URL的方法 openStream()：能从网络上读取数据</p></li>
<li><p>若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用URLConnection 。</p></li>
<li><p>URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时，首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection对象。如果连接过程失败，将产生IOException.</p>
<ul>
<li>URL netchinaren = new URL ("http://www.atguigu.com/index.shtml");</li>
<li>URLConnectonn u = netchinaren.openConnection( );</li>
</ul></li>
<li><p>通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getContent</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getContentLength</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDate</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">( )</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OutputSteram <span class="title">getOutputStream</span><span class="params">( )</span><span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="三uriurl和urn的区别">(三)、URI、URL和URN的区别</h3>
<p><strong>URI，是uniform resource identifier，统一资源标识符</strong>，用来唯一的标识一个资源。而<strong>URL是uniform resource locator，统一资源定位符，它是一种具体的URI</strong>，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。<strong>而URN，uniform resource name，统一资源命名，是通过名字来标识资源</strong>，比如mailto:java-net@java.sun.com。也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。</p>
<h3 id="四小结">(四)、小结</h3>
<ul>
<li>位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。</li>
<li>客户端－服务器是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。端口号是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。套接字用于连接客户端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实现面向连接的会话。</li>
<li>Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP地址，该对象里有两个字段：主机名(String) 和 IP 地址(int)。</li>
<li>类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络拥挤等问题，它保证数据可靠的传送。</li>
<li>类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。</li>
</ul>
<h2 id="考题">考题</h2>
<ol type="1">
<li><p>一个IP对应着哪个类的一个对象？</p>
<p>实例化这个类的两种方式？</p>
<p>两个常用方法是？</p>
<blockquote>
<ul>
<li>一个IP对应着InetAddress类的对象</li>
<li>实例化
<ul>
<li>InetAddress.getByName(String host)</li>
<li>InetAddress.getLocalHost();</li>
</ul></li>
<li>常用方法
<ul>
<li>getHostName();</li>
<li>getHostAddress();</li>
</ul></li>
</ul>
</blockquote></li>
<li><p>传输层的TCP协议和UDP协议的主要区别是？</p>
<blockquote>
<p>TCP: 可靠的数据传输（三次握手），可进行大数据量的传输，效率低</p>
<p>UDP：不可靠的数据传输，以数据报(或包)形式发送，一个数据报限定为64kB，效率高</p>
</blockquote></li>
<li><p>什么是URL，你能写一个URL吗</p>
<blockquote>
<p>URL：统一资源定位符</p>
<p>URL url = new URL("http://localhost:8080/examples/hello.txt?username=Tom&amp;password=123456");</p>
</blockquote></li>
<li><p>谈谈你对对象序列化机制的理解</p>
<blockquote>
<p>序列化过程</p>
<p>反序列化过程</p>
</blockquote></li>
<li><p>对象要想实现序列化，需要满足那几个条件</p>
<blockquote>
<ol type="1">
<li>实现接口：Serializable</li>
<li>对象所在类提供常量-序列版本号：private static final long serialVersionUID</li>
<li>要求对象的属性也必须是可序列化的（基本数据类型、String本身及已经是可序列化的）</li>
</ol>
</blockquote></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第12章 泛型与File</title>
    <url>/2022/01/13/Coding/Java/12%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="第12章泛型与file">第12章、泛型与File</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、为什么要有泛型</li>
<li>二、在集合中使用泛型 (需掌握)</li>
<li>三、自定义范型结构</li>
<li>四、泛型在继承上的体现</li>
<li>五、通配符的使用</li>
<li>六、泛型应用举例</li>
</ol>
<span id="more"></span>
<h2 id="一为什么要有泛型">一、为什么要有泛型</h2>
<p>JDK5前，例如ArrayList中可装入任何类型的对象，后出现泛型，使用泛型的ArrayList只能装入该泛型类型的对象。</p>
<blockquote>
<p>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection<E>，List<E>，ArrayList<E> 这个<E>就是类型参数，即泛型。</E></E></E></E></p>
</blockquote>
<ol type="1">
<li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。</li>
<li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。</li>
</ol>
<h3 id="一泛型的概念">(一)、泛型的概念</h3>
<blockquote>
<ul>
<li>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。</li>
<li>从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List<String>，这表明该List只能保存字符串类型的对象。</String></li>
<li>JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。</li>
</ul>
</blockquote>
<p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。</p>
<h2 id="二在集合中使用泛型需掌握">二、在集合中使用泛型(需掌握)</h2>
<ol type="1">
<li><p>集合或接口类在JDK5时都修改为带泛型的结构</p></li>
<li><p>在实例化集合类时，可指明具体的泛型结构</p></li>
<li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（如 方法、构造器、属性等）使用到类的泛型的位置都会替换为实例化时指定的泛型类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如在ArrayList定义中国的add(E e)在实例化并指定泛型类型（例如Integer）后，通过对象调用add方法时将是add(Integer e)</span><br></pre></td></tr></table></figure></li>
<li><p>注意点：<strong>泛型类型必须是一个类</strong>，不能是基本数据类型。需要用到基本数据类型处使用包装类</p></li>
<li><p>如果类实例化时未指明泛型类型，则泛型的默认类型为java.lang.Object类型</p></li>
<li><p>JDK7新特性：类型推断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规写法：</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> Map&lt;String, Integer&gt;();</span><br><span class="line"><span class="comment">// JDK7新特性：类型推断</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> Map&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="三自定义范型结构">三、自定义范型结构</h2>
<p>泛型类、泛型接口、泛型方法</p>
<h3 id="一泛型的声明">(一)、泛型的声明</h3>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; 和 <span class="title">class</span> <span class="title">GenTest</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br></pre></td></tr></table></figure>
<p>其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。常用T表示，是Type的缩写。</p>
</blockquote>
<h3 id="二泛型类">(二)、泛型类</h3>
<p>子类在继承带泛型的父类时，指明泛型类型为一个具体的类，则实例化子类对象时，不再需要指明泛型类型，此时子类只是一个普通的类，不是泛型类；相反的，若子类在继承带泛型的父类时，未指明父类的泛型类型，只是以一个E或T或其他符号代表，则子类也需要添加<T e>符号，此时的子类是一个泛型类</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String gName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gId;</span><br><span class="line">    <span class="keyword">private</span> T gType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericTest</span><span class="params">(String gName, <span class="keyword">int</span> gId, T gType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gName = gName;</span><br><span class="line">        <span class="keyword">this</span>.gId = gId;</span><br><span class="line">        <span class="keyword">this</span>.gType = gType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getgName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setgName</span><span class="params">(String gName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gName = gName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getgId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setgId</span><span class="params">(<span class="keyword">int</span> gId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gId = gId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getgType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setgType</span><span class="params">(T gType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gType = gType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GenericTest&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;gName=&#x27;&quot;</span> + gName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gId=&quot;</span> + gId +</span><br><span class="line">                <span class="string">&quot;, gType=&quot;</span> + gType +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubGenericTest</span> <span class="keyword">extends</span> <span class="title">GenericTest</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubGenericTest1</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">GenericTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T subTypeT;</span><br><span class="line">    <span class="keyword">private</span> E subTypeE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol type="1">
<li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</p></li>
<li><p>泛型类的构造器如下：public GenericClass(){}。 而下面是错误的：public GenericClass<E>(){}</E></p></li>
<li><p>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</p></li>
<li><p><strong>泛型不同的引用不能相互赋值。</strong></p>
<p>尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</Integer></String></p></li>
<li><p>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用。</p></li>
<li><p>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</p></li>
<li><p>jdk1.7，泛型的简化操作(类型推断)：ArrayList<Fruit> flist = new ArrayList&lt;&gt;();</Fruit></p></li>
<li><p>泛型的指定中不能使用基本数据类型，可以使用包装类替换。</p></li>
<li><p>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在<strong>静态方法中不能使用类的泛型</strong>。</p></li>
<li><p><strong>异常类不能是泛型的，类声明中泛型也不能当作异常类</strong></p></li>
<li><p><strong>不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity]; 参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</strong></p></li>
<li><p>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</p>
<ul>
<li>子类不保留父类的泛型：按需实现
<ul>
<li>没有类型 擦除</li>
<li>具体类型</li>
</ul></li>
<li>子类保留父类的泛型：泛型子类
<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;<span class="comment">// 等价于class Son extends Father&lt;Object,Object&gt;&#123; &#125;</span></span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型: 实例化子类对象时 要同时指定父类中的泛型类型，因此子类声明中的泛型列表中需保留继承时父类未指定的泛型类型符号</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;<span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123; &#125;</span></span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型: 实例化子类对象时 要同时指定父类中的泛型类型，因此子类声明中的泛型列表中需保留继承时父类未指定的泛型类型符号</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h3 id="三泛型方法">(三)、泛型方法</h3>
<ul>
<li>泛型方法：在方法中出现了范型的结构，泛型类型与所在类的泛型参数无关系。</li>
<li>泛型方法在调用时指明泛型参数的类型</li>
<li>泛型方法可声明为静态，原因：泛型方法的泛型参数是(可)在调用方法时确定的，并非在实例化对象时确定；而使用所在类泛型参数的静态方法是在实例化对象前就要加载到内存中，而由于加载类时无法确定类型故不可在静态方法中使用类的泛型类型参数</li>
</ul>
<blockquote>
<ul>
<li><p>方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。</p></li>
<li><p><strong>泛型方法的格式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常</span><br></pre></td></tr></table></figure>
<p>参数列表可以是空的，即在参数列表中不必指明泛型类型等</p></li>
<li><p>泛型方法声明泛型时也可以指定上限(在12.5中讲)</p></li>
</ul>
</blockquote>
<h3 id="五泛型使用场景举例">(五)、泛型使用场景举例</h3>
<p>DAO：Data(base) Access Object，操作数据库时需要提供Java类即DAO，用来定义操作数据库的通用操作，如定义添加一条记录、删除一条记录、修改一条记录、查询一条记录、查询多条记录</p>
<p>数据库中的一张表对应Java中的一个类，，由于数据库中存在多个表，因此可在DAO类定义时使用泛型指定那张表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表的共性操作的DAO</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DAO</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一条记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一条记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改一条记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询一条记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询多条记录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作某一个表(Customer表)的DAO</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerDAO</span> <span class="keyword">extends</span> <span class="title">DAO</span>&lt;<span class="title">Customer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四泛型在继承上的体现">四、泛型在继承上的体现</h2>
<p>虽然类A是类B的父类，但是G&lt;A&gt;和G&lt;B&gt;不具有子父类关系，因此两个类的对象不能实现赋值操作。但B&lt;G&gt;实例化的对象能够赋值给A&lt;G&gt;引用</p>
<blockquote>
<p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G&lt;B&gt;并不是G&lt;A&gt;的子类型！ 比如：String是Object的子类，但是List&lt;String&gt;并不是List&lt;Object&gt;的子类，因此List&lt;String&gt;类型对象不能赋值给List&lt;Object&gt;引用。若能够实现赋值，则违反了泛型设置的初衷（指定List中只能添加一种类型对象，不能随意添加多种类型对象）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List&lt;Object&gt; 和 List&lt;String&gt;不具备子父类关系，编译报错</span></span><br><span class="line">    <span class="comment">// list1 = list2;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但和List的父接口Collection是具备子父类关系的</span></span><br><span class="line">    list1.add(<span class="number">123</span>);</span><br><span class="line">    list1.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list1.add(<span class="keyword">new</span> Date());</span><br><span class="line">    show(list1);</span><br><span class="line"></span><br><span class="line">    list2.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list2.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    list2.add(<span class="keyword">new</span> Date().toString());</span><br><span class="line">    show(list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Collection c)</span></span>&#123;</span><br><span class="line">    Iterator iterator = c.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五通配符的使用">五、通配符的使用</h2>
<h3 id="一通配符使用">(一)、通配符(?)使用</h3>
<p>由于G&lt;A&gt;和G&lt;B&gt;不具有子父类关系，因此在使用泛型时具有不便性（方法中使用不同泛型的同类对象作为参数时，需要根据不同的泛型写多个方法名不同的方法，无法充分复用代码），因此出现通配符(?)用以充分复用代码。</p>
<blockquote>
<p>泛型，作为JDK5时代引入的”语法糖“，在编译的时候是会被抹除的，换言之，<code>specialSort(List&lt;Dog&gt;)</code>和<code>specialSort(List&lt;Apple&gt;)</code>在编译时都会变成<code>specialSort(List)</code>，因此不符合重载的原则（变量名相同、参数类型或数量不同）。</p>
</blockquote>
<p>G&lt;A&gt;和G&lt;B&gt;不具有子父类关系，二者共同的父类是G&lt;?&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// List&lt;Object&gt; 和 List&lt;String&gt;不具备子父类关系，编译报错</span></span><br><span class="line">        <span class="comment">// list1 = list2;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 但和List的父接口Collection是具备子父类关系的</span></span><br><span class="line">        list1.add(<span class="number">123</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        list1.add(<span class="keyword">new</span> Date());</span><br><span class="line">        show(list1);</span><br><span class="line"></span><br><span class="line">        list2.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        list2.add(<span class="keyword">new</span> Date().toString());</span><br><span class="line">        show(list2);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 利用多态性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Collection c)</span></span>&#123;</span><br><span class="line">        Iterator iterator = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 利用通配符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="二使用通配符后的数据写入和读取要求">(二)、使用通配符后的数据写入和读取要求</h3>
<ol type="1">
<li>List添加元素：对于List&lt;?&gt;不能向其内部添加数据，而只可以添加null</li>
<li>List读取数据：对于List&lt;?&gt;允许读取数据，读取的数据返回类型为Object</li>
</ol>
<h3 id="三有限制条件的通配符使用">(三)、有限制条件的通配符使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">? extends A: G&lt;? extends A&gt;可作为G&lt;A&gt;和G&lt;C&gt;的父类，其中A是C的父类</span><br><span class="line">? <span class="keyword">super</span> A：  G&lt;? <span class="keyword">super</span> A&gt;可作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;? extends Person&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;? <span class="keyword">super</span> Person&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; list3 = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;Person&gt; list4 = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;Object&gt; list5 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list1 = list4;</span><br><span class="line">    <span class="comment">//      list1 = list5; // 报错</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      list2 = list3; // 报错</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    list2 = list5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六泛型应用举例">六、泛型应用举例</h2>
<h3 id="一泛型嵌套">(一)、泛型嵌套</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt;(); </span><br><span class="line">    ArrayList&lt;Citizen&gt; list = <span class="keyword">new</span> ArrayList&lt;Citizen&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> Citizen(<span class="string">&quot;刘恺威&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Citizen(<span class="string">&quot;杨幂&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Citizen(<span class="string">&quot;小糯米&quot;</span>));</span><br><span class="line">    map.put(<span class="string">&quot;刘恺威&quot;</span>, list);</span><br><span class="line">    Set&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    Iterator&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; iterator = entrySet.iterator(); </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, ArrayList&lt;Citizen&gt;&gt; entry = iterator.next(); </span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        ArrayList&lt;Citizen&gt; value = entry.getValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;户主：&quot;</span> + key);</span><br><span class="line">        System.out.println(<span class="string">&quot;家庭成员：&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二实验2-自定义泛型类的使用">(二)、实验2 自定义泛型类的使用</h3>
<blockquote>
<ul>
<li>定义个泛型类 DAO<T>，在其中定义一个 Map 成员变量，Map 的键为 String 类型，值为 T 类型。
<ul>
<li>分别创建以下方法：
<ul>
<li>public void save(String id,T entity)： 保存 T 类型的对象到 Map 成员变量中</li>
<li>public T get(String id)：从 map 中获取 id 对应的对象</li>
<li>public void update(String id,T entity)：替换 map 中key 为id 的内容,改为 entity 对象</li>
<li>public List<T> list()：返回 map 中存放的所有 T 对象</T></li>
<li>public void delete(String id)：删除指定 id 对象</li>
</ul></li>
</ul></T></li>
<li>定义一个 User 类： 该类包含：private 成员变量（int 类型） id，age；（String 类型）name。</li>
<li>定义一个测试类： 创建 DAO 类的对象， 分别调用其 save、get、update、list、delete 方法来操作 User 对象， 使用 Junit 单元测试类进行测试。</li>
</ul>
</blockquote>
<p><strong>DAO.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DAO</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, T&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;String, T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DAO</span><span class="params">(Map&lt;String, T&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一条记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String id, T entity)</span></span>&#123;</span><br><span class="line">        map.put(id, entity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除一条记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        map.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改一条记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, T entity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(id)) &#123;</span><br><span class="line">            map.put(id, entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询一条记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        T t = map.get(id);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询多条记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 错误写法：map.values()返回的就是一个Collection，并不一定是一个List，</span></span><br><span class="line">        <span class="comment">// 不能直接强制类型转换</span></span><br><span class="line"><span class="comment">//        List&lt;T&gt; values = (List&lt;T&gt;)map.values();</span></span><br><span class="line"><span class="comment">//        return values;</span></span><br><span class="line"><span class="comment">//        return (List&lt;T&gt;) (map.values());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确写法：</span></span><br><span class="line">        ArrayList&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T value : map.values()) &#123;</span><br><span class="line">            list.add(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DAO&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;map=&quot;</span> + map +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UserDAO.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id, age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDAO</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserDAO&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        UserDAO userDAO = (UserDAO) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != userDAO.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (age != userDAO.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(userDAO.name) : userDAO.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DAOTest.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DAOTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DAO&lt;UserDAO&gt; userDAO = <span class="keyword">new</span> DAO&lt;&gt;();</span><br><span class="line">        userDAO.save(<span class="string">&quot;1001&quot;</span>, <span class="keyword">new</span> UserDAO(<span class="number">1</span>, <span class="number">20</span>, <span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        userDAO.save(<span class="string">&quot;1002&quot;</span>, <span class="keyword">new</span> UserDAO(<span class="number">2</span>, <span class="number">18</span>, <span class="string">&quot;Jerry&quot;</span>));</span><br><span class="line">        userDAO.save(<span class="string">&quot;1003&quot;</span>, <span class="keyword">new</span> UserDAO(<span class="number">3</span>, <span class="number">25</span>, <span class="string">&quot;Jack&quot;</span>));</span><br><span class="line">        System.out.println(userDAO);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Id = 1002, Value = &quot;</span> + userDAO.get(<span class="string">&quot;1002&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Id = 1004, Value = &quot;</span> + userDAO.get(<span class="string">&quot;1004&quot;</span>));</span><br><span class="line"></span><br><span class="line">        userDAO.update(<span class="string">&quot;1002&quot;</span>, <span class="keyword">new</span> UserDAO(<span class="number">5</span>, <span class="number">28</span>, <span class="string">&quot;Lily&quot;</span>));</span><br><span class="line">        System.out.println(userDAO);</span><br><span class="line"></span><br><span class="line">        List&lt;UserDAO&gt; list = userDAO.list();</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        userDAO.delete(<span class="string">&quot;1002&quot;</span>);</span><br><span class="line">        userDAO.delete(<span class="string">&quot;1004&quot;</span>);</span><br><span class="line">        System.out.println(userDAO);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第13章 IO流</title>
    <url>/2022/01/09/Coding/Java/13IO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="第13章io流">第13章、IO流</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、File 类的使用</li>
<li>二、IO 流原理及流的分类</li>
<li>三、节点流 (或文件流)</li>
<li>四、缓冲流 (处理流的一种)</li>
<li>五、转换流（处理流的一种）</li>
<li>六、标准输入、输出流 (了解)</li>
<li>七、打印流 (了解)</li>
<li>八、数据流 (了解)</li>
<li>九、对象流 (掌握)</li>
<li>十、随机存取文件流 (了解)</li>
<li>十一、NIO.2 中 Path、Paths、 Files 类的使用 (了解)</li>
<li>补充（第三方 API jar 包导入）</li>
<li>每日一考</li>
</ol>
<span id="more"></span>
<p>IO: Input、Output；输入：磁盘 --&gt; 内存；输出：内存 --&gt; 磁盘</p>
<h2 id="一file类的使用">一、File类的使用</h2>
<p>File类的对象可充当文件或文件夹，用以使用java中的对象表示磁盘存储的端点。</p>
<p>File类声明在java.io包下</p>
<blockquote>
<ul>
<li>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关 File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。</li>
<li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</li>
<li>File对象可以作为参数传递给流的构造器</li>
</ul>
</blockquote>
<h3 id="一常用构造器">(一)、常用构造器</h3>
<ol type="1">
<li><p>第一种 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。
<ul>
<li>绝对路径：是一个固定的路径,从盘符开始</li>
<li>相对路径：是相对于某个位置开始</li>
</ul></li>
<li>路径中的每级目录之间用一个路径分隔符隔开。</li>
<li>路径分隔符和系统有关：
<ul>
<li>windows和DOS系统默认使用“”来表示</li>
<li>UNIX和URL使用“/”来表示</li>
</ul></li>
<li>Java程序支持跨平台运行，因此路径分隔符要慎用。</li>
<li>为了解决这个隐患，File类提供了一个常量： public static final String separator。根据操作系统，动态的提供分隔符。</li>
</ul></li>
<li><p>第二种 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent,String child)</span></span></span><br></pre></td></tr></table></figure></p>
<p>以parent为父路径，child为子路径创建File对象。</p></li>
<li><p>第三种 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent,String child)</span></span></span><br></pre></td></tr></table></figure></p>
<p>根据一个父File对象和子文件路径创建File对象</p></li>
</ol>
<h3 id="二file类常用方法">(二)、File类常用方法</h3>
<ol type="1">
<li><p>File类的获取功能</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAbsolutePath</span><span class="params">()</span> <span class="comment">//获取绝对路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> <span class="comment">//获取路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> <span class="comment">//获取名称</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParent</span><span class="params">()</span><span class="comment">//获取上层文件目录路径。若无，返回null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> <span class="comment">//获取文件长度（即：字节数）。不能获取目录的长度。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="comment">//获取最后一次的修改时间，毫秒值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 如下方法适用于目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">list</span><span class="params">()</span> <span class="comment">//获取指定目录下的所有文件或者文件目录的名称数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File[] <span class="title">listFiles</span><span class="params">()</span> <span class="comment">//获取指定目录下的所有文件或者文件目录的File数组</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>File类的重命名功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span><span class="comment">//把文件重命名为指定的文件路径</span></span></span><br></pre></td></tr></table></figure>
<p>要想保证重命名成功，需要调用者存在于硬盘中、且dest不能存在于磁盘中</p></li>
<li><p>File类的判断功能</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span><span class="comment">//判断是否是文件目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> <span class="comment">//判断是否是文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> <span class="comment">//判断是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span><span class="comment">//判断是否可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span><span class="comment">//判断是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span> <span class="comment">//判断是否隐藏</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 可先判断文件是否存在 exists()，在进行后续操作</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>File类的创建功能</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="comment">//创建文件。若文件存在，则不创建，返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span> <span class="comment">//创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> <span class="comment">//创建文件目录。如果上层文件目录不存在，一并创建</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下。</p></li>
<li><p>File类的删除功能</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span><span class="comment">//删除文件或者文件夹</span></span></span><br></pre></td></tr></table></figure></p>
<p>删除注意事项：</p>
<ul>
<li>Java中的删除不走回收站。</li>
<li>要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录</li>
</ul></li>
<li><p>磁盘中是否存在真正的文件或目录对File类对象影响：</p></li>
</ol>
<figure>
<img src="/2022/01/09/Coding/Java/13IO%E6%B5%81/80%20Day%20-%2002.png" alt="File"><figcaption aria-hidden="true">File</figcaption>
</figure>
<ul>
<li>当硬盘中真有一个真实的文件或目录存在时，创建File对象时，各个属性会显式赋值。</li>
<li>当硬盘中没有真实的文件或目录对应时，那么创建对象时，除了指定的目录和路径之外，其他的属性都是取成员变量的默认值。</li>
</ul>
<h3 id="三总结">(三)、总结</h3>
<ul>
<li><p>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</p></li>
<li><p>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点”</p></li>
<li><p>IDEA中，如开发中在JUnit中的单元测试方法测试File类，则相对路径即为当前Module下。如在main()方法测试File类，则相对路径即为当前的Project下</p></li>
<li><p>Eclipse中，无论在单元测试方法还是在main()测试File类，相对路径都是当前的Project下</p></li>
</ul>
<h2 id="二io流原理及流的分类">二、IO流原理及流的分类</h2>
<h3 id="一java-io原理">(一)、Java IO原理</h3>
<blockquote>
<ul>
<li>I/O是Input/Output的缩写， I/O技术是非常实用的技术，<strong>用于处理设备之间的数据传输</strong>。如读/写文件，网络通讯等。</li>
<li>Java程序中，对于数据的输入/输出操作以“<strong>流(stream)</strong>” 的方式进行。</li>
<li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过<strong>标准的方法</strong>输入或输出数据。</li>
</ul>
</blockquote>
<ul>
<li><p>IO不止读写文件，还可在多个设备之间进行网络通信；</p></li>
<li><p>java提供的各种流类和流接口很多，但都是通过标准的方法实现输入输出，即读取数据一般是采用read()、写入数据一般采用write()，只是方法的参数不同。</p></li>
</ul>
<blockquote>
<ul>
<li>输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li>
<li>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li>
</ul>
</blockquote>
<ul>
<li>Java中的IO是站位在程序或内存角度的输入(数据流向内存)、输出(数据从内存输出)</li>
</ul>
<h3 id="二流的分类">(二)、流的分类</h3>
<ul>
<li>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)
<ul>
<li>字符流(char类型占用2个字节)更适合处理文本文件</li>
<li>字节流适合处理图片、视频等非文本数据</li>
</ul></li>
<li>按数据流的<strong>流向</strong>不同分为：输入流，输出流</li>
<li>按流的<strong>角色</strong>的不同分为：节点流，处理流
<ul>
<li>节点流：直接作用在文件上的流</li>
<li>处理流：在已有流的基础上再加一层流（将原来的流作为新添加流的构造器参数）。目的是提高传输速度</li>
</ul></li>
</ul>
<p>先判断流向：分为输入、输出流</p>
<p>再判断数据单位：分为字节流、字符流</p>
<p>最后判断角色：分为节点流、处理流</p>
<h3 id="三io流体系">(三)、IO流体系</h3>
<ul>
<li>IO流中的4个抽象基类</li>
</ul>
<figure>
<img src="/2022/01/09/Coding/Java/13IO%E6%B5%81/81%20Day%20-%2002.png" alt="IO"><figcaption aria-hidden="true">IO</figcaption>
</figure>
<ul>
<li><p>IO流分类（蓝框的流类需要重点掌握）</p>
<figure>
<img src="/2022/01/09/Coding/Java/13IO%E6%B5%81/82%20Day%20-%2002.png" alt="IO"><figcaption aria-hidden="true">IO</figcaption>
</figure>
<ul>
<li>访问文件的4个流类：节点流；其他流为处理流</li>
</ul></li>
<li><p>需掌握的IO流的体系结构</p>
<table>
<colgroup>
<col style="width: 3%">
<col style="width: 20%">
<col style="width: 26%">
<col style="width: 23%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th>抽象基类</th>
<th>InputStream</th>
<th>OutputStream</th>
<th>Reader</th>
<th>Writer</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>节点流</td>
<td>FileInputStream<br>( read(byte[] buffer) )</td>
<td>FileOutputStream<br>( write(byte[] buffer, offset, len) )</td>
<td>FileReader<br>( read(char[] cbuf) )</td>
<td>FileWriter<br>( write(char[] cbuf, offset, len) )</td>
</tr>
<tr class="even">
<td>缓冲流</td>
<td>BufferedInputStream<br>( read(byte[] buffer) )</td>
<td>BufferedOutputStream<br>( write(byte[] buffer, offset, len) / flush() )</td>
<td>BufferedReader<br>( read(char[] cbuf); readLine() )</td>
<td>BufferedWriter<br>( write(char[] cbuf, offset, len) / flush())</td>
</tr>
</tbody>
</table></li>
</ul>
<h3 id="四输入输出的标准化过程">(四)、输入输出的标准化过程</h3>
<ol type="1">
<li>输入过程
<ul>
<li>创建File类对象，指明读取的数据的来源（要求此文件一定要存在）</li>
<li>创建相应的输入流，将File类的对象作为参数，传入流的构造器中</li>
<li>具体的读入过程：
<ul>
<li>创建相应的byte[] 或 char[]</li>
<li>使用循环实现读入</li>
</ul></li>
<li>关闭流资源</li>
</ul></li>
<li>输出过程
<ul>
<li>创建File类对象，指明写出数据的位置（不要求此文件一定存在）</li>
<li>创建相应的输出流，将File类的对象作为参数，传入流的构造器中</li>
<li>具体的写出过程
<ul>
<li>write(byte[]/char[] buffer, offset, len)</li>
</ul></li>
<li>关闭流资源</li>
</ul></li>
</ol>
<h2 id="三节点流或文件流">三、节点流(或文件流)</h2>
<ul>
<li><h3 id="一filereader">(一)、FileReader</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将IO module下的hello.txt文件读入程序并输出至控制台</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileReaderWriter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 实例化File类的对象，指明操作的文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>); <span class="comment">//相对路径为当前module；main中的相对路径为当前project</span></span><br><span class="line">        <span class="comment">// 2.提供具体的流</span></span><br><span class="line">        fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 数据读入</span></span><br><span class="line">        <span class="comment">// read(): 返回读入的一个字符。如果到达文件末尾返回-1</span></span><br><span class="line">        <span class="keyword">int</span> read = fileReader.read();</span><br><span class="line">        <span class="keyword">while</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">            read = fileReader.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 流的关闭操作</span></span><br><span class="line">        <span class="comment">// JVM的垃圾回收 对于物理连接如数据库连接、输入输出流、Socket连接无能为力</span></span><br><span class="line">        <span class="comment">// 因此，流需要手动关闭。且要保证fileReader对象不能是null</span></span><br><span class="line">        <span class="keyword">if</span>(fileReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用read(char[] cbuf)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileReaderWriter2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 实例化File类</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 实例化流</span></span><br><span class="line">        fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="comment">// 3. 读取或写入操作</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileReader.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 返回每次读入cbuf数组中的字符个数，如果达到文件末尾则返回-1</span></span><br><span class="line">            String str = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fileReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol type="1">
<li><p>方法使用：</p>
<ul>
<li><p>方法一 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span>: 返回读入的一个字符。如果到达文件末尾返回-1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>方法二 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">read(<span class="keyword">char</span>[] cbuf): 返回每次读入cbuf数组中的字符个数，如果达到文件末尾则返回-<span class="number">1</span></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>操作过程：</p>
<ul>
<li>File类实例化</li>
<li>流的实例化</li>
<li>读入或写出操作</li>
<li>资源关闭</li>
</ul></li>
<li><p>注意</p>
<ul>
<li>对于流中的异常处理：最好使用try-catch-finally处理异常，保证流是一定可以执行关闭操作的（防止出现内存泄漏）</li>
<li>注意流需要手动关闭，在调用关闭方法前还需判断流不是null</li>
<li>读入的文件一定要存在，否则会报FileNotFoundException</li>
</ul></li>
</ol>
<h3 id="二filewriter">(二)、FileWriter</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileWriter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileWriter fileWriter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello_new.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 实例化流类</span></span><br><span class="line">        fileWriter = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 写出操作</span></span><br><span class="line">        <span class="comment">// write()对文件内容进行覆盖</span></span><br><span class="line">        fileWriter.write(<span class="string">&quot;hello world - new\n&quot;</span>);</span><br><span class="line">        fileWriter.write(<span class="string">&quot;\t----hello_new.txt&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fileWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>注意：
<ul>
<li>输出操作，对应的File可以不存在，并不会报异常
<ul>
<li>File对应的硬盘中文件如果不存在，在输出过程中，会自动创建此文件</li>
<li>File对应的硬盘中文件如果存在：
<ul>
<li>如果流使用的构造器为：FileWriter(file, false) 或 FileWriter(file)，则会在执行write()方法对文件进行写入操作后执行对原有文件的覆盖写入操作</li>
<li>如果流使用的构造器为：FileWriter(file, true)，则在执行write()方法对文件进行写入操作后不会对原有文件进行覆盖写入操作，而是在原有文件内容基础上继续追加</li>
</ul></li>
</ul></li>
<li>FileReader和FileWriter不能处理图片等非文本数据的处理</li>
</ul></li>
</ol>
<h3 id="三fileinputstream-fileoutputstream">(三)、FileInputStream &amp; FileOutputStream</h3>
<p>FileReader和FileWriter不能处理图片等非文本数据的处理。处理非文本数据时需使用字节流</p>
<ol type="1">
<li>对于文本文件(.txt, .java, .c, .cpp)：使用字符流处理。</li>
<li>对于非文本文件(图片、视频、音频、文档.doc .ppt)：使用字节流处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileInputOutputStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    String srcFilePath = <span class="string">&quot;F:\\Audio &amp; Video &amp; Picture Download\\Video Download\\速度与激情9.mp4&quot;</span>;</span><br><span class="line">    String destFilePath = <span class="string">&quot;F:\\Audio &amp; Video &amp; Picture Download\\Video Download\\速度与激情9-2.mp4&quot;</span>;</span><br><span class="line"></span><br><span class="line">    copyFile(srcFilePath, destFilePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;copy时间需花费：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>); <span class="comment">// 39606ms</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String srcFilePath, String destFilePath)</span></span>&#123;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. File对象创建</span></span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(srcFilePath);</span><br><span class="line">        File destFile = <span class="keyword">new</span> File(destFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 流对象创建</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 读入及写出操作</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileInputStream.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fileOutputStream.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        <span class="keyword">if</span>(fileInputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fileOutputStream != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四缓冲流处理流的一种">四、缓冲流(处理流的一种)</h2>
<ol type="1">
<li>缓冲流
<ul>
<li>BufferedInputStream</li>
<li>BufferedOutputStream</li>
<li>BufferedReader</li>
<li>BufferedWriter</li>
</ul></li>
<li>作用：提高文件的读写效率；一般开发时不用节点流(文件流)，一般使用效率更高的缓冲流
<ul>
<li>原因：内部提供了缓冲区，默认大小为8kB</li>
<li>bufferedOutputStream.flush()方法：刷新缓存区（即清空缓存区，不管是不是已经存满了缓冲区都把缓冲区内的数据写出去）</li>
</ul></li>
<li>处理流，就是”套接在“已有的流的基础上</li>
</ol>
<h3 id="一bufferedinputstream-bufferedoutputstream">(一)、BufferedInputStream &amp; BufferedOutputStream</h3>
<p>实现非文本文件的复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBufferedStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    String srcFilePath = <span class="string">&quot;F:\\Audio &amp; Video &amp; Picture Download\\Video Download\\速度与激情9.mp4&quot;</span>;</span><br><span class="line">    String destFilePath = <span class="string">&quot;F:\\Audio &amp; Video &amp; Picture Download\\Video Download\\速度与激情9-2.mp4&quot;</span>;</span><br><span class="line"></span><br><span class="line">    copyFileWithBuffered(srcFilePath, destFilePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;copy时间需花费：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>); <span class="comment">//5221ms</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFileWithBuffered</span><span class="params">(String srcFilePath, String destFilePath)</span></span>&#123;</span><br><span class="line">    BufferedInputStream bufferedInputStream = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bufferedOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. File类实例化</span></span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(srcFilePath);</span><br><span class="line">        File destFile = <span class="keyword">new</span> File(destFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 造流</span></span><br><span class="line">        <span class="comment">// 2.1. 先造节点流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line">        <span class="comment">// 2.2. 再造处理流</span></span><br><span class="line">        bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br><span class="line">        bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(fileOutputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 读取和写入操作</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bufferedInputStream.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bufferedOutputStream.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 关闭资源</span></span><br><span class="line">        <span class="comment">// 关闭资源要求：先关闭外层流、再关闭内层流</span></span><br><span class="line">        <span class="comment">// 说明：外层流关闭同时，内层流也会自动关闭。因此内层流关闭操作可省略。</span></span><br><span class="line">        <span class="keyword">if</span>(bufferedInputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bufferedInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bufferedOutputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bufferedOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        fileInputStream.close();</span></span><br><span class="line">        <span class="comment">//        fileOutputStream.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二bufferedwriter-bufferedreader">(二)、BufferedWriter &amp; BufferedReader</h3>
<p>实现文本文件的复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBufferedWriterReader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">    BufferedWriter bufferedWriter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.&amp;2. 创建实例</span></span><br><span class="line">        bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>)));</span><br><span class="line">        bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">&quot;hello-new.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 读写数据</span></span><br><span class="line">        <span class="comment">// 3.1. 方式一</span></span><br><span class="line">        <span class="comment">//        char[] buf = new char[1024];</span></span><br><span class="line">        <span class="comment">//        int len;</span></span><br><span class="line">        <span class="comment">//        while((len = bufferedReader.read(buf)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//            bufferedWriter.write(buf, 0, len);</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2. 方式二</span></span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">while</span>((str = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            bufferedWriter.write(str);</span><br><span class="line">            bufferedWriter.newLine(); <span class="comment">// 换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(bufferedWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bufferedWriter.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习">练习</h3>
<p>图片的加密及解密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图片加密</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPicEncryption</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;GenshinImpact.png&quot;</span>);</span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;GenshinImpact-encryption.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fileInputStream.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                buf[i] ^= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fileOutputStream.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fileInputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fileOutputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片解密：M ^ N ^ N = M</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPicDecryption</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;GenshinImpact-encryption.png&quot;</span>);</span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;GenshinImpact-decryption.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fileInputStream.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                buf[i] ^= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fileOutputStream.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fileInputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fileOutputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五转换流处理流的一种">五、转换流（处理流的一种）</h2>
<ol type="1">
<li><p>转换流(<strong>属于字符流</strong>)：</p>
<ul>
<li>InputStreamReader：将一个字节的输入流转换为字符的输入流</li>
<li>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</li>
</ul></li>
<li><p>转换流作用：处理字节流和字符流之间的转换</p>
<figure>
<img src="/2022/01/09/Coding/Java/13IO%E6%B5%81/85%20Day%20-%2002.png" alt="IO"><figcaption aria-hidden="true">IO</figcaption>
</figure></li>
<li><p>字符集：</p>
<ul>
<li>ASCII：美国标准信息交换码。 用一个字节的7位可以表示。</li>
<li>ISO8859-1：拉丁码表。欧洲码表 用一个字节的8位表示。</li>
<li>GB2312：中国的中文编码表。最多两个字节编码所有字符</li>
<li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</li>
<li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li>
<li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</li>
</ul>
<p>字符集Unicode历史</p>
<blockquote>
<ul>
<li>Unicode不完美，这里就有三个问题，一个是，我们已经知道，英文字母只用一个字节表示就够了，第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现。</li>
<li>面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</li>
<li>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。</li>
</ul>
</blockquote>
<figure>
<img src="/2022/01/09/Coding/Java/13IO%E6%B5%81/83%20Day%20-%2002.png" alt="IO"><figcaption aria-hidden="true">IO</figcaption>
</figure>
<figure>
<img src="/2022/01/09/Coding/Java/13IO%E6%B5%81/84%20Day%20-%2002.png" alt="IO"><figcaption aria-hidden="true">IO</figcaption>
</figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader(FileInputStream, String charset); <span class="comment">//参数2具体使用哪个字符集，取决于文件保存时使用的字符集；实现解码操作</span></span><br><span class="line">OutputStreamWriter(FileOutputStream, String charset); <span class="comment">//参数2使用的字符集，表示输出到文件使用的字符集；实现编码操作</span></span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>对后面学习的启示
<ul>
<li>客户端/浏览器段 &lt;----&gt; 后端(java, GO, Python, Node.js, php) &lt;---&gt; 数据库</li>
<li>要求前前后后使用的字符集都要统一：UTF-8</li>
</ul></li>
</ol>
<h2 id="六标准输入输出流了解">六、标准输入、输出流(了解)</h2>
<ol type="1">
<li>System.in和System.out分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器</li>
</ol>
<ul>
<li><strong>System.in的类型是InputStream</strong>
<ul>
<li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><p>重定向：通过System类的setIn，setOut方法对默认设备进行改变。</p>
<ul>
<li><p>public static void setIn(InputStream in)</p></li>
<li><p>public static void setOut(PrintStream out)</p></li>
</ul></li>
<li><p>从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。</p>
<ul>
<li>方法一：使用Scanner实现，调用next()返回一个字符串</li>
<li>方法二：使用System.in实现</li>
</ul></li>
<li><p>Create a program named MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and String values from the keyboard.</p></li>
</ol>
<h2 id="七打印流了解">七、打印流(了解)</h2>
<ol type="1">
<li>打印流：
<ul>
<li>printStream</li>
<li>printWriter</li>
</ul></li>
<li>作用：实现将基本数据类型的数据格式转化为字符串输出(调用的print(int / float / ...)或println(int / float / ...)等方法都是将各类型数据转换为String在输出到输出设备)</li>
<li>和System.setOut()配合使用</li>
</ol>
<h2 id="八数据流了解">八、数据流(了解)</h2>
<ol type="1">
<li>数据流：
<ul>
<li>DataInputStream：将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中
<ul>
<li>读取不同类型的数据的顺序要与当初写入文件时保存的数据顺序一致</li>
</ul></li>
<li>DataOutputStream：将内存中的基本数据类型变量或字符串写入到文件中</li>
</ul></li>
<li>用于读取或写出<strong>基本数据类型的变量</strong>或<strong>字符串</strong></li>
</ol>
<blockquote>
<ul>
<li>为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。</li>
<li>数据流有两个类：(用于读取和写出基本数据类型、String类的数据）</li>
<li>DataInputStream 和 DataOutputStream</li>
<li>分别“套接”在 InputStream 和 OutputStream 子类的流上</li>
</ul>
</blockquote>
<ol start="3" type="1">
<li>DataInputStream中的常用方法
<ul>
<li>DataInputStream中的方法boolean readBoolean()</li>
<li>char readChar()</li>
<li>double readDouble()</li>
<li>long readLong()</li>
<li>String readUTF()</li>
<li>DataOutputStream中的方法</li>
<li>byte readByte()</li>
<li>float readFloat()</li>
<li>short readShort()</li>
<li>int readInt()</li>
<li>void readFully(byte[] b)</li>
</ul></li>
<li>DataOutputStream
<ul>
<li>将上述的方法的read改为相应的write即可。</li>
</ul></li>
</ol>
<h2 id="九对象流掌握">九、对象流(掌握)</h2>
<p>数据流只能用于基本数据类型或字符串的读取或写入，不能实现对象的读取或写入。</p>
<h3 id="一对象流概念">(一)、对象流概念</h3>
<ol type="1">
<li><p>对象流</p>
<ul>
<li>ObjectInputStream：内存中的对象 --&gt; 存储中的文件、通过网络传输出去</li>
<li>OjbectOutputSteam：存储中的文件、通过网络接收过理 --&gt; 内存中的对象</li>
</ul></li>
<li><p>作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p></li>
<li><p>序列化和反序列化：</p>
<ul>
<li>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制</li>
<li>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制</li>
<li>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</li>
</ul></li>
</ol>
<h3 id="二对象的序列化对象流重心重点为对象序列化机制">(二)、对象的序列化（对象流重心，重点为对象序列化机制）</h3>
<ol type="1">
<li>序列化和反序列化：要求操作对象所属的类是可序列化、可反序列化的。【对象序列化机制】</li>
<li><strong>对象序列化机制</strong>允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点(序列化)。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象(反序列化)【能用自己的话表述】
<ul>
<li>序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去；使用ObjectOutputStream实现
<ul>
<li>调用writeObject()方法后，再<strong>显式调用flush()刷新</strong></li>
</ul></li>
<li>反序列化过程：将磁盘文件中的对象还原为内存中的对象；使用ObjectInputStream实现</li>
</ul></li>
</ol>
<blockquote>
<ul>
<li>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原</li>
<li>序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是JavaEE平台的基础</li>
</ul>
</blockquote>
<ol start="3" type="1">
<li>一般开发中会将各种类型的需要序列化的对象转化为String类型（即json文件类型），原因是String实现了序列化。</li>
</ol>
<h3 id="三自定义类的序列化">(三)、自定义类的序列化</h3>
<ul>
<li><p>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableException异常</p>
<ul>
<li><strong>Serializable</strong></li>
<li>Externalizable</li>
</ul></li>
<li><p>自定义类需要满足如下要求，方可序列化</p>
<ul>
<li>需要实现接口：<strong>Serializable</strong></li>
<li>给该类提供一个全局常量：serialVersionUID
<ul>
<li>用以唯一标识某个类</li>
</ul></li>
<li>除了当前操作对象所属类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的
<ul>
<li>实际上当对象用到了内部自定义的其他属性时，才需将该属性所属类实现序列化接口，但为了程序健壮性要求属性所属自定义类都需实现Serializable接口</li>
<li>默认情况下，基本数据类型是可序列化的</li>
</ul></li>
</ul></li>
<li><p>补充：</p>
<ul>
<li>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量
<ul>
<li>static的属性或其他成员属于类，而不属于对象，因此序列化对象时不能序列化static的成员变量。</li>
<li>transient为不允许序列化的关键字，加上此关键字的成员变量无法被序列化</li>
<li>成员变量使用static / transient的对象序列化可以成功，但无法把static / transient成员变量写入文件或发送至网络，反序列化时的static / transient成员变量值为所属类的默认值</li>
</ul></li>
</ul></li>
<li><p>使自定义Person类支持序列化机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">464135431543544L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != person.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Person的序列化过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSerializable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. &amp; 2.</span></span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;Person_Object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        oos.flush(); <span class="comment">// 显式调用flush</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Person的反序列化过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">antiSerializeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. &amp; 2.</span></span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;Person_Object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        Person p = (Person) obj;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="四serialverionuid">(四)、serialVerionUID</h3>
<ul>
<li>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。<strong>若类的实例变量做了修改，serialVersionUID 可能发生变化，序列化和反序列化容易出错</strong>。故建议，显式声明。
<ul>
<li>使用默认serialVersionUID时，若序列化后对类进行了更改，则反序列化时会出现异常，因此需要显式声明serialVersionUID</li>
</ul></li>
</ul>
<h2 id="十随机存取文件流了解">十、随机存取文件流(了解)</h2>
<h3 id="一randomaccessfile-类">(一)、RandomAccessFile 类</h3>
<ul>
<li>RandomAccessFile区别于其他流
<ul>
<li><strong>声明在java.io包下</strong>，但<strong>直接继承于java.lang.Object类</strong>。</li>
<li>并且它<strong>实现了DataInput、DataOutput这两个接口</strong>，也就意味着这个<strong>类既可以读也可以写</strong>。</li>
</ul></li>
<li>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件
<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul></li>
</ul>
<h3 id="二构造器">(二)、构造器</h3>
<ol type="1">
<li><p>构造器</p>
<ul>
<li>public RandomAccessFile(File file, String mode)</li>
<li>public RandomAccessFile(String name, String mode)</li>
</ul></li>
<li><p>mode参数</p>
<ul>
<li><p>创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式：</p>
<ul>
<li>r: 以只读方式打开</li>
<li>rw：打开以便读取和写入</li>
<li>rwd:打开以便读取和写入；同步文件内容的更新</li>
<li>rws:打开以便读取和写入；同步文件内容和元数据的更新</li>
</ul>
<blockquote>
<p>JDK1.6中写道：每次write数据时，"rw"模式下数据不会立即写入到硬盘中；而"rwd"下数据会被立即写入到硬盘中。如果写数据发生异常，"rwd"模式中已被write的数据被保存至硬盘，而"rw"则全部丢失</p>
</blockquote></li>
<li><p>如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。</p></li>
<li><p>如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。</p></li>
</ul></li>
<li><p>实现文件内容的复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RandomAccessFile randomAccessFile = <span class="keyword">null</span>;</span><br><span class="line">    RandomAccessFile randomAccessFile2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;GenshinImpact.png&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        randomAccessFile2 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;GenshinImpact-access.png&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = randomAccessFile.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            randomAccessFile2.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(randomAccessFile != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                randomAccessFile.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(randomAccessFile2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                randomAccessFile2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三randomaccessfile类的使用">(三)、RandomAccessFile类的使用</h3>
<ol type="1">
<li><p>输出流</p>
<ul>
<li>如果RandomAccessFile作为输出流时，写入到的文件若不存在，则执行过程中自动创建</li>
<li>如果写出的文件存在，则会对原有内容依次向后覆盖，且从头开始覆盖，并不会一次全部覆盖。</li>
</ul></li>
<li><p>输出内容至指定位置</p>
<ul>
<li>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。 RandomAccessFile 类对象可以自由移动记录指针：
<ul>
<li>long getFilePointer()：获取文件记录指针的当前位置</li>
<li>void seek(long pos)：将文件记录指针定位到 pos 位置</li>
</ul></li>
<li>调用write后输出的内容将在指定位置覆盖指定位置后面的内容，若要实现插入内容，则需要将指定位置至文件结尾的全部内容读出，再将需要插入的内容写入文件，最后再将刚刚读出的内容写入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在hello.txt的第三个位置插入内容</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRandomAccessFileInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RandomAccessFile randomAccessFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        randomAccessFile.seek(<span class="number">3</span>); <span class="comment">// 将指针指向角标为3的位置</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 将数据保存至StringBuilder</span></span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = randomAccessFile.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            builder.append(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, len)); <span class="comment">// 需要指定长度，否则会把整个byte数组添加到builder</span></span><br><span class="line">        &#125;</span><br><span class="line">        randomAccessFile.seek(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        randomAccessFile.write(<span class="string">&quot;xyz&quot;</span>.getBytes()); <span class="comment">// 字符串转换为byte数组</span></span><br><span class="line">        randomAccessFile.write(builder.toString().getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (randomAccessFile != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                randomAccessFile.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>我们可以用RandomAccessFile这个类，来实现一个多线程断点下载的功能，用过下载工具的朋友们都知道，下载前都会建立两个临时文件，一个是与被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上一次的地方下载，从而实现断点下载或上传的功能，有兴趣的朋友们可以自己实现下。</p></li>
</ol>
<h2 id="十一nio.2中pathpaths-files类的使用了解">十一、NIO.2中Path、Paths、 Files类的使用(了解)</h2>
<h3 id="一nio-nio.2">(一)、NIO / NIO.2</h3>
<p>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO<strong>支持面向缓冲区的</strong>(IO是面向流的)、基于通道的IO操作。NIO<strong>将以更加高效的方式进行文件的读写操作</strong>。【前面的流都是阻塞IO】</p>
<p>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</p>
<p>Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<blockquote>
<p>|——java.nio.channels.Channel</p>
<pre><code>  |——FileChannel:处理本地文件

  |——SocketChannel：TCP网络编程的客户端的Channel

  |——ServerSocketChannel:TCP网络编程的服务器端的Channel

  |——DatagramChannel：UDP网络编程中发送端和接收端的Channel</code></pre>
</blockquote>
<h3 id="二pathpaths和files">(二)、Path、Paths和Files</h3>
<ol type="1">
<li><p>3个类声明在java.nio.file包下</p></li>
<li><blockquote>
<p>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</p>
</blockquote>
<p>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。<strong>Path可以看成是File类的升级版本，实际引用的资源也可以不存在</strong>。【即可用Path替换File】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path 常用方法：</span><br><span class="line">	<span class="function">String <span class="title">toString</span><span class="params">()</span> <span class="comment">//： 返回调用 Path 对象的字符串表示形式</span></span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String path)</span><span class="comment">// : 判断是否以 path 路径开始</span></span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String path)</span><span class="comment">// : 判断是否以 path 路径结束</span></span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">isAbsolute</span><span class="params">()</span><span class="comment">// : 判断是否是绝对路径</span></span></span><br><span class="line"><span class="function">	Path <span class="title">getParent</span><span class="params">()</span><span class="comment">// ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</span></span></span><br><span class="line"><span class="function">	Path <span class="title">getRoot</span><span class="params">()</span><span class="comment">// ：返回调用 Path 对象的根路径</span></span></span><br><span class="line"><span class="function">	Path <span class="title">getFileName</span><span class="params">()</span><span class="comment">// : 返回与调用 Path 对象关联的文件名</span></span></span><br><span class="line"><span class="function">	<span class="keyword">int</span> <span class="title">getNameCount</span><span class="params">()</span><span class="comment">// : 返回Path 根目录后面元素的数量</span></span></span><br><span class="line"><span class="function">	Path <span class="title">getName</span><span class="params">(<span class="keyword">int</span> idx)</span><span class="comment">// : 返回指定索引位置 idx 的路径名称</span></span></span><br><span class="line"><span class="function">	Path <span class="title">toAbsolutePath</span><span class="params">()</span><span class="comment">// : 作为绝对路径返回调用 Path 对象</span></span></span><br><span class="line"><span class="function">	Path <span class="title">resolve</span><span class="params">(Path p)</span><span class="comment">// :合并两个路径，返回合并后的路径对应的Path对象</span></span></span><br><span class="line"><span class="function">	File <span class="title">toFile</span><span class="params">()</span><span class="comment">//: 将Path转化为File类的对象</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>同时，NIO.2在java.nio.file包下还<strong>提供了Files、Paths工具类</strong>，</p>
<ul>
<li><p>Files包含了大量静态的工具方法来操作文件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.nio.file.Files 用于操作文件或目录的工具类。</span><br><span class="line">Files常用方法：</span><br><span class="line">	<span class="function">Path <span class="title">copy</span><span class="params">(Path src, Path dest, CopyOption … how)</span><span class="comment">// : 文件的复制</span></span></span><br><span class="line"><span class="function">	Path <span class="title">createDirectory</span><span class="params">(Path path, FileAttribute&lt;?&gt; … attr)</span><span class="comment">// : 创建一个目录</span></span></span><br><span class="line"><span class="function">	Path <span class="title">createFile</span><span class="params">(Path path, FileAttribute&lt;?&gt; … arr)</span><span class="comment">// : 创建一个文件</span></span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">delete</span><span class="params">(Path path)</span><span class="comment">// : 删除一个文件/目录，如果不存在，执行报错</span></span></span><br><span class="line"><span class="function">	<span class="keyword">void</span> <span class="title">deleteIfExists</span><span class="params">(Path path)</span><span class="comment">// : Path对应的文件/目录如果存在，执行删除</span></span></span><br><span class="line"><span class="function">	Path <span class="title">move</span><span class="params">(Path src, Path dest, CopyOption…how)</span><span class="comment">// : 将 src 移动到 dest 位置</span></span></span><br><span class="line"><span class="function">	<span class="keyword">long</span> <span class="title">size</span><span class="params">(Path path)</span><span class="comment">// : 返回 path 指定文件的大小</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Files常用方法：用于判断</span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(Path path, LinkOption … opts)</span><span class="comment">// : 判断文件是否存在</span></span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">(Path path, LinkOption … opts)</span><span class="comment">// : 判断是否是目录</span></span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">isRegularFile</span><span class="params">(Path path, LinkOption … opts)</span><span class="comment">// : 判断是否是文件</span></span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">(Path path)</span><span class="comment">// : 判断是否是隐藏文件</span></span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">(Path path)</span><span class="comment">// : 判断文件是否可读</span></span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">(Path path)</span><span class="comment">// : 判断文件是否可写</span></span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">notExists</span><span class="params">(Path path, LinkOption … opts)</span><span class="comment">// : 判断文件是否不存在</span></span></span><br><span class="line"><span class="function">Files常用方法：用于操作内容</span></span><br><span class="line"><span class="function">	SeekableByteChannel <span class="title">newByteChannel</span><span class="params">(Path path, OpenOption…how)</span><span class="comment">// : 获取与指定文件的连接，how 指定打开方式。</span></span></span><br><span class="line"><span class="function">	DirectoryStream&lt;Path&gt;  <span class="title">newDirectoryStream</span><span class="params">(Path path)</span><span class="comment">// : 打开 path 指定的目录</span></span></span><br><span class="line"><span class="function">	InputStream <span class="title">newInputStream</span><span class="params">(Path path, OpenOption…how)</span><span class="comment">//:获取InputStream 对象</span></span></span><br><span class="line"><span class="function">	OutputStream <span class="title">newOutputStream</span><span class="params">(Path path, OpenOption…how)</span><span class="comment">// : 获取 OutputStream 对象</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>Paths则包含了两个返回Path的静态工厂方法。Paths 类提供的静态 get() 方法用来获取 Path 对象：</p>
<ul>
<li>static Path get(String first, String … more) : 用于将多个字符串串连成路径</li>
<li>static Path get(URI uri): 返回指定uri对应的Path路径</li>
</ul></li>
</ul></li>
</ol>
<h2 id="补充第三方api-jar包导入">补充（第三方API jar包导入）</h2>
<p>若要导入到当前Module下</p>
<ol type="1">
<li>在Module上右键 --&gt; New Directory --&gt; 第三方jar包一般都放在lib中</li>
<li>将jar包复制粘贴进lib目录下，此时的jar包还无法使用</li>
<li>右键jar包，选择Add as Library，选择OK，此时既可使用jar包下的API</li>
</ol>
<p>一般开发中无需自己写IO流实现功能，而是有相应的jar包或API直接调用即可。</p>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li><p>如何遍历Map的key集、value集、key-value集，使用上泛型</p></li>
<li><p>写出使用Iterator和增强for循环遍历List<String>的代码，使用上泛型</String></p></li>
<li><p>提供一个方法，用于遍历获取HashMap&lt;String, String&gt;中的所有value，并存放在List中返回。考虑上集合中泛型的使用。</p></li>
<li><p>创建一个与a.txt文件同目录下的另外一个文件b.txt</p></li>
<li><p>Map接口中的常用方法有哪些？</p></li>
<li><p>说明流的三种分类方式</p></li>
<li><p>写出4个IO流中的抽象基类、4个文件流、4个缓冲流</p></li>
<li><p>字节流与字符流的区别与使用情景</p>
<p>字节流针对处理非文本文件，字符流针对处理文本文件</p>
<p>字节流：read(byte[] buffer) / byte read()</p>
<p>字符流：read(char[] cbuf) / char read()</p></li>
<li><p>使用缓冲流实现a.jpg文件复制为b.jpg文件的操作</p></li>
<li><p>转换流是那两个类，分别的作用是什么？请分别创建两个类的对象。</p></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第11.5章 Java版数据结构概述</title>
    <url>/2022/01/07/Coding/Java/11dot5Java%E7%89%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="第11.5章java版数据结构概述">第11.5章、Java版数据结构概述</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>数据结构 - Java 版</li>
<li>数据结构与算法</li>
</ol>
<span id="more"></span>
<h2 id="数据结构-java版">数据结构-Java版</h2>
<figure>
<img src="/2022/01/07/Coding/Java/11dot5Java%E7%89%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/数据结构-Java版.svg" alt="数据结构-Java版"><figcaption aria-hidden="true">数据结构-Java版</figcaption>
</figure>
<h2 id="数据结构与算法">数据结构与算法</h2>
<figure>
<img src="/2022/01/07/Coding/Java/11dot5Java%E7%89%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/数据结构知识结构框架图.jpg" alt="数据结构知识结构框架图"><figcaption aria-hidden="true">数据结构知识结构框架图</figcaption>
</figure>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第11章 Java集合</title>
    <url>/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="第十一章java集合">第十一章、Java集合</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、Java 集合框架概述</li>
<li>二、Collection 接口方法（抽象方法）</li>
<li>四、Collection 子接口一：List</li>
<li>五、Collection 子接口二：Set（重要性低于 List、Map）</li>
<li>六、Map 接口</li>
<li>七、Collections 工具类</li>
<li>面试题</li>
<li>每日一考</li>
</ol>
<span id="more"></span>
<h2 id="一java集合框架概述">一、Java集合框架概述</h2>
<h3 id="一概述">(一)、概述</h3>
<p>集合、数组都是对多个数据进行存储操作的结构，简称为<strong>java容器</strong>【说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt, .jpg ...）】</p>
<ol type="1">
<li>一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。
<ul>
<li>数组在内存存储方面的特点：
<ul>
<li>数组初始化以后，长度就确定了。</li>
<li>数组声明的类型，就决定了进行元素初始化时的类型</li>
</ul></li>
<li>数组在存储数据方面的弊端：
<ul>
<li>数组初始化以后，长度就不可变了，不便于扩展</li>
<li>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数</li>
<li>数组存储的数据是有序的、可以重复的。----&gt;存储数据的特点单一。对于无序、不可重复的需求不能满足</li>
</ul></li>
</ul></li>
<li>Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。</li>
</ol>
<h3 id="二集合框架">(二)、集合框架</h3>
<p>Java 集合可分为 Collection 和 Map 两种体系</p>
<ul>
<li><p>Collection接口：单列数据，定义了存取一组对象的方法的集合</p>
<ul>
<li>List：元素有序、可重复的集合。---&gt; “动态”数组
<ul>
<li>List接口<strong>实现类</strong>：<strong>ArrayList、LinkedList、Vector</strong></li>
</ul></li>
<li>Set：元素无序、不可重复的集合。---&gt; 数学上的“集合”
<ul>
<li>Set接口<strong>实现类</strong>：HashSet、LinkedHashSet、TreeSet</li>
</ul></li>
</ul></li>
<li><p>Map接口：双列数据，保存具有映射关系“key-value对”的集合 ---&gt; 数学上的“函数”：y = f(x) 【value = f(key)】</p>
<ul>
<li>Map接口<strong>实现类</strong>：<strong>HashMap</strong>、LinkedHashMap、TreeMap、Hashtable、Properties</li>
</ul></li>
<li><p>Collection接口继承树</p>
<figure>
<img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/73%20Day%20-%2002.png" alt="Collection接口继承树"><figcaption aria-hidden="true">Collection接口继承树</figcaption>
</figure></li>
<li><p>Map接口继承树</p>
<figure>
<img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/74%20Day%20-%2002.png" alt="Collection接口继承树"><figcaption aria-hidden="true">Collection接口继承树</figcaption>
</figure></li>
</ul>
<h2 id="二collection接口方法抽象方法">二、Collection接口方法（抽象方法）</h2>
<ol type="1">
<li><p>add(Object e) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(Object e): 将元素e添加到集合中</span><br></pre></td></tr></table></figure></p></li>
<li><p>size() <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">size(): 获取添加的元素个数</span><br></pre></td></tr></table></figure></p></li>
<li><p>addAll(Collection coll1) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addAll(Collection coll1): 将coll1集合中的元素添加到当前的集合中</span><br></pre></td></tr></table></figure></p></li>
<li><p>isEmpty() <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isEmpty(): 判断当前集合是否为空</span><br></pre></td></tr></table></figure></p></li>
<li><p>clear() <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clear(): 清空集合中的所有元素</span><br></pre></td></tr></table></figure></p></li>
<li><p>contains(Object obj) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">contains(Object obj): 判断当前集合中是否包含obj</span><br><span class="line"><span class="comment">// 在判断时，会调用obj的equals()方法</span></span><br><span class="line"><span class="comment">// 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals()方法</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals()方法</strong></li>
</ul></li>
<li><p>containsAll(Collection coll1) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">containsAll(Collection coll1): 判断形参coll1中的所有元素是否都存在于当前集合中</span><br></pre></td></tr></table></figure></p></li>
<li><p>remove(Object obj) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">remove(Object obj): 从当前集合中移除obj元素，且在移除前使用equals()方法判断是否存在于当前集合中</span><br></pre></td></tr></table></figure></p></li>
<li><p>removeAll(Collection coll1) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">removeAll(Collection coll1): 从当前集合中移除coll1中的所有元素（移除的是当前集合和coll1的交集元素，同样在移除前会调用各元素的equals()方法），差集</span><br></pre></td></tr></table></figure></p></li>
<li><p>retainAll(Collection coll1) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">retainAll(Collection coll1): 交集，获取当前集合和coll1的交集，并直接将当前集合修改为结果</span><br></pre></td></tr></table></figure></p></li>
<li><p>equals(Object obj) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">equals(Object obj): 判断当前集合和形参是否相同（当形参为集合时，需要元素是相同的顺序且调用对应元素的equals()方法）</span><br></pre></td></tr></table></figure></p></li>
<li><p>hashCode() <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashCode(): 返回当前对象的哈希值（Object类中已定义hashCode()方法）</span><br></pre></td></tr></table></figure></p></li>
<li><p>toArray() <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">toArray(): 集合 --&gt; 数组，方法返回一个Object[]类型</span><br><span class="line">Arrays.asList(T... a): 数组 --&gt; 集合，调用Arrays类的静态方法asList()，形参为可变形参</span><br><span class="line">    List&lt;String&gt; arr = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, String.valueOf(<span class="number">123</span>), <span class="string">&quot;BB&quot;</span>&#125;);</span><br><span class="line">        System.out.println(arr); <span class="comment">//[AA, 123, BB]</span></span><br><span class="line"></span><br><span class="line">        List arr1 = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">12</span>, <span class="number">45</span>, <span class="number">78</span>&#125;); </span><br><span class="line">		<span class="comment">//提示：Call to &#x27;asList()&#x27; with only one argument</span></span><br><span class="line">		<span class="comment">// 被识别为一个参数</span></span><br><span class="line">        System.out.println(arr1); <span class="comment">//[[I@4f8e5cde]</span></span><br><span class="line"></span><br><span class="line">        List arr2 = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">12</span>, <span class="number">45</span>, <span class="number">78</span>&#125;);</span><br><span class="line">        System.out.println(arr2); <span class="comment">//[12, 45, 78]</span></span><br><span class="line"></span><br><span class="line">        List arr3 = Arrays.asList(<span class="number">12</span>, <span class="number">45</span>, <span class="number">78</span>);</span><br><span class="line">        System.out.println(arr3); <span class="comment">//[12, 45, 78]</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>toArray(T[] a) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">toArray(T[] a)</span><br></pre></td></tr></table></figure></p></li>
<li><p>iterator() <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iterator(): 返回Iterator接口的实例，用于遍历集合元素。放在IteratorTest.java中测试</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="三iterator迭代器接口">三、Iterator迭代器接口</h2>
<ul>
<li>Iterator对象称为迭代器(设计模式的一种)，主要<strong>用于遍历 Collection 集合</strong>中的元素。（无法遍历Map中的元素）</li>
<li>GOF给迭代器模式的定义为：<strong>提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生</strong>。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。</li>
<li>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</li>
<li><strong>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。</strong></li>
<li><strong>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</strong></li>
</ul>
<figure>
<img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/75%20Day%20-%2002.png" alt="alt"><figcaption aria-hidden="true">alt</figcaption>
</figure>
<ol type="1">
<li><p>next() <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">next(): 返回迭代器中的下一个元素</span><br><span class="line">    <span class="comment">// 执行next时：①指针下移 ②将下移后集合位置上的元素返回</span></span><br><span class="line">    <span class="comment">// Throws: NoSuchElementException - if the iteration has no more elements </span></span><br></pre></td></tr></table></figure></p></li>
<li><p>hasNext() <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hasNext(): 判断是否还有下一个元素</span><br></pre></td></tr></table></figure></p></li>
<li><p>方法使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="number">123</span>);</span><br><span class="line">coll.add(<span class="string">&quot;Aa&quot;</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> Date());</span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">Iterator iterator = coll.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐写法</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; coll.size(); i++)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐写法</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk 5.0新增了foreach循环</span></span><br><span class="line"><span class="comment">// for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line"><span class="comment">// 内部仍然调用了迭代器 iterator</span></span><br><span class="line"><span class="keyword">for</span> (Object obj: coll) &#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for(集合元素的类型 局部变量 : 数组对象)</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i :</span><br><span class="line">     arr) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 笔试题</span></span><br><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;MM&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用增强for循环（或foreach）</span></span><br><span class="line"><span class="keyword">for</span> (String s :</span><br><span class="line">     arr) &#123;</span><br><span class="line">    s = <span class="string">&quot;GG&quot;</span>; <span class="comment">// 使用的局部变量进行赋值，不改变原有元素值</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr)); <span class="comment">//[MM, MM, MM]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一：普通for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    arr[i] = <span class="string">&quot;GG&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr)); <span class="comment">//[GG, GG, GG]</span></span><br></pre></td></tr></table></figure></li>
<li><p>remove() <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">remove(): 可在遍历时删除集合中的元素，删除当前iterator指针指向的元素。此方法不同于集合中的remove()方法。</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</li>
<li>如果还未调用过next()或在上一次调用 next 方法之后已经调用过了 remove 方法，再调用remove都会报<strong>IllegalStateException</strong>。</li>
</ul></li>
</ol>
<h2 id="四collection子接口一list">四、Collection子接口一：List</h2>
<ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常<strong>使用List替代数组</strong></li>
<li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。
<ul>
<li>同：三个类都实现了List接口，存储数据的特点相同：存储有序、可重复的数据</li>
<li>异：
<ul>
<li>ArrayList：
<ul>
<li>作为List接口的主要实现类</li>
<li>线程不安全，因此效率高</li>
<li><strong>底层使用Object[] elementData存储</strong></li>
</ul></li>
<li>LinkedList：
<ul>
<li>对于频繁的插入、删除操作，使用此类效率比ArrayList高</li>
<li><strong>底层使用双向链表</strong></li>
</ul></li>
<li>Vector：
<ul>
<li>作为List接口的古老实现类。【JDK1.0时即存储有序、可重复的数据，JDK1.2后出现的List接口，且紧接着出现了两个实现类ArrayList、LinkedList，后把Vector归入List接口的实现类】</li>
<li><strong>线程安全</strong>，效率低</li>
<li><strong>底层使用Object[] elementData存储</strong></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="一arraylist源码分析---jdk7情况下">(一)、ArrayList源码分析 - JDK7情况下</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 空参构造器创建了一个长度为10的Object数组</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// elementData[0] = new Integer(123);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">11</span>); <span class="comment">// 如果此次的添加导致底层elementData数组容量不足，则扩容；默认情况下，扩容为原来的1.5倍，同时需将原有数组中的数据复制到新的数组中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：建议开发中使用带参构造器</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(<span class="keyword">int</span> capacity);</span><br></pre></td></tr></table></figure>
<h3 id="二arraylist源码分析---jdk8情况下">(二)、ArrayList源码分析 - JDK8情况下</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(); <span class="comment">// 底层Object[] elementData初始化为&#123;&#125;。并没有创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 后续添加和扩容操作与JDK7无异</span></span><br></pre></td></tr></table></figure>
<p>JDK7中的ArrayList的创建类似于单例模式的饿汉式，而JDK8中的ArrayList的创建类似于单例模式的懒汉式，延迟了数组的创建，节省内存。</p>
<h3 id="三linkedlist源码分析">(三)、LinkedList源码分析</h3>
<p>JDK7和JDK8中的LinkedList底层无差别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList(); <span class="comment">//内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 将123封装到Node中，创建了Node对象</span></span><br></pre></td></tr></table></figure>
<p>其中Node类为LinkedList的内部静态类，其定义体现了LinkedList的双向链表结构，定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四vector源码分析">(四)、Vector源码分析</h3>
<p>JDK7和JDK8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组；在扩容方面，默认每次扩容为当前数组长度的2倍</p>
<p>Stack类即栈是Vector子类</p>
<h3 id="五list接口中的常用方法">(五)、List接口中的常用方法</h3>
<ol type="1">
<li><p>add <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span></span>; <span class="comment">//在index位置插入ele元素</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>addAll <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Boolean <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection eles)</span></span>; <span class="comment">// 从index位置开始将eles中的所有元素加入到当前集合中</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>get <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">//获取指定index位置的元素</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>indexOf <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>; <span class="comment">//返回obj在集合中首次出现的位置，若不存在返回-1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>lastIndexOf <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object obj)</span></span>; <span class="comment">//返回obj在集合中末次出现的位置，若不存在返回-1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>remove <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">//移除指定index位置的元素，并返回此元素。是Collection中remove方法的重载</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>set <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object ele)</span></span>; <span class="comment">//设置指定index位置的元素为ele</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>subList <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>; <span class="comment">//返回从fromIndex到toIndex位置的左闭右开区间内的元素</span></span><br></pre></td></tr></table></figure></p>
<p>即List接口在Collection接口定义的方法基础上有定义了新的方法</p></li>
</ol>
<h3 id="六总结常用方法不去看api就能用">(六)、总结：常用方法（不去看API就能用）</h3>
<ol type="1">
<li><p>增：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(Object obj)</span><br></pre></td></tr></table></figure></li>
<li><p>删</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">remove(<span class="keyword">int</span> index); / remove(Object obj)</span><br></pre></td></tr></table></figure></li>
<li><p>改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set(<span class="keyword">int</span> index, Object ele);</span><br></pre></td></tr></table></figure></li>
<li><p>查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">get(<span class="keyword">int</span> index);</span><br></pre></td></tr></table></figure></li>
<li><p>插</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(<span class="keyword">int</span> index, Object ele)</span><br></pre></td></tr></table></figure></li>
<li><p>长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">size()</span><br></pre></td></tr></table></figure></li>
<li><p>遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iterator迭代器方式</span><br><span class="line">增强<span class="keyword">for</span>循环</span><br><span class="line">普通循环</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="五collection子接口二set重要性低于listmap">五、Collection子接口二：Set（重要性低于List、Map）</h2>
<h3 id="一set接口的框架">(一)、Set接口的框架</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">    /----Set接口：存储无序的、不可重复的数据</span><br><span class="line">    	/----HashSet：作为Set接口的主要实现类；线程不安全；可存储<span class="keyword">null</span>值</span><br><span class="line">    		/----LinkedHashSet：作为HashSet的子类；遍历其内部数据时可按照添加的顺序遍历</span><br><span class="line">    	/----TreeSet：底层使用二叉树中的红黑树存储数据；只能添加同一个类<span class="keyword">new</span>的对象，且可按照添加对象的指定属性进行排序</span><br></pre></td></tr></table></figure>
<p>Set接口中没有额外定义的新方法，使用的都是Collection中声明过的方法</p>
<h3 id="二理解set的无序性和不可重复性">(二)、理解Set的无序性和不可重复性</h3>
<p>以HashSet为例：</p>
<ol type="1">
<li>无序性：不等于随机性
<ul>
<li>存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值确定其位置</li>
<li>即不按照程序调用顺序添加元素</li>
</ul></li>
<li>不可重复性：保证添加的元素按照equals()方法判断时，不能返回true，即相同的元素只能添加一个</li>
</ol>
<h3 id="三添加元素的过程以jdk7-hashset为例">(三)、添加元素的过程：以JDK7 HashSet为例</h3>
<p>向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出此元素在HashSet底层数组中的存放位置（即为索引位置），判断数组此位置上是否已经有元素：</p>
<ul>
<li>如果此位置上没有其他元素，则元素a添加成功 ----&gt; 情况1</li>
<li>如果此位置上有其他元素b（或以链表形式存在的多个元素），则比较元素a与元素b的hash值：
<ul>
<li>如果hash值不同，则元素a添加成功 ----&gt; 情况2</li>
<li>如果hash值相同，进而需要调用元素a所在类的equals()方法
<ul>
<li>若equals()返回true，元素a添加失败</li>
<li>若equals()返回false，元素a添加成功 ----&gt; 情况3</li>
</ul></li>
</ul></li>
</ul>
<p>对于添加成功的情况2和3而言：元素a与已经存在保存在指定索引位置上的数据以链表方式存储。JDK7中元素a放在数组中，指向原来的所有元素的first；JDK8中原来的元素在数组或链表中，原来的元素的last指向元素a</p>
<p><strong>HashSet底层：数组+链表的结构</strong>，new的HashSet实际上内部new 的HashMap，而HashSet中的add()方法实际上调用的是HashMap的put()方法。（JDK7的底层数据，与HashMap相关）</p>
<h3 id="四hashcode的重写">(四)、hashCode()的重写</h3>
<figure>
<img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/76%20Day%20-%2002.png" alt="HashCode"><figcaption aria-hidden="true">HashCode</figcaption>
</figure>
<p>要求：</p>
<ul>
<li><p><strong>向Set中添加的数据，其所在类一定要重写hashCode()和equals()</strong></p></li>
<li><p><strong>重写的hashCode()和equals()尽可能保持一致性：相等的对象(equals()返回true)必须具有相等的散列码</strong></p>
<ul>
<li>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值</li>
<li>推荐使用IDE自动重写的方法</li>
</ul></li>
</ul>
<h3 id="五linkedhashset">(五)、LinkedHashSet</h3>
<p>LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。</p>
<p>优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p>
<h3 id="六treeset了解">(六)、TreeSet（了解）</h3>
<ol type="1">
<li><p>向TreeSet中添加的数据，要求是相同类的对象，不能添加不同类的对象。从而实现按属性对对象排序（二叉树中的红黑树，排序复杂度为O(1)）</p></li>
<li><p>排序的两种方式：<strong>自然排序（实现Comparable接口） &amp; 定制排序 （实现Comparator接口）</strong></p>
<ul>
<li><p>自然排序（添加到TreeSet中的对象所属类实现Comparable接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.javapack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hunt Wu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-10-21:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        User user = (User) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != user.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(user.name) : user.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照姓名从小到大排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            User user = (User) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(user.name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TreeSetTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeSet treeSet = <span class="keyword">new</span> TreeSet();</span><br><span class="line"></span><br><span class="line">    treeSet.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> User(<span class="string">&quot;Jhon&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">15</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> User(<span class="string">&quot;Taylor&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> User(<span class="string">&quot;Hunt&quot;</span>, <span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = treeSet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Hunt&#x27;, age=24&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Jack&#x27;, age=15&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Jhon&#x27;, age=22&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Taylor&#x27;, age=25&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定制排序（）</p>
<ul>
<li>使用TreeSet构造函数的Comparator参数构造器，将匿名实现类的对象或匿名实现类的匿名对象作为参数</li>
</ul>
<figure>
<img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/77%20Day%20-%2002.png" alt="TreeSet"><figcaption aria-hidden="true">TreeSet</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TreeSetTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeSet treeSet2 = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">        <span class="comment">// 年龄从小到大排序</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                User user1 = (User) o1;</span><br><span class="line">                User user2 = (User) o2;</span><br><span class="line">                <span class="comment">// return ((Integer)user1.getAge()).compareTo(user2.getAge());</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(user1.getAge(), user2.getAge());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;比较类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    treeSet2.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>));</span><br><span class="line">    treeSet2.add(<span class="keyword">new</span> User(<span class="string">&quot;Jhon&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    treeSet2.add(<span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="number">15</span>));</span><br><span class="line">    treeSet2.add(<span class="keyword">new</span> User(<span class="string">&quot;Taylor&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    treeSet2.add(<span class="keyword">new</span> User(<span class="string">&quot;Hunt&quot;</span>, <span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = treeSet2.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Jack&#x27;, age=15&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Jhon&#x27;, age=22&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Hunt&#x27;, age=24&#125;</span></span><br><span class="line"><span class="comment">        User&#123;name=&#x27;Taylor&#x27;, age=25&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>TreeSet中判断添加的两个对象是否相同</strong>：</p>
<ul>
<li>自然排序中比较两个对象是否相同的标准：compareTo()方法返回0，不再是equals()</li>
<li>定制排序中比较两个对象是否相同的标准：compare()方法返回0，不再是equals()</li>
</ul></li>
</ol>
<h2 id="六map接口">六、Map接口</h2>
<p>与Collection接口并列</p>
<h3 id="一map接口继承树">(一)、Map接口继承树</h3>
<figure>
<img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/78%20Day%20-%2002.png" alt="Map"><figcaption aria-hidden="true">Map</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/----Map：双列数据，保存具有映射关系“key-value对”的集合 ---&gt; 数学上的“函数”：y = f(x) 【value = f(key)】</span><br><span class="line">    /----HashMap:作为Map的主要实现类，线程不安全，效率高；可存储<span class="keyword">null</span>的key和value，健壮性好。底层使用 数组+链表(JDK7)、数组+链表+红黑树(JDK8)</span><br><span class="line">		/----LinkedHashMap：保证遍历map元素时，可按照添加的顺序实现遍历输出</span><br><span class="line">        				原因：在原有的HashMap底层结构基础上，添加了一对引用分别记录当前HashMap节点的前一个和后一个元素</span><br><span class="line">        				对于频繁的遍历操作，此类的执行效率高于HashMap</span><br><span class="line">	/----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历；按照key排序（考虑key的自然排序和定制排序），底层使用红黑树</span><br><span class="line">	/----Hashtable:作为Map的古老实现类，线程安全，效率低；不可存储<span class="keyword">null</span>的key和value</span><br><span class="line">		/----Properties:常用来处理配置文件；特点：key和value都是String类型</span><br><span class="line">先出现的Hashtble，后出现Map接口来规范键值对的规则，并使用HashMap作为其主要实现类，TreeMap针对有顺序的Map，由于HashMap的插删数据不方便，因此出现了LinkedHashMap</span><br></pre></td></tr></table></figure>
<h3 id="二map结构的理解">(二)、Map结构的理解</h3>
<p>Map中的key：无序的、不可重复的，使用Set存储所有的key ----&gt; key所在的类要重写equals()和hashCode()（以HashMap为例）</p>
<p>Map中的value：无序的、可重复的，使用Collection存储所有的value ----&gt; key所在的类要重写equals()（以HashMap为例）</p>
<p>一个键值对：key-value构成一个Entry对象</p>
<p>Map中的entry：无序的、不可重复的，使用Set存储所有的entry</p>
<h3 id="三hashmap的底层实现原理jdk7为例">(三)、HashMap的底层实现原理（JDK7为例）</h3>
<ol type="1">
<li><p>实例化 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">// 在实例化后，底层创建了长度是16的一维数组Entry[] table。</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>添加数据 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">....<span class="comment">// 已经执行过0次或多次put方法</span></span><br><span class="line">map.put(key1, value1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先，调用key1所在类的hashCode方法，计算key1哈希值，此哈希值经过某种算法计算后，得到在Entry数组中的存放位置</span></span><br><span class="line"><span class="comment">// 如果此位置上数据为空，此时的(key1, value1)添加成功。 ----情况1</span></span><br><span class="line"><span class="comment">// 如果此位置上的数据不为空，（此位置上存在着一个或多个数据（以链表形式存在）），比较key1和已经存在的一个或多个数据的哈希值：</span></span><br><span class="line"><span class="comment">// 		如果key1的哈希值与已经存在的数据的哈希值都不相同，此时的key1-value1添加成功 ----情况2</span></span><br><span class="line"><span class="comment">// 		如果key1的哈希值与已经存在的某一个数据(key2-value2)的哈希值相同，则调用key1所在类的equals(key2)方法</span></span><br><span class="line"><span class="comment">// 			如果equals(key2)方法返回false，则key1-value1添加成功  ----情况3</span></span><br><span class="line"><span class="comment">// 			如果equals(key2)方法返回true，则value2被替换为value1（put具有修改功能）</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>情况2和情况3：新添加的数据和原来的数据以链表的方式存储，新添加数据在数组中(JDK7)，或新添加数据放在最后(JDK8)，同一位置多个元素以单向链表形式存储</p></li>
<li><p>不断添加过程中，会涉及扩容问题，当当前数组中的已存元素超过临界值（且当前key-value要存放的位置非空时）则扩容。默认的添加方式：数组扩容为原来的2倍，并将原来的数据重新计算哈希值Map到新数组中。</p></li>
</ol>
<h3 id="四jdk8相较于jdk7在底层实现方面的不同">(四)、JDK8相较于JDK7在底层实现方面的不同</h3>
<ol type="1">
<li><p>实例化 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">// 底层没有创建一个长度为16的数组。</span></span><br><span class="line"><span class="comment">// 底层的数组为Node[]，而不是Entry[]数组</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>首次调用put方法时，底层创建长度为16的数组</p></li>
<li><p>JDK7底层结构只有 数组+链表；JDK8底层结构有 数组+链表+红黑树</p>
<ul>
<li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所有数据改为使用红黑树存储（优化查找效率）</li>
</ul></li>
</ol>
<h3 id="五hashmap中的重要常量jdk8">(五)、HashMap中的重要常量（JDK8）</h3>
<blockquote>
<p><strong>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</strong> MAXIMUM_CAPACITY ： HashMap的最大支持容量，2^30 <strong>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子</strong></p>
<p><strong>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树</strong></p>
<p>UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表</p>
<p><strong>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。）</strong> table：存储元素的数组，总是2的n次幂 entrySet：存储具体元素的集 size：HashMap中存储的键值对的数量 modCount：HashMap扩容和结构改变的次数。 **threshold：扩容的临界值，=容量*填充因子** loadFactor：填充因子</p>
</blockquote>
<h3 id="六linkedhashmap的底层实现原理">(六)、LinkedHashMap的底层实现原理</h3>
<p>LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap。区别在于LinkedHashMap内部提供了Entry，替换HashMap中的Node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after; <span class="comment">// 记录添加元素的先后顺序</span></span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七map中定义的方法">(七)、Map中定义的方法</h3>
<p>添加、删除、修改操作</p>
<ol type="1">
<li><p>put <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">put</span><span class="params">(Object key, Object value)</span>: 将指定key-value添加到（或修改）当前map对象中</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>putAll <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map m)</span>: 将m中所有的key-value对添加到当前map中</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>remove <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(Object key)</span>: 移除指定key的key-value对，并返回value</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>clear <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>：清空当前map中的所有数据</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>元素查询的操作</p>
<ol type="1">
<li><p>get <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object key)</span>：获取指定key对应的value</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>containsKey <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span>：是否包含指定的key</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>containsValue <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span>：是否包含指定的value</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>size <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>：返回map中key-value对的个数</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>isEmpty <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：判断当前map是否为空</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>equals <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：判断当前map和参数对象obj是否相等</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>元视图操作的方法</p>
<ol type="1">
<li><p>keySet <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Set <span class="title">keySet</span><span class="params">()</span>：返回所有key构成的Set集合</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>values <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Collection <span class="title">values</span><span class="params">()</span>：返回所有value构成的Collection集合</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>entrySet <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Set <span class="title">entrySet</span><span class="params">()</span>：返回所有key-value对构成的Set集合</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>总结：常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">添加：<span class="function">Object <span class="title">put</span><span class="params">(Object key, Object value)</span></span></span><br><span class="line"><span class="function">删除：Object <span class="title">remove</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">修改：Object <span class="title">put</span><span class="params">(Object key, Object value)</span></span></span><br><span class="line"><span class="function">查询：Object <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">长度：<span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">遍历：Set <span class="title">keySet</span><span class="params">()</span> / Collection <span class="title">values</span><span class="params">()</span> / Set <span class="title">entrySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br></pre></td></tr></table></figure>
<h3 id="八treemap">(八)、TreeMap</h3>
<p>向TreeMap中添加key-value，要求key必须是由用一个类创建的对象。因为要按照key进行排序：自然排序、定制排序</p>
<h3 id="九properties">(九)、Properties</h3>
<ol type="1">
<li>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</li>
<li>在程序中加载配置文件使用Properties对象的load(InputStream instream)方法</li>
<li>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key和 value 都是字符串类型</li>
<li>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法</li>
</ol>
<p>IDEA下的配置文件：</p>
<ul>
<li>一般在当前工程文件夹下</li>
<li>新建配置文件：右键工程名 -- New -- File 或者 Resource Bundle，扩展名为.properties</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置文件 jdbc.properties</span></span><br><span class="line">name=Tom</span><br><span class="line">password=<span class="number">123456</span></span><br></pre></td></tr></table></figure>
<ul>
<li>java代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProperties</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;../jdbc.properties&quot;</span>);</span><br><span class="line">    properties.load(fis); <span class="comment">// 加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">    String name = properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    <span class="comment">// name = Tom, password = 123456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七collections工具类">七、Collections工具类</h2>
<ul>
<li>Collections 是一个<strong>操作 Collection 和 Map 等集合</strong>的工具类（操作数组的工具类：Arrays）</li>
<li>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</li>
</ul>
<p>排序操作：（均为static方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reverse(List)：反转 List 中元素的顺序</span><br><span class="line">shuffle(List)：对 List 集合元素进行随机排序</span><br><span class="line">sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span><br><span class="line">sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line">swap(List，<span class="keyword">int</span>， <span class="keyword">int</span>)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br></pre></td></tr></table></figure>
<p>查找、替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection)</span>：根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line"><span class="function">Object <span class="title">max</span><span class="params">(Collection，Comparator)</span>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection)</span></span></span><br><span class="line"><span class="function">Object <span class="title">min</span><span class="params">(Collection，Comparator)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection，Object)</span>：返回指定集合中指定元素的出现次数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span>：将src中的内容复制到dest中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list，Object oldVal，Object newVal)</span>：使用新值替换List 对象的所有旧值</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Copy()方法：要求dest的size要大于list的size，否则抛异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCollections</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        // java.lang.IndexOutOfBoundsException: Source does not fit in dest</span></span><br><span class="line">    <span class="comment">//        List dest = new ArrayList();</span></span><br><span class="line">    <span class="comment">//        Collections.copy(dest, list);</span></span><br><span class="line">    List dest = Arrays.asList(<span class="keyword">new</span> Object[list.size()]);</span><br><span class="line">    Collections.copy(dest, list);</span><br><span class="line"></span><br><span class="line">    System.out.println(dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>同步控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2021/12/31/Coding/Java/11Java%E9%9B%86%E5%90%88/79%20Day%20-%2002.png" alt="synchronized"><figcaption aria-hidden="true">synchronized</figcaption>
</figure>
<h2 id="面试题">面试题</h2>
<ol type="1">
<li><p>ArrayList、LinkedList、Vector三者异同</p>
<ul>
<li>同：三个类都实现了List接口，存储数据的特点相同：存储有序、可重复的数据</li>
<li>异：
<ul>
<li>ArrayList：
<ul>
<li>作为List接口的主要实现类</li>
<li>线程不安全，因此效率高</li>
<li>底层使用Object[] elementData存储</li>
</ul></li>
<li>LinkedList：
<ul>
<li>对于频繁的插入、删除操作，使用此类效率比ArrayList高</li>
<li>底层使用双向链表</li>
</ul></li>
<li>Vector：
<ul>
<li>作为List接口的古老实现类。【JDK1.0时即存储有序、可重复的数据，JDK1.2后出现的List接口，且紧接着出现了两个实现类ArrayList、LinkedList，后把Vector归入List接口的实现类】</li>
<li>线程安全，效率低</li>
<li>底层使用Object[] elementData存储</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>区分List中的remove(int index)和remove(Object obj)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListRemove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    updateList(list);</span><br><span class="line">    System.out.printl(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">    list.remove(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>HashMap的底层实现原理？</p></li>
<li><p>HashMap和Hashtable的异同？</p></li>
<li><p>CurrentHashMap和Hashtable的异同？</p></li>
<li><p>Collection和Collections的区别？</p></li>
<li><p>负载因子值的大小，对HashMap有什么影响</p>
<blockquote>
<ul>
<li>负载因子的大小决定了HashMap的数据密度。</li>
<li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。</li>
<li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</li>
<li>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。</li>
</ul>
</blockquote></li>
</ol>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li><p>说说你所理解的集合框架都有哪些接口，存储数据的特点是什么？</p>
<ul>
<li>Collection：单列集合，用于存储一个一个的对象
<ul>
<li>List：有序的、可重复的集合</li>
<li>Set：无序的、不可重复的集合</li>
</ul></li>
<li>Map：双列数据，保存具有映射关系“key-value对”的集合</li>
</ul></li>
<li><p>比较throw和throws的异同</p>
<ul>
<li>throw：生成一个异常对象并抛出（手动抛出异常），使用在方法内部；和自动抛出异常对应</li>
<li>throws：异常处理的一种方式。和try-catch-finally对象</li>
</ul></li>
<li><p>谈谈你对同步代码块中同步监视器和共享数据的理解及各自要求</p>
<p>同步监视器：俗称锁，任何一个类的对象都可充当锁。多个线程共用一把锁</p>
<p>共享数据：多个线程共同操作的数据</p>
<p>需要使用同步机制将操作共享数据的代码包起来，既不能包多、也不能包少</p></li>
<li><p>集合Collection中存储的如果是自定义类的对象，需要自定义类重写哪个方法？为什么？‘</p>
<p>需要重写equals()方法，当集合对象调用contains方法时，会调用集合存储元素的equals()方法，如自定义类未重写equals()方法则默认使用Object类中的equals()方法即使用 == 符号判断</p>
<ul>
<li>List：重写equals()方法</li>
<li>Set：
<ul>
<li>HashSet、LinkedHashSet：重写equals()、hashCode()</li>
<li>TreeSet：Comparable接口( compareTo(Object o) )、Comparator接口( compare(Object o1, Object o2) )</li>
</ul></li>
</ul></li>
<li><p>ArrayList、LinkedList、Vector三者的相同点与不同点？【面试题】</p></li>
<li><p>List接口的常用方法有哪些？(增、删、改、查、插、长度、遍历)</p>
<ul>
<li>增：add(Object obj)</li>
<li>删：remove(int index) / remove(Object obj)</li>
<li>改：set(int index, Object ele)</li>
<li>查：get(int index)</li>
<li>插：add(int index, Object ele)</li>
<li>长度：size()</li>
<li>遍历：itertor()，for循环 或增强for循环</li>
</ul></li>
<li><p>如何使用Iterator和增强for循环遍历List</p></li>
<li><p>Set存储数据的特点是什么？常见的实现类有什么？说明彼此的特点</p>
<ul>
<li>特点：存储无序、不可重复数据</li>
<li>实现类：HashSet、LinkedHashSet、TreeSet
<ul>
<li>HashSet：底层使用HashMap</li>
<li>LinkedHashSet：底层使用LinkedHashMap</li>
<li>TreeSet：底层使用TreeMap</li>
</ul></li>
</ul></li>
<li><p>练习</p>
<ul>
<li><p>在List内去除重复数字值，要求尽量简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDuplicateList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">4</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    List list2 = duplicateList(list);</span><br><span class="line">    Iterator iterator = list2.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayList <span class="title">duplicateList</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    HashSet hashSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">    hashSet.addAll(list);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(hashSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// User类重写了HashCode和equals</span></span><br><span class="line">    HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    User u1 = <span class="keyword">new</span> User(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    User u2 = <span class="keyword">new</span> User(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set.add(u1);</span><br><span class="line">    set.add(u2);</span><br><span class="line">    u1.setName(<span class="string">&quot;CC&quot;</span>);<span class="comment">// 属性变动，Hash值也会变，但add后变化不会检查</span></span><br><span class="line">    set.remove(u1); <span class="comment">// remove需要先判断</span></span><br><span class="line">    System.out.println(set); <span class="comment">//u1 u2</span></span><br><span class="line">    <span class="comment">// [User&#123;name=&#x27;CC&#x27;, age=1001&#125;, User&#123;name=&#x27;BB&#x27;, age=1002&#125;]</span></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    <span class="comment">// [User&#123;name=&#x27;CC&#x27;, age=1001&#125;, User&#123;name=&#x27;CC&#x27;, age=1001&#125;, User&#123;name=&#x27;BB&#x27;, age=1002&#125;]</span></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    <span class="comment">// [User&#123;name=&#x27;CC&#x27;, age=1001&#125;, User&#123;name=&#x27;CC&#x27;, age=1001&#125;,</span></span><br><span class="line">    <span class="comment">// User&#123;name=&#x27;AA&#x27;, age=1001&#125;, User&#123;name=&#x27;BB&#x27;, age=1002&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Map存储数据的特点？并指明key、value、entry存储数据的特点</p>
<ul>
<li>双列数据，存储key-value对数据</li>
<li>key：无序的、不可重复的。相当于使用Set存储</li>
<li>value：无序的、可重复的。相当于使用Collection存储</li>
<li>entry：无序的、不可重复的。相当于使用Set存储</li>
</ul></li>
<li><p>描述HashMap的底层实现原理（JDK8）</p></li>
<li><p>Map中常用实现类有哪些？各自有什么特点？</p>
<blockquote>
<p>/----Map：双列数据，保存具有映射关系“key-value对”的集合 ---&gt; 数学上的“函数”：y = f(x) 【value = f(key)】 /----HashMap:作为Map的主要实现类，线程不安全，效率高；可存储null的key和value，健壮性好。底层使用 数组+链表(JDK7)、数组+链表+红黑树(JDK8) /----LinkedHashMap：保证遍历map元素时，可按照添加的顺序实现遍历输出 原因：在原有的HashMap底层结构基础上，添加了一对引用分别记录当前HashMap节点的前一个和后一个元素 对于频繁的遍历操作，此类的执行效率高于HashMap /----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历；按照key排序（考虑key的自然排序和定制排序），底层使用红黑树 /----Hashtable:作为Map的古老实现类，线程安全，效率低；不可存储null的key和value /----Properties:常用来处理配置文件；特点：key和value都是String类型</p>
</blockquote></li>
<li><p>如何遍历Map中的key-value对，代码实现</p></li>
<li><p>Map中的常用方法</p></li>
<li><p>Collection和Collections的区别</p></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章 枚举类与注解</title>
    <url>/2021/12/25/Coding/Java/10%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="第10章枚举类与注解">第10章、枚举类与注解</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、枚举类的使用</li>
<li>二、注解的使用</li>
<li>每日一考</li>
</ol>
<span id="more"></span>
<h2 id="一枚举类的使用">一、枚举类的使用</h2>
<h3 id="一如何自定义枚举类">（一）、如何自定义枚举类</h3>
<ol type="1">
<li><p>枚举类的理解</p>
<ul>
<li>类的<strong>对象只有有限个，确定的</strong>。举例如下：星期类、性别类、季节类、支付方式（现金、微信、支付宝）</li>
<li>当需要定义<strong>一组</strong>常量时，强烈建议使用枚举类</li>
<li>如果枚举类中只有一个对象，可以看成单例模式的实现方式</li>
</ul></li>
<li><p>如何定义枚举类</p>
<ul>
<li><p>JDK5.0前，自定义枚举类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要有有限个、确定的对象 ==&gt; 私有化类的构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season season = Season.SPRING;</span><br><span class="line">        System.out.println(season);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">// 声明对象属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化类的构造器，并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供当前枚举类的多个对象: public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>私有化构造器</li>
<li>私有化属性，且属性声明为final</li>
<li>类的内部创建固定数量的当前类的对象</li>
<li>提供属性的get方法</li>
<li>重写toString方法</li>
</ul></li>
</ul></li>
</ol>
<h3 id="二如何使用关键字enum定义枚举类重点">（二）、如何使用关键字enum定义枚举类（重点）</h3>
<p>JDK5.0后，可使用enum关键字定义枚举类</p>
<ul>
<li>定义的枚举类继承于 java.lang.Enum类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season season = Season.SPRING;</span><br><span class="line">        System.out.println(season); <span class="comment">// SPRING</span></span><br><span class="line">        System.out.println(season.getClass().getSuperclass()); </span><br><span class="line">        <span class="comment">//class java.lang.Enum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用enum关键字</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 提供当前枚举类的对象，多个对象之间用逗号隔开，末尾对象用分号结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明对象属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化类的构造器，并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toString()方法无需重写，输出为对象名</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public String toString() &#123;</span></span><br><span class="line"><span class="comment">//        return &quot;Season&#123;&quot; +</span></span><br><span class="line"><span class="comment">//                &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">//                &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">//                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三enum类的主要方法重点">（三）、Enum类的主要方法（重点）</h3>
<ul>
<li>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</li>
<li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</li>
<li>toString()：返回当前枚举类对象常量的名称</li>
</ul>
<h3 id="四实现接口的枚举类">（四）、实现接口的枚举类</h3>
<ul>
<li><p>和普通 Java 类一样，枚举类可以实现一个或多个接口</p></li>
<li><p>情况一：实现接口，在类中实现方法；</p>
<p>即若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</p></li>
<li><p>情况二：</p>
<p>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式,则可以让每个枚举值分别来实现该方法</p>
<ul>
<li>通过实现接口，并在枚举类的每个对象后分别实现接口中的方法</li>
<li>每个枚举成员调用show方法时会按各自实现方法中定义的操作进行操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season season = Season.SPRING;</span><br><span class="line">        System.out.println(season);</span><br><span class="line">        System.out.println(season.getClass().getSuperclass());</span><br><span class="line">        season.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用enum关键字</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> <span class="keyword">implements</span> <span class="title">info</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 提供当前枚举类的对象，多个对象之间用逗号隔开，末尾对象用分号结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明对象属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化类的构造器，并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toString()方法无需重写，输出为对象名</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public String toString() &#123;</span></span><br><span class="line"><span class="comment">//        return &quot;Season&#123;&quot; +</span></span><br><span class="line"><span class="comment">//                &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">//                &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">//                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二注解的使用">二、注解的使用</h2>
<h3 id="一注解annotation概述">（一）、注解（Annotation）概述</h3>
<ol type="1">
<li>从<strong>JDK 5.0 开始</strong>, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)</li>
<li>Annotation 其实就是代码里的<strong><em>特殊标记</em></strong>, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</li>
<li>Annotation 可以像修饰符一样被使用, 可用于<strong>修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明,</strong> 这些信息被保存在Annotation的 “name=value” 对中。</li>
<li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</li>
<li>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：<strong>框架 = 注解 + 反射 + 设计模式。</strong></li>
</ol>
<h3 id="二常见的annotation示例">（二）、常见的Annotation示例</h3>
<p>使用Annotation 时要在其前面增加 @ 符号, 并把该Annotation 当成一个修饰符使用。用于修饰它支持的程序元素</p>
<ol type="1">
<li><p>示例一：生成文档相关的注解</p>
<ul>
<li><span class="citation" data-cites="author">@author</span> 标明开发该类模块的作者，多个作者之间使用,分割</li>
<li><span class="citation" data-cites="version">@version</span> 标明该类模块的版本</li>
<li><span class="citation" data-cites="see">@see</span> 参考转向，也就是相关主题</li>
<li><span class="citation" data-cites="since">@since</span> 从哪个版本开始增加的</li>
<li><span class="citation" data-cites="param">@param</span> 对方法中某参数的说明，如果没有参数就不能写</li>
<li><span class="citation" data-cites="return">@return</span> 对方法返回值的说明，如果方法的返回值类型是void就不能写</li>
<li><span class="citation" data-cites="exception">@exception</span> 对方法可能抛出的异常进行说明，如果方法没有用throws显式抛出的异常就不能写其中</li>
</ul>
<p><span class="citation" data-cites="param">@param</span> <span class="citation" data-cites="return">@return</span> 和@exception 这三个标记都是只用于方法的。 <span class="citation" data-cites="param的格式要求">@param的格式要求</span>：<span class="citation" data-cites="param">@param</span> 形参名形参类型 形参说明 <span class="citation" data-cites="return">@return</span> 的格式要求：<span class="citation" data-cites="return">@return</span> 返回值类型返回值说明 <span class="citation" data-cites="exception的格式要求">@exception的格式要求</span>：<span class="citation" data-cites="exception">@exception</span> 异常类型异常说明 <span class="citation" data-cites="param和">@param和</span><span class="citation" data-cites="exception可以并列多个">@exception可以并列多个</span></p></li>
<li><p>示例二：<strong>在编译时进行格式检查</strong>(JDK内置的三个基本注解)</p>
<ul>
<li><p><span class="citation" data-cites="Override">@Override</span>: 限定重写父类方法, 该注解只能用于方法</p></li>
<li><p><span class="citation" data-cites="Deprecated">@Deprecated</span>: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</p></li>
<li><p><span class="citation" data-cites="SuppressWarnings">@SuppressWarnings</span>: 抑制编译器警告</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 抑制未使用警告</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123; &quot;unused&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">// 抑制未使用变量 未使用泛型</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>示例三：跟踪代码依赖性，实现替代配置文件功能</p>
<ul>
<li>Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署</li>
<li>spring框架中关于“事务”的管理</li>
</ul></li>
</ol>
<h3 id="三自定义annotation">（三）、自定义Annotation</h3>
<ol type="1">
<li>如何自定义注解
<ul>
<li>参照SuppressWarnings的定义</li>
<li>注解声明为 <span class="citation" data-cites="interface">@interface</span></li>
<li>内部定义成员，通常使用value表示</li>
<li>可指定成员的默认值，使用default定义</li>
<li>如果自定义注解无成员，表明是一个标识作用。称为标记</li>
<li>如果注解有成员，在使用注解时，需要指明成员的值</li>
<li>自定义注解必须配上注解的信息处理流程（使用反射）才有意义</li>
</ul></li>
</ol>
<ul>
<li>自定义注解通常都会指明两个元注解：Retention、Target</li>
</ul>
<ol start="2" type="1">
<li>PPT</li>
</ol>
<ul>
<li>自定义注解自动继承了<strong>java.lang.annotation.Annotation</strong>接口</li>
<li>Annotation 的<strong>成员变量</strong>在 Annotation 定义中<strong>以无参数方法的形式来声明</strong>。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。</li>
<li>可以在定义 Annotation 的成员变量时为其<strong>指定初始值</strong>, 指定成员变量的初始值可使用<strong>default 关键字</strong></li>
<li>如果只有一个参数成员，建议使用<strong>参数名为value</strong></li>
<li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”</li>
<li>没有成员定义的 Annotation 称为<strong>标记</strong>; 包含成员变量的 Annotation 称为元数据Annotation</li>
<li>注意：自定义注解必须配上注解的信息处理流程才有意义。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    String[] value(); <span class="comment">// 看起来像方法，其实是成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定成员的默认值</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>; <span class="comment">// 看起来像方法，其实是成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;hi&quot;, xxx = xxxx)</span></span><br></pre></td></tr></table></figure>
<h3 id="四jdk中的元注解">（四）、JDK中的元注解</h3>
<ol type="1">
<li><p>元注解：对现有的注解解释说明的注解</p></li>
<li><p>JDK 的元Annotation 用于修饰其他Annotation 定义</p></li>
<li><p>JDK5.0提供了4个标准的meta-annotation类型，分别是：</p>
<ul>
<li><strong>Retention</strong>：指定所修饰的Annotation的生命周期，包含SOURCE(默认行为)。只有声明为RUNTIME生命周期的注解才能通过反射获取。</li>
<li><strong>Target</strong>：用于指定被修饰的Annotation能用于修饰那些程序元素（类、构造器、方法、...）</li>
<li>Documented（出现频率低）：表示被Documented所修饰的注解若在程序元素上用到，则在被javadoc解析时保留下来该注解</li>
<li>Inherited：被它修饰的Annotation具有继承性（若该Annotation修饰父类，则子类不用显式注解仍然有父类的注解信息）</li>
</ul></li>
<li><p>元注解类比：元数据 String name = "Tom"; 其中"Tom"是最核心的，而String 和 name都是来解释说明修饰"Tom"数据的，即String 和 name可看成是"Tom"的元数据</p></li>
</ol>
<h3 id="五利用反射获取注解信息">（五）、利用反射获取注解信息</h3>
<ol type="1">
<li>前提：
<ul>
<li>要求此注解的元注解Retention中声明的生命周期状态为：RUNTIME</li>
</ul></li>
</ol>
<h3 id="六jdk8中注解的新特性可重复注解类型注解">（六）、JDK8中注解的新特性（可重复注解、类型注解）</h3>
<ol type="1">
<li><p>可重复注解</p>
<ul>
<li><p>在MyAnnotation上声明@repeatable()，成员值为MyAnnotations.class</p></li>
<li><p>MyAnnotation的@Target和<span class="citation" data-cites="Retention等元注解和MyAnnotaions相同">@Retention等元注解和MyAnnotaions相同</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyAnnotationTest.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK 8前重复注解写法</span></span><br><span class="line"><span class="comment">//@MyAnnotations(&#123;@MyAnnotation(value = &quot;Hi - 1&quot;), @MyAnnotation(value = &quot;Hi - 2&quot;)&#125;)</span></span><br><span class="line"><span class="comment">//JDK 8后重复注解写法</span></span><br><span class="line"><span class="comment">//  - 在MyAnnotation上声明@repeatable()，成员值为MyAnnotations.class</span></span><br><span class="line"><span class="comment">//  - MyAnnotation的@Target和@Retention和MyAnnotaions相同</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;Hi - 1&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;Hi - 2&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyAnnotation.java</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.CONSTRUCTOR&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyAnnotations.java</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.CONSTRUCTOR&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>类型注解</p>
<ul>
<li><p>ElementType.TYPE_PARAMETER：表示该注解能写在类型变量声明语句中（如泛型声明）</p></li>
<li><p>ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中</p></li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyAnnotationTest.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;@<span class="title">MyAnnotation</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">throws</span> @MyAnnotation RuntimeException</span>&#123;</span><br><span class="line">        ArrayList&lt;<span class="meta">@MyAnnotation</span> String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = (<span class="meta">@MyAnnotation</span> <span class="keyword">int</span>) <span class="number">10L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyAnnotation.java</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyAnnotation.java</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li><p>什么是枚举类？枚举类的对象声明的修饰符都有哪些？</p>
<ul>
<li><p>类的<strong>对象只有有限个，确定的</strong>。举例如下：星期类、性别类、季节类、支付方式（现金、微信、支付宝）</p></li>
<li><p>当需要定义<strong>一组</strong>常量时，强烈建议使用枚举类</p></li>
<li><p>如果枚举类中只有一个对象，可以看成单例模式的实现方式</p></li>
<li><div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">static</span> <span class="dt">final</span></span></code></pre></div></li>
</ul></li>
<li><p>什么是元注解？说说Retention和Target元注解的作用</p>
<ul>
<li>元注解是对现有的注解解释说明的注解</li>
<li><strong>Retention</strong>：指定所修饰的Annotation的生命周期，包含SOURCE(默认行为)。只有声明为RUNTIME生命周期的注解才能通过反射获取。</li>
<li><strong>Target</strong>：用于指定被修饰的Annotation能用于修饰那些程序元素（类、构造器、方法、...）</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第9章 java常用类</title>
    <url>/2021/12/20/Coding/Java/09Java%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="第9章java常用类">第9章、java常用类</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、字符串相关类（String 类、StringBuffer、StringBuilder）【面试常考】</li>
<li>二、JDK 8 之前的日期时间 API（System 静态方法、Date 类，Calendar 类、SimpleDateFormat 类）</li>
<li>三、JDK 8 中新日期时间 API（LocalDate、LocalTime、LocalDateTime、Instant、DateTimeFormatter、其他类）</li>
<li>四、Java 比较器（Comparable 接口、Comparator 接口）(重点)</li>
<li>五、System 类</li>
<li>六、Math 类</li>
<li>七、BigInteger 与 BigDecimal</li>
<li>面试</li>
<li>每日一考</li>
</ol>
<span id="more"></span>
<h2 id="一字符串相关类string类stringbufferstringbuilder面试常考">一、字符串相关类（String类、StringBuffer、StringBuilder）【面试常考】</h2>
<h3 id="string字符串使用一对引起来表示">String：字符串，使用一对“”引起来表示</h3>
<ol type="1">
<li>String是声明为final的，不可被继承</li>
<li>String类实现了Serializable接口：表示字符串是支持序列化的（可通过网络传输IO流）</li>
<li>String类实现了Comparable接口：表示String对象可比较大小</li>
<li>String类内部定义了<strong>final</strong> char[] value用于存储字符串数据（不可更改数组大小、内容）</li>
<li>String：代表不可变的字符序列，<strong>不可变 性</strong>
<ul>
<li><strong>不可变性体现1</strong>：当对字符串重新赋值时，需要重新指定内存区域赋值，不能使用原有的value赋值（在常量池中重新分配内存区域并将地址赋给引用）</li>
<li><strong>不可变性体现2</strong>：对现有字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value赋值</li>
<li><strong>不可变性体现3</strong>：当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value赋值</li>
</ul></li>
</ol>
<h4 id="string对象的内存结构">String对象的内存结构</h4>
<ol type="1">
<li>String实例化方式：
<ul>
<li>通过字面量定义的方式：此时的字符串引用的数据声明在方法区中的字符串常量池中
<ul>
<li>不用new的赋值，为<strong>字面量的定义方式</strong>。String str = "str";</li>
<li>通过字面量的方式给字符串赋值，此时的字符串值声明在字符串常量池中。</li>
<li>字符串常量池中不会存储相同内容的字符串（相同的字符串内容的引用都指向同一地址）</li>
</ul></li>
<li>通过new+构造器的方式：此时字符串引用保存的地址值时数据在堆空间中开辟空间后对应的地址值。但堆空间中的char[]数组所指向的地址仍指向字符串常量池，且若在常量池中已经存在传入构造器的字符串内容时，char[]数组指向的地址也是该常量池已存在的字符串地址</li>
</ul></li>
</ol>
<figure>
<img src="/2021/12/20/Coding/Java/09Java%E5%B8%B8%E7%94%A8%E7%B1%BB/70%20Day%20-%2002.png" alt="new 构造器"><figcaption aria-hidden="true">new 构造器</figcaption>
</figure>
<ol start="2" type="1">
<li>结论（面笔试常考）
<ul>
<li><p>常量（字面量）与常量（字面量）的拼接结果在常量池。且常量池中不会存在相同内容的常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;strok&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String s = <span class="string">&quot;str&quot;</span>; <span class="comment">// 仍然是常量</span></span><br><span class="line">String s1 = s + <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">sysout(s1 == str) <span class="comment">// true，加了final就是常量，常量和常量拼接仍在常量池</span></span><br></pre></td></tr></table></figure></li>
<li><p>只要其中有一个是变量，结果就在堆中</p></li>
<li><p>如果字符串拼接的结果调用intern()方法，返回值就在常量池中</p></li>
</ul></li>
</ol>
<p>面试题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String str = <span class="keyword">new</span> String(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span>[] ch)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;change, str == this.str: &quot;</span> + str == <span class="keyword">this</span>.str); </span><br><span class="line">        <span class="comment">// true：说明传入的是地址</span></span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line"><span class="comment">//        str = new String(&quot;test ok&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;change, str == this.str: &quot;</span> + str == <span class="keyword">this</span>.str);</span><br><span class="line">        <span class="comment">// false：说明函数内的str丢掉了类中的str属性地址，</span></span><br><span class="line">        <span class="comment">// 而字面量和new等都给str引用重新赋了新的地址值</span></span><br><span class="line">        </span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;change: &quot;</span> + <span class="keyword">this</span>.str);</span><br><span class="line">        System.out.println(<span class="string">&quot;change: &quot;</span> + <span class="keyword">this</span>.ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringTest stringTest = <span class="keyword">new</span> StringTest();</span><br><span class="line">        stringTest.change(stringTest.str, stringTest.ch);</span><br><span class="line">        System.out.println(<span class="string">&quot;main: &quot;</span> + stringTest.str);</span><br><span class="line">        System.out.println(<span class="string">&quot;main: &quot;</span> + stringTest.ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法的值传递机制中，当实参和形参都是引用类型变量时，传递的值确实是地址值，因为实参是栈中保存的值即对象在堆中的地址值，但需要澄清的一点是：方法中形参拿到该值后可以通过该值找到对象并修改对象中的属性值（类似数组传递后可更改数组中存储的值），但是方法内的形参不会影响实参的值，也就是说形参的值改变（意味着形参存储的地址值改变）时，实参仍是指向原来的地址的。</p>
<p>上面代码中的change方法中，对形参str又重新赋值，即形参改的是地址值，并没有改变实参所指向地址堆空间中的属性值。就像传入数组地址一样，你在方法内通过形参去索引数组的某个元素并修改他是可以影响到外面的，因为外面的数组指向的也是这个堆空间，但是这种方式并没有影响实参数组的指向地址，当你在方法内把形参数组重新赋值时改的也只是形参指向的地址，并不会改变实参指向的地址。</p>
<p>总结：实参只是传递给形参一个值的副本或值的copy，无论如何，形参的操作无法影响实参的存储数据（是栈中保存的数据，而不是堆中的数据，只要知道存储在堆中对象的地址就能通过调用修改对象中的属性）</p>
<p>【初级参数传递见 第四章 - 六、再谈方法】</p>
<h4 id="string常用方法">String常用方法</h4>
<ol type="1">
<li>常用方法1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>：返回字符串的长度： return value.length</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>： 返回某索引处的字符return value[index]</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：判断是否是空字符串：return value.length </span>== <span class="number">0</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为小写</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为大写</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span>：返回字符串的副本，忽略前导空白和尾部空白</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写</span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串的大小</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到<span class="title">endIndex</span><span class="params">(不包含)</span>的一个子字符串。</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>常用方法2</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="keyword">char</span> 值序列时，返回 <span class="keyword">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>常用方法3</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span>：返回一个新的字符串，它是通过用newChar 替换此字符串中出现的所有oldChar 得到的。</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> ： 使用 给 定 的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> ：使用给定的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。</span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex)</span>：根据给定正则表达式的匹配拆分此字符串。</span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中</span></span><br></pre></td></tr></table></figure>
<h4 id="string和基本数据类型转换">String和基本数据类型转换</h4>
<ol type="1">
<li><p>String --&gt; 基本数据类型、包装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包装类.parseXxx(str);</span><br></pre></td></tr></table></figure></li>
<li><p>基本数据类型、包装类 --&gt; String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf(xxx);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="string与字符数组转换">String与字符数组转换</h4>
<ol type="1">
<li><p>String --&gt; char[]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String对象.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供了将指定索引范围内的字符串存放到数组中的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span>[] dst,<span class="keyword">int</span> dstBegin)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>char[] --&gt; String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String 类的构造器：</span></span><br><span class="line">String(<span class="keyword">char</span>[]);</span><br><span class="line">String(<span class="keyword">char</span>[]，<span class="keyword">int</span> offset，<span class="keyword">int</span> length); </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="string与字节数组转换">String与字节数组转换</h4>
<ol type="1">
<li><p>String --&gt; byte[]：编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = String对象.getBytes(); <span class="comment">// 使用默认字符集进行转换</span></span><br><span class="line">sysout(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName) </span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = String对象.getBytes(<span class="string">&quot;gbk&quot;</span>); <span class="comment">// 使用gbk字符集进行编码</span></span><br><span class="line">sysout(Arrays.toString(bytes));</span><br></pre></td></tr></table></figure></li>
<li><p>byte[] --&gt; String：解码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。</span></span><br><span class="line">String(<span class="keyword">byte</span>[]); <span class="comment">// 使用默认字符集进行解码</span></span><br><span class="line">String(<span class="keyword">byte</span>[], <span class="string">&quot;gbk&quot;</span>); <span class="comment">// 使用gbk字符集进行解码</span></span><br><span class="line"><span class="comment">// 解码时要求解码使用的字符集必须与编码时使用的字符集一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象</span></span><br><span class="line">String(<span class="keyword">byte</span>[]，<span class="keyword">int</span> offset，<span class="keyword">int</span> length) </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="string常见算法">String常见算法</h4>
<ol type="1">
<li><p>模拟一个trim方法，去除字符串两端的空格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrimAlike</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot; 1 &quot;</span>;</span><br><span class="line">        String str1 = str.trim();</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">        String str2 = Trim(str);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Trim</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start &lt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(ch, start + <span class="number">1</span>, end - start - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">5</span>;</span><br><span class="line">        String str1 = reverseString(str, start, end);</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">reverseString</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; start &lt; end &amp;&amp; str.length() - <span class="number">1</span> &gt; end &amp;&amp; start &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (end - start) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> tmp = chars[start + i];</span><br><span class="line">                chars[start + i] = chars[end - i];</span><br><span class="line">                chars[end - i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于数组的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">reverseString2</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; start &lt; end &amp;&amp; str.length() - <span class="number">1</span> &gt; end &amp;&amp; start &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = start, y = end; x &lt; y; x++, y--) &#123;</span><br><span class="line">                <span class="keyword">char</span> tmp = chars[x];</span><br><span class="line">                chars[x] = chars[y];</span><br><span class="line">                chars[y] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用String的拼接</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">reverseString3</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; start &lt; end &amp;&amp; str.length() - <span class="number">1</span> &gt; end &amp;&amp; start &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            String reverseStr = str.substring(<span class="number">0</span>, start);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">                reverseStr += str.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            reverseStr += str.substring(end + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> reverseStr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用StringBuffer | StringBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">reverseString4</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; start &lt; end &amp;&amp; str.length() - <span class="number">1</span> &gt; end &amp;&amp; start &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            stringBuilder.append(str, <span class="number">0</span>, start);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">                stringBuilder.append(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.append(str.substring(end + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> stringBuilder.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>获取一个字符串在另一个字符串中出现的次数。比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;abkkcadkabkebfkabkskab&quot;</span>;</span><br><span class="line">        System.out.println(countString(str1, str2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算str1在str2中出现次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countString</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str1.length() &gt; str2.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str1.length() == str2.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1.compareTo(str2) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str2.length();i++;)&#123;</span><br><span class="line">                i = str2.indexOf(str1, i);</span><br><span class="line">                System.out.println(<span class="string">&quot;index: &quot;</span> + i);</span><br><span class="line">                <span class="keyword">if</span>(i == -<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>获取两个字符串中最大相同子串。比如： str1 = "abcwerthelloyuiodef“;str2 = "cvhellobnm" 提示：将短的那个串进行长度依次递减的子串与较长的串比较。</p></li>
</ol>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abcwerdwadsawthelloooyuioddawdsef&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;cvhobnm&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String strShort, strLong;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str1.length() &gt; str2.length())&#123;</span><br><span class="line">            strShort = str2;</span><br><span class="line">            strLong = str1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            strShort = str1;</span><br><span class="line">            strLong = str2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str = longestString(strShort, <span class="keyword">null</span>, strLong, <span class="number">1</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strShort: 短字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strShortArray: 短字符串在当前choice下的各个字串组成的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strLong: 长字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> choice: 为了找到最长字串，用来标识短字符串长度需要减多少以获得多长的字串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">longestString</span><span class="params">(String strShort, String[] strShortArray, String strLong, <span class="keyword">int</span> choice)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断所有传入的strShortArray元素都是否是strLong的字串</span></span><br><span class="line">        <span class="keyword">if</span>(strShortArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String value : strShortArray) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strLong.contains(value)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如不是：进行下一个choice；</span></span><br><span class="line">        <span class="keyword">if</span>(++choice &gt; strShort.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个字符串数组，用来存储当前choice下的各个strShort字串</span></span><br><span class="line">        String[] strShortNew = <span class="keyword">new</span> String[choice];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; choice; i++)&#123;</span><br><span class="line">            strShortNew[i] = strShort.substring(i, i + strShort.length() - choice + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String s = longestString(strShort, strShortNew, strLong, choice);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 第二种方式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">longestString2</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str1 != <span class="keyword">null</span> &amp;&amp; str2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String strShort = (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line">            String strLong = (str1.length() &lt;= str2.length()) ? str2 : str1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strShort.length(); i++) &#123; <span class="comment">// 大循环</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y = strShort.length() - i; y &lt;= strShort.length(); x++, y++) &#123; <span class="comment">// 内循环：两个指针分别用来取中间的字串</span></span><br><span class="line">                    String subStr = strShort.substring(x, y);</span><br><span class="line">                    <span class="keyword">if</span> (strLong.contains(subStr)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> subStr;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="5" type="1">
<li>对字符串中字符进行自然顺序排序。 提示：</li>
</ol>
<p>1）字符串变成字符数组。 2）对数组排序，选择，冒泡，Arrays.sort(); 3）将排序后的数组变成字符串。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;abcwerthelloyuiodef&quot;</span>;</span><br><span class="line">        String strSorted = stringSort(str);</span><br><span class="line">        System.out.println(strSorted);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">stringSort</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">            Arrays.sort(ch);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="stringbuffer类-stringbuilder类以stringbuffer为例">StringBuffer类 &amp; StringBuilder类（以StringBuffer为例）</h3>
<ol type="1">
<li><p>String、StringBuffer、StringBuilder三者异同（高频面试题）</p>
<ul>
<li>String：不可变的字符序列；底层使用final char[]存储</li>
<li>StringBuffer：可变的字符序列；线程安全，效率低；底层使用char[]存储</li>
<li>StringBuilder：可变的字符序列；JDK5.0新增，线程不安全，效率高；底层使用char[]存储</li>
</ul></li>
<li><p>底层实现</p>
<ul>
<li><p>String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(); <span class="comment">// char[] value = new char[0];</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">// char[] value = new char[]&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;</span></span><br></pre></td></tr></table></figure></li>
<li><p>StringBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(); <span class="comment">// char[] value = new char[16];</span></span><br><span class="line">sysout(sb1.length()) <span class="comment">// 0</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span>  StringBuffer(<span class="string">&quot;abc&quot;</span>); </span><br><span class="line">	<span class="comment">// char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br><span class="line">sysout(sb2.length())<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果要添加的数据底层数组盛不下了，则需要扩容底层数组。默认情况下扩容为原来容量的2倍+2，同时将原有数组中元素复制到新数组中</li>
<li>指导意义：开发中建议使用：StringBuffer(int capacity)构造器或StringBuilder(int capacity)指定底层数组长度以减少重新分配数组的内存空间；</li>
</ul></li>
</ul></li>
<li><p>StringBuffer类常用方法(StringBuilder含有相同的方法，只是方法线程不同步)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(xxx)</span>：提供了很多的<span class="title">append</span><span class="params">()</span>方法，用于进行字符串拼接</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>：删除指定位置的内容</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span>：把[start,end)位置替换为str StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, xxx)</span>：在指定位置插入xxx</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">reverse</span><span class="params">()</span> ：把当前字符序列逆转</span></span><br><span class="line"><span class="function">                                                       </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<ul>
<li>增：append(xxx)</li>
<li>删：delete(int start,int end)</li>
<li>改：setCharAt(int n ,char ch)；replace(int start, int end, String str)</li>
<li>查：charAt(int n )</li>
<li>插：insert(int offset, xxx)</li>
<li>长度：length()</li>
<li>遍历：for + charAt 或 toString方法</li>
</ul></li>
<li><p>效率比较：</p>
<ul>
<li>StringBuilder &gt; StringBuffer &gt; String</li>
</ul></li>
</ol>
<h2 id="二jdk-8之前的日期时间apisystem静态方法date类calendar类simpledateformat类">二、JDK 8之前的日期时间API（System静态方法、Date类，Calendar类、SimpleDateFormat类）</h2>
<h3 id="system静态方法">System静态方法</h3>
<ol type="1">
<li>System类提供的<strong>public static long currentTimeMillis()</strong>
<ul>
<li>用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</li>
<li>称为时间戳</li>
<li>可用来计算代码执行的时长</li>
</ul></li>
</ol>
<h3 id="java.util.date类">java.util.Date类</h3>
<p>java中的Date类有java.util.Date，java.sql.Date；java.util.Date为java.sql.Date父类</p>
<ol type="1">
<li><p>两个构造器的使用（java.util.Date）</p>
<ul>
<li><p>构造器一：创建一个对应当前时间的Date对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">sysout(date.toString());</span><br></pre></td></tr></table></figure></li>
<li><p>构造器二：创建指定毫秒数的Date对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">1555100545L</span>);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>两个方法的使用</p>
<ul>
<li>toString()：返回当前的年、月、日、时、分、秒字符串</li>
<li>getTime()：获取当前Date对象对应的毫秒数（时间戳）</li>
</ul></li>
<li><p>java.sql.Date对应着数据库中的日期类型的变量</p>
<ul>
<li><p>创建java.sql.Date对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.sql.Date date = <span class="keyword">new</span> java.sql.Date(<span class="number">1555555555L</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>将java.util.Date对象转化为java.sql.Date对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">java.sql.Date dateSql = <span class="keyword">new</span> java.sql.Date(date.getTime());</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h3 id="java.text.simpledateformat类">java.text.SimpleDateFormat类</h3>
<p>SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析</p>
<ol type="1">
<li><p>两个操作</p>
<ul>
<li><p>格式化：日期 --&gt; 字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造器</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">String format = sdf.format(date);</span><br><span class="line">System.out.println(format); <span class="comment">// 21-9-16 下午4:32</span></span><br></pre></td></tr></table></figure></li>
<li><p>解析：（格式化逆过程）字符串 --&gt; 日期</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析</span></span><br><span class="line">String str = <span class="string">&quot;21-9-16 下午4:23&quot;</span>;</span><br><span class="line">Date date1 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    date1 = sdf.parse(str);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(date1); <span class="comment">// Thu Sep 16 16:23:00 CST 2021</span></span><br></pre></td></tr></table></figure></li>
<li><p>指定方式格式化：调用带参构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//******指定方式格式化:调用带参构造器, 可参考API手册**************</span></span><br><span class="line"><span class="comment">//SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;);</span></span><br><span class="line"></span><br><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy.MM.dd HH:mm:ss&quot;</span>); </span><br><span class="line"><span class="comment">// HH: 24h制； hh: 12h制</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">String format1 = simpleDateFormat.format(date);</span><br><span class="line">System.out.println(format1); <span class="comment">// 2021.09.16 04:32:23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析: 要求字符串必须符合SimpleDateFormat识别的格式（通过构造器参数指定），否则会抛异常</span></span><br><span class="line">Date date2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    date2 = simpleDateFormat.parse(<span class="string">&quot;2021.09.16 04:32:23&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(date2); <span class="comment">// Thu Sep 16 04:32:23 CST 2021</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2021/12/20/Coding/Java/09Java%E5%B8%B8%E7%94%A8%E7%B1%BB/71%20Day%20-%2002.png" alt="日期或时间元素的字母表示"><figcaption aria-hidden="true">日期或时间元素的字母表示</figcaption>
</figure></li>
</ul></li>
<li><p>练习</p>
<ul>
<li><p>字符串“2020-09-08”转换为java.sql.Date</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;2020-09-08&quot;</span>;</span><br><span class="line">    SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    Date date = simpleDateFormat.parse(str);</span><br><span class="line">    java.sql.Date dateSql = <span class="keyword">new</span> java.sql.Date(date.getTime());</span><br><span class="line">    System.out.println(dateSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>"三天打鱼两天晒网"，如果该渔夫从1990-01-01开始按俗语执行，问到某年某月某日时该渔夫是在打鱼还是晒网</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总天数 mod 5：若为1、2、3则为打鱼；若为0、4则为晒网</span></span><br><span class="line"><span class="comment">// 总天数计算</span></span><br><span class="line"><span class="comment">// 		方式一：(date2.getTime() - date1.getTime()) / (1000 * 60 * 60 * 24) + 1</span></span><br><span class="line"><span class="comment">// 		方式二：计算整年天数 + 在某年内的天数</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h3 id="calendar类">Calendar类</h3>
<p>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</p>
<p>获取Calendar实例的方法</p>
<ul>
<li>使用Calendar.getInstance()方法</li>
<li>调用它的子类GregorianCalendar的构造器。</li>
</ul>
<ol type="1">
<li><p>使用方式</p>
<ul>
<li><p>实例化</p>
<ul>
<li><p>方式一（不常用）：调用它的子类GregorianCalendar的构造器。</p></li>
<li><p>方式二：使用Calendar.getInstance()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>常用方法</p>
<ul>
<li>get():</li>
<li>set()</li>
<li>add()</li>
<li>getTime()</li>
<li>setTime()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get()</span></span><br><span class="line">        <span class="keyword">int</span> daysInMonth = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        <span class="keyword">int</span> daysInYear = calendar.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">        System.out.println(<span class="string">&quot;today is &quot;</span> + daysInMonth + <span class="string">&quot;-th day in this month, &quot;</span></span><br><span class="line">                + daysInYear + <span class="string">&quot;-th day in this year&quot;</span>);</span><br><span class="line">        <span class="comment">// today is 16-th day in this month, 259-th day in this year</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// set()</span></span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH, <span class="number">22</span>);</span><br><span class="line">        daysInMonth = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        daysInYear = calendar.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">        System.out.println(<span class="string">&quot;today is &quot;</span> + daysInMonth + <span class="string">&quot;-th day in this month, &quot;</span></span><br><span class="line">                + daysInYear + <span class="string">&quot;-th day in this year&quot;</span>);</span><br><span class="line">        <span class="comment">// today is 22-th day in this month, 265-th day in this year</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// add()</span></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, <span class="number">5</span>);</span><br><span class="line">        daysInMonth = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        daysInYear = calendar.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">        System.out.println(<span class="string">&quot;today is &quot;</span> + daysInMonth + <span class="string">&quot;-th day in this month, &quot;</span></span><br><span class="line">                + daysInYear + <span class="string">&quot;-th day in this year&quot;</span>);</span><br><span class="line">        <span class="comment">// today is 27-th day in this month, 270-th day in this year</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// getTime()</span></span><br><span class="line">        Date date = calendar.getTime();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        <span class="comment">// Mon Sep 27 21:27:07 CST 2021</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// setTime()</span></span><br><span class="line">        Date dateSet = <span class="keyword">new</span> Date();</span><br><span class="line">        calendar.setTime(dateSet);</span><br><span class="line">        <span class="comment">// 获得的Month从0开始</span></span><br><span class="line">        System.out.println(calendar.get(Calendar.YEAR) + <span class="string">&quot;年&quot;</span></span><br><span class="line">                +  (calendar.get(Calendar.MONTH)+<span class="number">1</span>) + <span class="string">&quot;月&quot;</span></span><br><span class="line">                + calendar.get(Calendar.DATE) + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">        <span class="comment">// 2021年9月16日</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>注意点</p>
<ul>
<li>获取月份时：一月是0，二月是1，以此类推，12月是11</li>
<li>获取星期时：周日是1，周二是2 ， 。。。。周六是7</li>
</ul></li>
</ol>
<h2 id="三jdk-8中新日期时间apilocaldatelocaltimelocaldatetimeinstantdatetimeformatter其他类">三、JDK 8中新日期时间API（LocalDate、LocalTime、LocalDateTime、Instant、DateTimeFormatter、其他类）</h2>
<p>JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p>
<ul>
<li>可变性：像日期和时间这样的类应该是不可变的。</li>
<li>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</li>
<li>格式化：格式化只对Date有用，Calendar则不行。</li>
<li>此外，它们也不是线程安全的；不能处理闰秒等。</li>
</ul>
<p>总结：对日期和时间的操作一直是Java程序员最痛苦的地方之一。</p>
<h3 id="第三次引入api">第三次引入API</h3>
<p><strong>第三次引入的API</strong>是成功的，并且Java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。 Java 8 吸收了<strong>Joda-Time（开源jar）</strong>的精华，以一个新的开始为 Java 创建优秀的API。新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期API 大大简化了日期时间和本地化的管理。</p>
<h4 id="新日期api">新日期API</h4>
<ul>
<li><strong>java.time</strong> – 包含值对象的<strong>基础包</strong></li>
<li>java.time.chrono – 提供对不同的日历系统的访问</li>
<li><strong>java.time.format</strong> – 格式化和解析时间和日期</li>
<li><strong>java.time.temporal</strong> – 包括底层框架和扩展特性</li>
<li>java.time.zone – 包含时区支持的类</li>
</ul>
<p>大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。</p>
<h4 id="常用的类">常用的类：</h4>
<p><strong>LocalDate、LocalTime、LocalDateTime</strong> 类是其中较重要的几个类，它们的实例是<strong>不可变的对象</strong>，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p>
<ul>
<li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储 生日、纪念日等日期。</li>
<li>LocalTime表示一个时间，而不是日期。</li>
<li>LocalDateTime是用来表示日期和时间的，这是一个<strong>最常用的类之一</strong>。</li>
</ul>
<h4 id="新日期api的三个常用类的使用">新日期API的三个常用类的使用</h4>
<ol type="1">
<li><p>实例化</p>
<ul>
<li><p>now()<strong>静态</strong>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// now()</span></span><br><span class="line">LocalDate localDate = LocalDate.now(); <span class="comment">// 2021-09-16</span></span><br><span class="line">LocalTime localTime = LocalTime.now(); <span class="comment">// 21:56:48.358</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now(); </span><br><span class="line"><span class="comment">// 2021-09-16T21:56:48.358</span></span><br><span class="line"></span><br><span class="line">System.out.println(localDate);</span><br><span class="line">System.out.println(localTime);</span><br><span class="line">System.out.println(localDateTime);</span><br></pre></td></tr></table></figure></li>
<li><p>of()<strong>静态</strong>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// of()方法: 设置指定的年、月、日、时、分、秒，无偏移量</span></span><br><span class="line">LocalDate localDate1 = LocalDate.of(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">16</span>); <span class="comment">// 2021-10-16</span></span><br><span class="line">LocalTime localTime1 = LocalTime.of(<span class="number">15</span>, <span class="number">59</span>, <span class="number">50</span>, <span class="number">500000000</span>); <span class="comment">// 15:59:50.500</span></span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2021</span>, <span class="number">10</span>,</span><br><span class="line">                                                <span class="number">16</span>, <span class="number">15</span>, <span class="number">59</span>, <span class="number">50</span>, <span class="number">500000000</span>); </span><br><span class="line"><span class="comment">// 2021-10-16T15:59:50.500</span></span><br><span class="line"></span><br><span class="line">System.out.println(localDate1);</span><br><span class="line">System.out.println(localTime1);</span><br><span class="line">System.out.println(localDateTime1);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>相关方法</p>
<ul>
<li><p>get</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getDayOfMonth()/getDayOfYear() <span class="comment">// 获得月份天数(1-31) /获得年份天数(1-366)</span></span><br><span class="line">getDayOfWeek() <span class="comment">// 获得星期几(返回一个 DayOfWeek 枚举值)</span></span><br><span class="line">getMonth() <span class="comment">// 获得月份, 返回一个 Month 枚举值</span></span><br><span class="line">getMonthValue() / getYear() <span class="comment">// 获得月份(1-12) /获得年份</span></span><br><span class="line">getHour()/getMinute()/getSecond() <span class="comment">// 获得当前对象对应的小时、分钟、秒</span></span><br></pre></td></tr></table></figure></li>
<li><p>set: 体现不可变性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">withDayOfMonth()/withDayOfYear()/withMonth()/withYear()/withHour()/withXxx()</span><br><span class="line"><span class="comment">//将月份天数、年份天数、月份、年份、小时等修改为指定的值并返回新的对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>add</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</span><br><span class="line"><span class="comment">// 向当前对象添加几天、几周、几个月、几年、几小时</span></span><br></pre></td></tr></table></figure></li>
<li><p>minus</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</span><br><span class="line"><span class="comment">// 从当前对象减去几月、几周、几天、几年、几小时</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h4 id="瞬时instant类">瞬时：Instant类</h4>
<ul>
<li>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的<strong>事件时间戳</strong>。</li>
<li>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</li>
<li>java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</li>
<li>(1 ns = 10-9 s) 1秒 = 1000毫秒 =10<sup>6微秒=10</sup>9纳秒</li>
</ul>
<ol type="1">
<li><p>实例化</p>
<ul>
<li><p>now(): 获取本初子午线对应的标准时间 ( UTC )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// now()</span></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">System.out.println(instant); <span class="comment">// UTC: 2021-09-16T14:17:29.692Z</span></span><br></pre></td></tr></table></figure></li>
<li><p>atOffset(): 添加时间的偏移量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加时间的偏移量</span></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(offsetDateTime); <span class="comment">// 2021-09-16T22:17:29.692+08:00</span></span><br></pre></td></tr></table></figure></li>
<li><p>ofEpochMilli(long epochMilli): 通过给定毫秒数，获取Instant实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</span></span><br><span class="line">ofEpochMilli(<span class="keyword">long</span> epochMilli)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>方法</p>
<ul>
<li><p>toEpochMilli()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">toEpochMilli() <span class="comment">// 返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h4 id="格式化与解析日期或时间-java.time.format.datetimeformatter">格式化与解析日期或时间 java.time.format.DateTimeFormatter</h4>
<ol type="1">
<li><p>格式化方法</p>
<ul>
<li><p>预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter isoLocalDateTime = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">String str = isoLocalDateTime.format(LocalDateTime.now());</span><br><span class="line">System.out.println(str); <span class="comment">// 2021-09-16T22:31:23.101</span></span><br><span class="line">System.out.println(LocalDateTime.now());<span class="comment">// 2021-09-16T22:31:23.101</span></span><br></pre></td></tr></table></figure></li>
<li><p>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter isoLocalDateTime = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">String str = isoLocalDateTime.format(LocalDateTime.now());</span><br><span class="line">System.out.println(str); <span class="comment">// 2021年9月16日 下午10时31分23秒</span></span><br><span class="line">System.out.println(LocalDateTime.now()); <span class="comment">// 2021-09-16T22:31:23.101</span></span><br></pre></td></tr></table></figure></li>
<li><p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter isoLocalDateTime = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">String str = isoLocalDateTime.format(LocalDateTime.now());</span><br><span class="line">System.out.println(str); <span class="comment">// 2021-09-16 22:33:03</span></span><br><span class="line">System.out.println(LocalDateTime.now()); <span class="comment">// 2021-09-16T22:33:03.181</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>解析 parse</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter isoLocalDateTime = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">TemporalAccessor parse = isoLocalDateTime.parse(<span class="string">&quot;2021-09-16 23:20:20&quot;</span>);</span><br><span class="line">System.out.println(parse); <span class="comment">// &#123;&#125;,ISO resolved to 2021-09-16T23:20:20</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="其他api">其他API</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</span><br><span class="line">ZonedDateTime：一个在ISO-<span class="number">8601</span>日历系统时区的日期时间，如 <span class="number">2007</span>-<span class="number">12</span>-03T10:<span class="number">15</span>:<span class="number">30</span>+<span class="number">01</span>:<span class="number">00</span> Europe/Paris。</span><br><span class="line">				其中每个时区都对应着ID，地区ID都为“&#123;区域&#125;/&#123;城市&#125;”的格式，例如：Asia/Shanghai等</span><br><span class="line">Clock：使用时区提供对当前即时、日期和时间的访问的时钟。</span><br><span class="line">持续时间：Duration，用于计算两个“时间”间隔</span><br><span class="line">日期间隔：Period，用于计算两个“日期”间隔</span><br><span class="line">TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。</span><br><span class="line">TemporalAdjusters : 该类通过静态方法</span><br><span class="line">(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster 的实现。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ZoneId:类中包含了所有的时区信息</span></span><br><span class="line"><span class="comment">// ZoneId的getAvailableZoneIds():获取所有的ZoneId</span></span><br><span class="line">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line"><span class="keyword">for</span> (String s : zoneIds) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ZoneId的of():获取指定时区的时间</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>)); System.out.println(localDateTime);</span><br><span class="line"><span class="comment">//ZonedDateTime:带时区的日期时间</span></span><br><span class="line"><span class="comment">// ZonedDateTime的now():获取本时区的ZonedDateTime对象</span></span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.now();</span><br><span class="line">System.out.println(zonedDateTime);</span><br><span class="line"><span class="comment">// ZonedDateTime的now(ZoneId id):获取指定时区的ZonedDateTime对象ZonedDateTime zonedDateTime1 = ZonedDateTime.now(ZoneId.of(&quot;Asia/Tokyo&quot;)); System.out.println(zonedDateTime1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Duration:用于计算两个“时间”间隔，以秒和纳秒为基准</span></span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">LocalTime localTime1 = LocalTime.of(<span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">//between():静态方法，返回Duration对象，表示两个时间的间隔</span></span><br><span class="line">Duration duration = Duration.between(localTime1, localTime);</span><br><span class="line">System.out.println(duration);</span><br><span class="line">System.out.println(duration.getSeconds());</span><br><span class="line">System.out.println(duration.getNano());</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>); LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2017</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line">Duration duration1 = Duration.between(localDateTime1, localDateTime); System.out.println(duration1.toDays());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Period:用于计算两个“日期”间隔，以年、月、日衡量LocalDate localDate = LocalDate.now();</span></span><br><span class="line">LocalDate localDate1 = LocalDate.of(<span class="number">2028</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line">Period period = Period.between(localDate, localDate1); System.out.println(period);</span><br><span class="line">System.out.println(period.getYears());</span><br><span class="line">System.out.println(period.getMonths());</span><br><span class="line">System.out.println(period.getDays());</span><br><span class="line">Period period1 = period.withYears(<span class="number">2</span>);</span><br><span class="line">System.out.println(period1);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TemporalAdjuster:时间校正器</span></span><br><span class="line"><span class="comment">// 获取当前日期的下一个周日是哪天？</span></span><br><span class="line">TemporalAdjuster temporalAdjuster = TemporalAdjusters.next(DayOfWeek.SUNDAY); LocalDateTime localDateTime = LocalDateTime.now().with(temporalAdjuster); System.out.println(localDateTime);</span><br><span class="line"><span class="comment">// 获取下一个工作日是哪天？</span></span><br><span class="line">LocalDate localDate = LocalDate.now().with(<span class="keyword">new</span> TemporalAdjuster() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span> </span>&#123;</span><br><span class="line">        LocalDate date = (LocalDate) temporal;</span><br><span class="line">        <span class="keyword">if</span> (date.getDayOfWeek().equals(DayOfWeek.FRIDAY)) &#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (date.getDayOfWeek().equals(DayOfWeek.SATURDAY)) &#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> date.plusDays(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;下一个工作日是：&quot;</span> + localDate);</span><br></pre></td></tr></table></figure>
<h2 id="四java比较器comparable接口comparator接口重点">四、Java比较器（Comparable接口、Comparator接口）(重点)</h2>
<p>java中的对象正常情况下只能进行== 或 ！= ，不能使用 &gt; 或 &lt;。但在开发场景中，我们需要对多个对象进行排序， Java实现对象排序的方式有两种：</p>
<ol type="1">
<li><p>自然排序：java.lang.Comparable</p>
<ul>
<li>像String、包装类等实现了Comparable接口，重写了compareTo()方法，给出了比较两个对象大小的方式</li>
<li>像String、包装类重写compareTo()方法后，在通过Arrays.sort()或集合的排序方法调用时会对数组或集合中的元素进行<strong>从小到大的排序</strong></li>
<li>重写compareTo()的规则
<ul>
<li>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。</li>
<li>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，<strong>两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。</strong></li>
<li><strong>实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</strong></li>
<li>对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。</li>
</ul></li>
<li>如果自定义类的对象需要排序，应让自定义类实现Comparable接口，重写compareTo()方法</li>
</ul></li>
<li><p>定制排序：java.util.Comparator</p>
<ul>
<li><strong>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较。</strong></li>
<li><strong>重写compare(Object o1,Object o2)方法</strong>，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li>
<li>可以<strong>将 Comparator 传递给 sort 方法</strong>（如 Collections.sort 或Arrays.sort），从而允许在排序顺序上实现精确控制。</li>
<li>还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</li>
</ul></li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">5</span>];</span><br><span class="line">        goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovoMouse&quot;</span>, <span class="number">34</span>);</span><br><span class="line">        goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dellMouse&quot;</span>, <span class="number">43</span>);</span><br><span class="line">        goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomiMouse&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huaweiMouse&quot;</span>, <span class="number">65</span>);</span><br><span class="line">        goods[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;microsoftMouse&quot;</span>, <span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过Comparable接口中的compareTo()方法实现排序</span></span><br><span class="line">        Arrays.sort(goods);</span><br><span class="line">        System.out.println(Arrays.toString(goods));</span><br><span class="line">        <span class="comment">// [Goods&#123;name=&#x27;xiaomiMouse&#x27;, price=12.0&#125;, Goods&#123;name=&#x27;lenovoMouse&#x27;, price=34.0&#125;,</span></span><br><span class="line">        <span class="comment">// Goods&#123;name=&#x27;dellMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;microsoftMouse&#x27;, price=43.0&#125;,</span></span><br><span class="line">        <span class="comment">// Goods&#123;name=&#x27;huaweiMouse&#x27;, price=65.0&#125;]</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过Comparator接口的匿名类的匿名对象实现排序</span></span><br><span class="line">        Arrays.sort(goods, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                    <span class="comment">// &lt;时返回正整数，&gt;时返回负整数；调用sort方法时将为从大到小排序</span></span><br><span class="line">                    <span class="keyword">if</span>(((Goods) o1).price &lt; ((Goods) o2).price)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(((Goods) o1).price &gt; ((Goods) o2).price)&#123;</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(goods));</span><br><span class="line">        <span class="comment">//[Goods&#123;name=&#x27;huaweiMouse&#x27;, price=65.0&#125;, Goods&#123;name=&#x27;dellMouse&#x27;, price=43.0&#125;,</span></span><br><span class="line">        <span class="comment">//Goods&#123;name=&#x27;microsoftMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;lenovoMouse&#x27;, price=34.0&#125;,</span></span><br><span class="line">        <span class="comment">//Goods&#123;name=&#x27;xiaomiMouse&#x27;, price=12.0&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Comparable接口实现类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.price = price;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> price;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.price = price;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                Goods goods = (Goods) o;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;类型不一致&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Goods&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Comparable和Comparator接口使用的对比</p>
<ul>
<li>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可通过调用Arrays或集合的sort方法实现排序</li>
<li>属于临时性的比较</li>
</ul></li>
</ol>
<h2 id="五system类">五、System类</h2>
<p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</p>
<p>成员变量</p>
<ul>
<li>System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</li>
</ul>
<p>成员方法</p>
<ul>
<li><p>native long currentTimeMillis()： 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p></li>
<li><p>void exit(int status)： 该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p></li>
<li><p>void gc()： 该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p></li>
<li><p>String getProperty(String key)： 该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p>
<figure>
<img src="/2021/12/20/Coding/Java/09Java%E5%B8%B8%E7%94%A8%E7%B1%BB/72%20Day%20-%2002.png" alt="属性名及属性作用"><figcaption aria-hidden="true">属性名及属性作用</figcaption>
</figure></li>
</ul>
<h2 id="六math类">六、Math类</h2>
<p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">方法</th>
<th style="text-align: left;">方法功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">abs</td>
<td style="text-align: left;">绝对值</td>
</tr>
<tr class="even">
<td style="text-align: left;">acos,asin,atan,cos,sin,tan</td>
<td style="text-align: left;">三角函数</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sqrt</td>
<td style="text-align: left;">平方根</td>
</tr>
<tr class="even">
<td style="text-align: left;">pow(double a,doble b)</td>
<td style="text-align: left;">a的b次幂</td>
</tr>
<tr class="odd">
<td style="text-align: left;">log</td>
<td style="text-align: left;">自然对数</td>
</tr>
<tr class="even">
<td style="text-align: left;">exp</td>
<td style="text-align: left;">e为底指数</td>
</tr>
<tr class="odd">
<td style="text-align: left;">max(double a,double b)</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">min(double a,double b)</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">random()</td>
<td style="text-align: left;">返回0.0到1.0的随机数</td>
</tr>
<tr class="even">
<td style="text-align: left;">long round(double a)</td>
<td style="text-align: left;">double型数据a转换为long型（四舍五入）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">toDegrees(double angrad)</td>
<td style="text-align: left;">弧度—&gt;角度</td>
</tr>
<tr class="even">
<td style="text-align: left;">toRadians(double angdeg)</td>
<td style="text-align: left;">角度—&gt;弧度</td>
</tr>
</tbody>
</table>
<h2 id="七biginteger与bigdecimal">七、BigInteger与BigDecimal</h2>
<h3 id="biginteger">BigInteger</h3>
<ol type="1">
<li><p>Integer类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的，最大为263-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p></li>
<li><p>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p></li>
<li><p>构造器</p>
<ul>
<li>BigInteger(String val)：根据字符串构建BigInteger对象</li>
</ul></li>
<li><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">abs</span><span class="params">()</span>：返回此 BigInteger 的绝对值的 BigInteger。</span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span> ：返回其值为 <span class="params">(<span class="keyword">this</span> + val)</span> 的 BigInteger</span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span> ：返回其值为 <span class="params">(<span class="keyword">this</span> - val)</span> 的 BigInteger</span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span> ：返回其值为 <span class="params">(<span class="keyword">this</span> * val)</span> 的 BigInteger</span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span> ：返回其值为 <span class="params">(<span class="keyword">this</span> / val)</span> 的 BigInteger。整数相除只保留整数部分。</span></span><br><span class="line"><span class="function">BigInteger <span class="title">remainder</span><span class="params">(BigInteger val)</span> ：返回其值为 <span class="params">(<span class="keyword">this</span> % val)</span> 的 BigInteger。</span></span><br><span class="line"><span class="function">BigInteger[] <span class="title">divideAndRemainder</span><span class="params">(BigInteger val)</span>：返回包含 <span class="params">(<span class="keyword">this</span> / val)</span> 后跟<span class="params">(<span class="keyword">this</span> % val)</span> 的两个 BigInteger 的数组。</span></span><br><span class="line"><span class="function">BigInteger <span class="title">pow</span><span class="params">(<span class="keyword">int</span> exponent)</span> ：返回其值为 <span class="params">(thisexponent)</span> 的 BigInteger。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="bigdecimal">BigDecimal</h3>
<ol type="1">
<li><p>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。</p></li>
<li><p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p></li>
<li><p>构造器</p>
<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val)</li>
</ul></li>
<li><p>常用方法</p>
<ul>
<li>public BigDecimal add(BigDecimal augend)</li>
<li>public BigDecimal subtract(BigDecimal subtrahend)</li>
<li>public BigDecimal multiply(BigDecimal multiplicand)</li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul></li>
<li><p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBigInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">&quot;12433241123&quot;</span>);</span><br><span class="line">    BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">    BigDecimal bd2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(bi);</span><br><span class="line">    <span class="comment">// System.out.println(bd.divide(bd2));</span></span><br><span class="line">    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>P495</p>
<h2 id="面试">面试</h2>
<ol type="1">
<li><p>String str1 = “abc”;与String str2 = new String(“abc”);的区别？</p></li>
<li><p>String s = new String("abc");方式创建对象，在内存中创建了几个对象？</p>
<ul>
<li>两个：1个是堆空间中new结构；另一个是char[]对应的常量池中的数据。如果常量池中已经有了“abc”，则char[]数组只需指向该地址即可</li>
</ul></li>
<li><p>什么情况下，indexOf(str)和lastIndexOf(str)返回值相同</p>
<ul>
<li>存在唯一的str，或者不存在str</li>
</ul></li>
</ol>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li><p>画出如下几行代码的内存结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">s1 += <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>如何理解String类的不可变性</p></li>
<li><p>String类是否可以被继承？为什么？</p>
<p>不可被继承，因为String类被声明为final</p></li>
<li><p>String s = new String("hello");在内存中创建了几个对象？请说明</p>
<p>两个：一个是堆中的String对象，还有一个是在字符串常量池中的hello数组</p></li>
<li><p>String、StringBuffer、StringBuilder三者对比</p></li>
<li><p>String的常用方法有哪些？（至少七个）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">length() / charAt() / indexOf() / subString() / equals() / startsWith() / endsWith() / contains() / lastIndexOf() / getBytes() / toCharArray() / valueOf()</span><br></pre></td></tr></table></figure></li>
<li><p>将字符串“2017-08-16”转换为对应的java.sql.Date类的对象（使用JDK8之前或JDK8中的API皆可）</p></li>
<li><p>解释何为编码？解码？何为日期时间的格式化？解析？</p>
<ul>
<li>编码：将字符串转换为二进制数；解码：将二进制数据转化为字符串</li>
<li>日期时间的格式化：日期转化为字符串；解析：字符串转换为日期</li>
</ul></li>
<li><p>自定义Person类如下，如何实现自然排序（按姓名从小到大排序）</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj instanceOf String)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="10" type="1">
<li><p>提供定制排序涉及到的接口的实现类对象，并按Person类的年龄从大到小排序</p></li>
<li><p>JDK8之前和JDK8中日期、时间相关的类分别有哪些？</p></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章 多线程</title>
    <url>/2021/12/14/Coding/Java/08%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="第8章多线程">第8章、多线程</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、基本概念：程序、进程、线程</li>
<li>二、线程的创建和使用（重点，JDK5.0 前 2 种创建多线程方式）</li>
<li>三、线程的生命周期</li>
<li>四、线程的同步（重难点，3 种方法解决线程安全问题）</li>
<li>五、线程的通信</li>
<li>六、JDK5.0 新增的 2 种线程创建方式</li>
<li>面试</li>
<li>每日一考</li>
<li>创建多线程有哪些方式：4 种</li>
</ol>
<span id="more"></span>
<h2 id="一基本概念程序进程线程">一、基本概念：程序、进程、线程</h2>
<ol type="1">
<li><strong>程序(program)</strong>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段<strong>静态的代码</strong>，<strong>静态对象</strong></li>
<li><strong>进程(process)</strong>是程序的一次执行过程，或是<strong>正在运行的一个程序</strong>。是一个<strong>动态</strong>的过程：有它自身的产生、存在和消亡的过程。——生命周期
<ul>
<li>如：运行中的QQ，运行中的MP3播放器</li>
<li>程序是静态的，进程是动态的</li>
<li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li>
</ul></li>
<li><strong>线程(thread)</strong>，进程可进一步细化为线程，是一个程序内部的一条执行路径。
<ul>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的</li>
<li><strong>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)</strong>，线程切换的开销小</li>
<li><strong>一个进程中的多个线程共享相同的内存单元/内存地址空间 --&gt; 它们从同一堆中分配对象，可以访问相同的变量和对象</strong>。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</li>
</ul></li>
</ol>
<h3 id="单核cpu和多核cpu">单核CPU和多核CPU</h3>
<ol type="1">
<li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来。</li>
<li>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li>
<li>一个Java应用程序java.exe，其实<strong>至少有三个线程</strong>：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</li>
</ol>
<h3 id="并行和并发">并行和并发</h3>
<ol type="1">
<li>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</li>
<li>并发：一个CPU(采用时间片)“同时”执行多个任务。比如：秒杀、多个人做同一件事（多个线程同作一件事）</li>
</ol>
<h3 id="使用多线程的优点">使用多线程的优点</h3>
<p>背景：以<strong>单核</strong>CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短（cpu需要切换时间），为何仍需多线程呢？</p>
<p>多线程程序优点：</p>
<ol type="1">
<li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li>
<li>提高计算机系统CPU的利用率</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>
</ol>
<h3 id="何时需要多线程">何时需要多线程</h3>
<ol type="1">
<li>程序需要同时执行两个或多个任务。</li>
<li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</li>
<li>需要一些后台运行的程序时</li>
</ol>
<h2 id="二线程的创建和使用重点jdk5.0前2种创建多线程方式">二、线程的创建和使用（重点，JDK5.0前2种创建多线程方式）</h2>
<h3 id="多线程的创建方式一继承于thread类存在线程安全问题">多线程的创建，方式一：继承于Thread类（存在线程安全问题）</h3>
<ol type="1">
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类的run()，将此线程执行的操作声明在run()方法中</li>
<li>创建Thread类子类对象</li>
<li>调用子类对象的start()方法:
<ul>
<li>启动当前线程</li>
<li>调用当前线程的run()方法</li>
</ul></li>
</ol>
<p>问题一：不能通过直接调用对象的run()方法的方式启动线程</p>
<p>问题二：不可以让已经start()的线程去执行。会报IllegalThreadStateException。需要重新创建一个线程的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 创建Thread类子类对象</span></span><br><span class="line">        <span class="comment">// 4. 调用子类对象的start()方法</span></span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如下操作仍在main线程中进行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 匿名子类的匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 重写Thread类的run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="thread类的常用方法">Thread类的常用方法</h3>
<ol type="1">
<li>start(): 启动当前线程；调用当前线程的run方法</li>
<li>run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li>
<li>currentThread(): 静态方法，返回执行当前代码的线程</li>
<li>getName(): 获取当前线程的名字</li>
<li>setName(): 设置当前线程的名字</li>
<li>yield(): 静态方法，释放当前cpu的执行权</li>
<li>join(): 在线程A中调用线程B的join方法，此时线程a进入阻塞状态，直到线程B完全执行完后，线程A才结束阻塞状态</li>
<li>stop(): 已过时；当执行此方法时，强制结束当前线程</li>
<li>sleep(long millis): 让当前线程睡眠指定的millis毫秒。载指定的millis毫秒时间内，当前线程是阻塞状态</li>
<li>isAlive(): 判断当前线程是否存活</li>
</ol>
<h3 id="线程的调度">线程的调度</h3>
<ol type="1">
<li>调度策略
<ul>
<li>时间片</li>
<li>抢占式：高优先级线程抢占CPU</li>
</ul></li>
<li>Java的调度方法
<ul>
<li>同优先级线程组成先进先出队列，使用时间片策略</li>
<li>高优先级使用优先调度的抢占式策略</li>
</ul></li>
</ol>
<h3 id="线程的优先级">线程的优先级</h3>
<ol type="1">
<li>线程的优先等级
<ul>
<li>MAX_PRIORITY：10</li>
<li>MIN _PRIORITY：1</li>
<li>NORM_PRIORITY：5；线程的默认优先级</li>
</ul></li>
<li>线程优先级方法
<ul>
<li>getPriority() ：返回线程优先值</li>
<li>setPriority(int newPriority) ：改变线程的优先级</li>
</ul></li>
<li>高优先级的线程要抢占低优先级线程的CPU执行权。但只是从概率上讲，高优先级的线程高概率的情况下先被执行。并不意味着只有当高优先级的线程执行完后，低优先级的线程才执行。</li>
</ol>
<h3 id="创建多线程的方式二实现runnable接口存在线程安全问题">创建多线程的方式二：实现Runnable接口（存在线程安全问题）</h3>
<ol type="1">
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去实现Runnable中的抽象方法：run()</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类对象</li>
<li>通过Thread类的对象调用strat()：①启动线程；②调用当前线程的run()方法 --&gt; Java源码内，传入Thread的构造器的实参传给了 Runnable类型的target，实际上调用的target的run()方法</li>
</ol>
<h3 id="创建多线程的2种方式区别">创建多线程的2种方式区别</h3>
<ol type="1">
<li><p>开发中优先选择实现Runnable接口的方式</p>
<ul>
<li>实现的方式没有类的单继承性的局限性</li>
<li>实现的方式更适合来处理多个线程有共享数据的形式</li>
</ul></li>
<li><p>联系</p>
<ul>
<li><p>Thread也实现了Runnable接口</p></li>
<li><p>两种方式都需要重写run()，将线程执行的逻辑声明在run()中</p></li>
</ul></li>
</ol>
<h3 id="补充线程的分类">补充：线程的分类</h3>
<p>Java中的线程分为两类：一种是守护线程，一种是用户线程。</p>
<ul>
<li>用户线程在的时候，守护线程用来服务用户线程</li>
<li>通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程</li>
<li>当用户线程退出后，守护线程也将退出；java垃圾回收就是一个典型的守护线程</li>
<li>若JVM中都是守护线程，当前JVM将退出</li>
</ul>
<h2 id="三线程的生命周期">三、线程的生命周期</h2>
<p>线程的完整生命周期通常要经历如下五个状态：</p>
<ol type="1">
<li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪：处于新建状态的线程<strong>被start()后</strong>，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</li>
<li>运行：当<strong>就绪的线程被调度并获得CPU资源时,便进入运行状态</strong>， run()方法定义了线程的操作和功能0阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ol>
<figure>
<img src="/2021/12/14/Coding/Java/08%E5%A4%9A%E7%BA%BF%E7%A8%8B/69%20Day%20-%2002.png" alt="生命周期"><figcaption aria-hidden="true">生命周期</figcaption>
</figure>
<p>说明</p>
<ol type="1">
<li>生命周期关注的两个概念：状态、相应的方法</li>
<li>关注
<ul>
<li>从状态a到状态b哪些方法执行了（回调方法）</li>
<li>通过手动调用那些方法实现从状态a到状态b</li>
</ul></li>
<li>阻塞是临时状态，不可做为最终状态。</li>
</ol>
<h2 id="四线程的同步重难点3种方法解决线程安全问题">四、线程的同步（重难点，3种方法解决线程安全问题）</h2>
<p>安全问题:</p>
<ul>
<li>多个线程执行的不确定性引起执行结果的不稳定</li>
<li>多个线程对数据的共享，会造成操作的不完整性，会破坏数据。</li>
</ul>
<p>解决方法：Java中通过同步机制，来解决线程的安全问题</p>
<p>同步的方式，解决了线程的安全问题 -- 好处</p>
<p>操作同步代码时，只能有一个线程参与，其他线程等待。相当于一个单线程的过程，效率低 -- 局限性</p>
<h3 id="方式一同步代码块synchronized">方式一：同步代码块（synchronized）</h3>
<ol type="1">
<li><p>格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">    <span class="comment">// 需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>说明</p>
<ul>
<li><p>操作<strong>共享数据</strong>的代码即为需要被同步的代码；多个线程共同操作的变量即为共享数据。同步代码块不能包少了，也不能包多了（逻辑会出问题）</p></li>
<li><p><strong>同步监视器</strong>（俗称 锁）任何一个类的对象都可充当锁。</p>
<ul>
<li><p>要求多个线程共用同一把锁，即同一个对象</p></li>
<li><p>实现Runnable接口的类中，可直接创建一个新的任意类的对象作为同步监视器，或直接使用this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>继承Thread类的子类中，需创建一个static对象作为同步监视器，或直接使用“当前类.class"，即类也是一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(MyThread1.class)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ol>
<h3 id="方式二同步方法synchronized">方式二：同步方法（synchronized）</h3>
<p>如果操作共享数据的代码完整的声明在一个方法中，不妨将此方法声明为同步的</p>
<p>总结:</p>
<ol type="1">
<li><p>同步方法仍然涉及到同步监视器，只是不需要我们显式声明</p></li>
<li><p>非静态的同步方法，同步监视器为this；静态同步方法的同步监视器为当前类本身</p>
<ul>
<li><p>实现Runnable接口的类中，可直接抽出部分代码作为方法，并将此方法声明为synchronized、在run()方法体中调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">// 同步方法中的同步监视器：this</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>继承Thread类的子类中，抽出部分代码作为方法，并将此方法声明为synchronized，但需同时将此方法声明为static，此时使用的同步监视器为“当前类.class"，即类也是一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">// 同步监视器：MyThread1.class</span></span><br><span class="line">        <span class="comment">// private synchronized void show()&#123; // 同步监视器：this，指当前对象，所以锁不唯一</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h3 id="单例模式之懒汉式-安全问题解决">单例模式之懒汉式 安全问题解决</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123; <span class="comment">// 同步方法</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Bank();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 懒汉式同步代码块实现方式一: 效率稍差</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Bank.class) &#123; <span class="comment">// 同步代码块</span></span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Bank();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 懒汉式同步代码块实现方式二【Double-checked locking 】: 效率较高</span></span><br><span class="line">        <span class="comment">// 原因：当同时来的多个线程取对象时，仍然相当于单线程判断和执行</span></span><br><span class="line">        <span class="comment">//      但当后面再来多个线程取对象时，直接return走了，无需进入单线程判断和执行</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Bank.class) &#123; <span class="comment">// 同步代码块</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Bank();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁问题">死锁问题</h3>
<ol type="1">
<li>死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li>
<li>说明
<ul>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li>
<li>使用同步时，要避免出现死锁</li>
</ul></li>
</ol>
<h3 id="方式三lock锁-----jdk5.0新增">方式三：Lock锁 --- JDK5.0新增</h3>
<ol type="1">
<li>实例化ReentrantLock( 需保证多个线程的lock对象是相同的 )</li>
<li>调用上锁方法：lock()</li>
<li>调用解锁方法：unlock()</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 1. 实例化</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">// 2. 调用上锁方法 lock</span></span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: ID - &quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 调用解锁方法 unlock</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优先使用顺序</strong></p>
<ul>
<li>Lock - 同步代码块 - 同步方法</li>
</ul>
<h3 id="小结释放锁的操作">小结：释放锁的操作</h3>
<ol type="1">
<li>当前线程的同步方法、同步代码块执行结束。</li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li>
</ol>
<h3 id="小结不释放锁的操作">小结：不释放锁的操作</h3>
<ol type="1">
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、 Thread.yield()方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。
<ul>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul></li>
</ol>
<h2 id="五线程的通信">五、线程的通信</h2>
<h3 id="涉及到的三个方法">涉及到的三个方法</h3>
<ol type="1">
<li>wait(): 一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器</li>
<li>notify(): 一旦执行此方法，就会唤醒被wait()的一个线程。如果多个线程被wait()，就唤醒优先级高的线程</li>
<li>notifyAll(): 一旦执行此方法，就会唤醒所以被wait()的线程</li>
</ol>
<h3 id="说明">说明</h3>
<ol type="1">
<li>wait()、notify()、notifyAll()都必须使用在同步代码块或同步方法中</li>
<li>wait()、notify()、notifyAll()的<strong>调用者必须是同步代码块或同步方法中的同步监视器，否则会出现IllegalMonitorStateException异常</strong></li>
<li>wait()、notify()、notifyAll()三个方法定义在java.lang.Object类中</li>
</ol>
<h3 id="经典问题生产者消费者问题">经典问题（生产者/消费者问题）</h3>
<p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p>
<p>这里可能出现两个问题：</p>
<ul>
<li>生产者比消费者快时，消费者会漏掉一些数据没有取到。</li>
<li>消费者比生产者快时，消费者会取相同的数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享数据：店员 / 产品数量</span></span><br><span class="line"><span class="comment">// 涉及线程安全问题：3种同步机制</span></span><br><span class="line"><span class="comment">// 涉及线程通信</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line"></span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(clerk);</span><br><span class="line">        producer.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer(clerk);</span><br><span class="line">        customer.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        customer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produceProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (productNum &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            productNum++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 正在生产第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (productNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: 正在购买第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            productNum--;</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            clerk.produceProduct();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六jdk5.0新增的2种线程创建方式">六、JDK5.0新增的2种线程创建方式</h2>
<h3 id="创建线程方式三jdk5.0新增方式一实现callable接口">创建线程方式三（JDK5.0新增方式一）：实现Callable接口</h3>
<ol type="1">
<li><p>与使用Runnable相比， Callable功能更强大些</p>
<ul>
<li>相比run()方法，Call()方法可以有返回值</li>
<li>Call()方法可以抛出异常，被外面的操作捕获，获取异常信息</li>
<li>Callable支持泛型，Call()支持泛型的返回值</li>
<li>需要借助FutureTask类，比如获取返回结果</li>
</ul></li>
<li><p>过程</p>
<ul>
<li>创建一个实现Callable的实现类</li>
<li>实现类中实现Call方法，将此线程需要执行的操作声明在Call方法中</li>
<li>创建Callable实现类的对象</li>
<li>将实现类对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</li>
<li>将FutureTask的对象作为参数传递到Thread的构造器中，创建Thread对象，并调用start()方法</li>
<li>获取Callable中Call方法中的返回值，FutureTask对象的get()方法返回值即为FutureTask构造器参数Callable实现类重写的Call()的返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="创建线程方式四jdk5.0新增方式二开发常用线程池">创建线程方式四（JDK5.0新增方式二，开发常用）：线程池</h3>
<p><strong>背景</strong>：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 <strong>思路</strong>：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。<strong>可以避免频繁创建销毁、实现重复利用</strong>。类似生活中的公共交通工具。</p>
<p><strong>好处</strong>：</p>
<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理（多于数据库可连接总数时，不再提供连接）
<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
<li>…</li>
</ul></li>
</ul>
<h2 id="面试">面试</h2>
<ol type="1">
<li>synchronized 与 Lock 的异同
<ul>
<li>相同点：两者都可解决线程的安全问题</li>
<li>不同点：
<ul>
<li>synchronized机制在执行完相应的同步代码块后，自动释放同步监视器</li>
<li>Lock需要手动启动同步lock()，同时结束同步也需要手动的实现unlock()</li>
</ul></li>
</ul></li>
<li>sleep()方法和wait()方法的异同？（重点）
<ul>
<li>相同点：执行后都可使当前线程进入阻塞状态</li>
<li>不同点：
<ul>
<li>两方法声明位置不同：Thread类中声明sleep()，Object类中声明wait()</li>
<li>调用要求不同：sleep()可在需要的场景下调用；wait()必须使用在同步代码块或同步方法中</li>
<li>关于释放同步监视器：如两方法都使用在同步方法或同步代码块中，sleep()不会释放同步监视器，wait()会释放同步监视器</li>
</ul></li>
</ul></li>
<li>创建多线程有几种方式？
<ul>
<li>四种：
<ul>
<li>继承Thread类并重写run方法，在main中创建对象并调用start()方法</li>
<li>实现Runnable接口方式，实现接口run方法，在main中创建实现类对象，并将该对象作为参数传给Thread构造函数，通过Thread对象调用start()方法</li>
<li>实现Callable接口方式，实现Call方法，在main中创建实现类对象，将该对象作为参数传给FutureTask构造函数，将FutureTask对象作为参数传给Thread构造函数，通过Thread对象调用start()方法</li>
<li>使用线程池方式，响应速度提高、提高了资源重用率，便于管理</li>
</ul></li>
</ul></li>
<li>如何解决线程安全问题，有几种方式，对比几种方式的不同点</li>
</ol>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li><p>谈谈你对程序、进程、线程的理解</p>
<ul>
<li>程序是静态的代码</li>
<li>进程是正在运行的程序，动态的</li>
<li>线程：进程可以细分为线程，线程是一个程序内部的一条执行路径</li>
</ul></li>
<li><p>代码完成继承Thread的方式创建分线程，并遍历100以内的自然数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread1 t1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        t1.setName(<span class="string">&quot;Extends Thread 线程&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代码完成实现Runnable接口的方法创建分线程，并遍历100以内的自然数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread2 t2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(t2);</span><br><span class="line"></span><br><span class="line">        t.setName(<span class="string">&quot;implements Runnable 线程&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对比两种创建方式</p></li>
<li><p>说说你对IDEA中Project和Module的理解</p>
<ul>
<li>一个项目Project由多个相互联系的模块Module组成</li>
</ul></li>
<li><p>画图说明线程的生命周期，以及各状态切换使用到的方法等</p>
<ul>
<li>创建、就绪、运行、阻塞、死亡</li>
<li></li>
</ul></li>
<li><p>同步代码块中涉及到同步监视器和共享数据，谈谈你对同步监视器和共享数据的理解，以及注意点</p>
<ul>
<li>同步监视器是什么，
<ul>
<li>需要同步的代码的同步监视器需要是同一个对象</li>
<li>非静态同步方法的同步监视器是this，静态方法的同步监视器是当前类本身</li>
</ul></li>
<li>共享数据是多个线程共同操作的数据，
<ul>
<li>操作共享数据代码不能包多了，也不能包少了</li>
</ul></li>
</ul></li>
<li><p>sleep()和wait()的区别</p>
<ul>
<li>声明的位置不同：</li>
<li>调用者不同</li>
<li>调用的位置不同</li>
<li>释放锁情况不同</li>
</ul></li>
<li><p>写一个线程安全的懒汉式</p></li>
<li><p>创建多线程有哪些方式：4种</p></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章 异常处理</title>
    <url>/2021/12/11/Coding/Java/07%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="第7章异常处理">第7章、异常处理</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、异常概述与异常体系结构</li>
<li>二、常见异常</li>
<li>三、异常处理机制一：try - catch - finally (重点)</li>
<li>四、异常处理机制二：throws (重点)</li>
<li>五、手动抛出异常：throw</li>
<li>六、用户自定义异常类</li>
<li>面试题</li>
</ol>
<span id="more"></span>
<h2 id="一异常概述与异常体系结构">一、异常概述与异常体系结构</h2>
<h3 id="异常概述">异常概述</h3>
<p>异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。(开发过程中的语法错误和逻辑错误不是异常)</p>
<p>Java程序在执行过程中所发生的异常事件可分为两类（广义异常）：</p>
<ul>
<li>Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：java.lang.StackOverflowError（栈溢出）和java.lang.OutOfMemoryError（堆溢出，OOM）。一般不编写针对性的代码进行处理。</li>
<li>Exception（狭义异常）: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：
<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul></li>
</ul>
<ol type="1">
<li>对于这些错误，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。</li>
</ol>
<h3 id="异常体系结构">异常体系结构</h3>
<ul>
<li>java.lang.Throwable
<ul>
<li>java.lang.Error</li>
<li>java.lang.Exception
<ul>
<li>编译时异常（受检异常，checked）
<ul>
<li>IOException
<ul>
<li>FileNotFoundException</li>
</ul></li>
<li>ClassNotFoundException</li>
<li>...</li>
</ul></li>
<li>运行时异常（非受检异常，unchecked）java.lang.RuntimeException
<ul>
<li>NullPointerException</li>
<li>ArrayIndexOutOfBoundsException</li>
<li>ClassCastException</li>
<li>NumberFormatException</li>
<li>InputMismatchException</li>
<li>ArithmeticException</li>
<li>...</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="二常见异常">二、常见异常</h2>
<ul>
<li>java.lang.RuntimeException
<ul>
<li>ClassCastException</li>
<li>ArrayIndexOutOfBoundsException</li>
<li>NullPointerException</li>
<li>ArithmeticException</li>
<li>NumberFormatException</li>
<li>InputMismatchException</li>
<li>。。。</li>
</ul></li>
<li>java.io.IOExeption
<ul>
<li>FileNotFoundException</li>
<li>EOFException</li>
</ul></li>
<li>java.lang.ClassNotFoundException</li>
<li>java.lang.InterruptedException</li>
<li>java.io.FileNotFoundException</li>
<li>java.sql.SQLException</li>
</ul>
<h2 id="三异常处理机制一try---catch---finally重点">三、异常处理机制一：try - catch - finally(重点)</h2>
<h3 id="异常处理抓抛模型">异常处理：抓抛模型</h3>
<p>过程一：抛，程序在正常执行过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。一旦抛出对象后，其后的代码就不再执行</p>
<p>过程二：抓，理解为异常处理方式：①try - catch - finally</p>
<h3 id="try-catch-finally的使用">try-catch-finally的使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 处理异常类型1的处理方式方式1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 处理异常类型2的处理方式方式2</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">// 处理异常类型3的处理方式方式3</span></span><br><span class="line">&#125; </span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：
<ul>
<li>finally是可选的</li>
<li>使用try将可能出现异常的代码包装起来，执行过程中一旦出现异常，就会生成一个异常类的对象，根据此对象的类型，去catch中进行匹配</li>
<li>一旦try中的异常对象匹配到某个catch条件时，就进入catch中进行异常处理，一旦处理完成，就跳出当前的try-catch结构（无finally的情况），继续执行其后的代码</li>
<li>catch中的异常类型，如无子父类关系，谁声明在上、下无所谓；catch中的异常类型如满足子父类关系，则要求子类的catch语句声明在父类的catch语句上面，否则报错</li>
<li>常用的异常对象处理方式：①String getMessage(); ②printStackTrace();</li>
<li>try结构中声明的变量，出了try结构后就不能被调用了</li>
<li>try-catch-finally结构可以嵌套</li>
</ul></li>
<li>体会
<ul>
<li>使用try-catch-finally处理编译时异常，会使得程序在编译时不在报错，但在运行时可能会报错。相当于使用try-catch-finally结构将一个编译时可能出现的异常，延迟到运行时出现</li>
<li>开发中，由于运行时异常比较常见，所以通常不针对运行时异常编写try-catch-finally了。但针对编译时异常，一定要考虑异常处理（处理编译时异常使得可能出现的异常延迟，起码生成字节码文件）</li>
</ul></li>
</ul>
<h3 id="try-catch-finally中finally的使用">try-catch-finally中finally的使用</h3>
<ol type="1">
<li>finally是可选的</li>
<li>finally中声明的是一定会被执行的代码，即使catch中又出现异常、try中有return语句（被执行）、catch中有return语句（被执行）等情况。【如try、catch、finally中都有return语句，则最终返回的是finally中的return语句】</li>
<li>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，我们需要手动进行资源的释放，此时的资源释放代码<strong>需要声明在finally中</strong></li>
<li>右键 - surround with - try/catch block</li>
</ol>
<h2 id="四异常处理机制二throws重点">四、异常处理机制二：throws(重点)</h2>
<ol type="1">
<li>“throws + 异常类型” 卸载方法的声明处，指明此方法执行时可能会抛出的异常类型。一旦方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后的异常类型时就会被抛出（抛给调用者），异常代码后的代码就不再执行</li>
<li>体会：
<ul>
<li>try-catch-finally：真正的把异常处理掉了</li>
<li>throws的方式只是将异常抛给了方法的调用者，并没有真正的将异常处理掉</li>
</ul></li>
<li>开发中如何选择try-catch-finally，还是使用throws
<ul>
<li>如父类中被重写方法没有throws处理异常，则子类重写的方法也不能使用throws方式处理异常，意味着如果子类重写的方法中有可能出现异常，必须使用try-catch-finally方式处理异常</li>
<li>执行的方法a中，先后又调用了另外几个方法时，且这几个方法是递进关系执行的（下一个方法的执行依赖于上一个方法的正确结果），那么建议这几个方法使用throws方式进行处理，而执行的方法a可以考虑使用try-catch-finally方式进行处理</li>
</ul></li>
</ol>
<h3 id="方法重写的规则子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型">方法重写的规则：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</h3>
<p>重写的方法，在编译时看的父类被重写方法，因此在编译阶段认为：方法抛出异常后调用者处理的是父类中被重写方法的异常类型，然而由于多态性，运行时运行的是子类重写的方法，因此如果子类重写的方法抛出的异常类型大于父类被重写的方法抛出的异常，调用者处理异常的方法失效，编译报错</p>
<h2 id="五手动抛出异常throw">五、手动抛出异常：throw</h2>
<p>程序执行中，除了自动抛出异常对象的情况外，还可手动的throw一个异常类的对象</p>
<p>异常对象的产生：①系统自动生成的异常对象；②手动的生成一个异常对象，并抛出（throw）</p>
<h2 id="六用户自定义异常类">六、用户自定义异常类</h2>
<p>如何自定义异常类</p>
<ol type="1">
<li>继承于现有的异常结构：RuntimeException、Exception</li>
<li>提供全局常量serialVersionUID</li>
<li>提供重载的构造器</li>
</ol>
<h2 id="面试题">面试题</h2>
<ol type="1">
<li>常见的异常都有哪些？举例说明</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//		File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line"><span class="comment">//		FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		int data = fis.read();</span></span><br><span class="line"><span class="comment">//		while(data != -1)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.print((char)data);</span></span><br><span class="line"><span class="comment">//			data = fis.read();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		fis.close();</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line">	<span class="comment">//ArithmeticException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">		System.out.println(a / b);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//InputMismatchException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> score = scanner.nextInt();</span><br><span class="line">		System.out.println(score);</span><br><span class="line">		</span><br><span class="line">		scanner.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//NumberFormatException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">		str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//ClassCastException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Object obj = <span class="keyword">new</span> Date();</span><br><span class="line">		String str = (String)obj;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//		int[] arr = new int[10];</span></span><br><span class="line"><span class="comment">//		System.out.println(arr[10]);</span></span><br><span class="line">		<span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">		String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//NullPointerException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		int[] arr = null;</span></span><br><span class="line"><span class="comment">//		System.out.println(arr[3]);</span></span><br><span class="line">		</span><br><span class="line">		String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		str = <span class="keyword">null</span>;</span><br><span class="line">		System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>throw和throws有什么区别？
<ul>
<li>throws为一种异常处理方式
<ul>
<li>属于异常处理的一种方式，声明在方法的声明处</li>
</ul></li>
<li>throw为手动抛出异常对象
<ul>
<li>表示抛出一个异常类的对象，生成异常类对象的过程。声明在方法体内</li>
</ul></li>
</ul></li>
<li>final、finally、finalize三者区别（
<ul>
<li>结构相似的
<ul>
<li>Collection和Collections，</li>
<li>String、StringBuffer、StringBuilder，</li>
<li>ArrayList、LinkedList，</li>
<li>HashMap、LinkedHashMap，</li>
<li>重写、重载</li>
</ul></li>
<li>结构不相似的
<ul>
<li>抽象类、接口</li>
<li>==、equals()</li>
<li>sleep()、wait()</li>
</ul></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章 面向对象编程-下</title>
    <url>/2021/12/04/Coding/Java/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8B/</url>
    <content><![CDATA[<h1 id="第6章面向对象编程-下">第6章、面向对象编程-下</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、关键字：static</li>
<li>单例（Singleton）设计模式【掌握，可能在笔试时手写】</li>
<li>二、理解 main 方法的语法</li>
<li>三、类的成员之四：代码块（或初始化块）</li>
<li>四、关键字：final</li>
<li>五、抽象类与抽象方法【少数认为归为特征（封装、继承、多态、抽象），一般归为关键字：abstract】</li>
<li>六、接口（interface）【关键字的使用】</li>
<li>七、类的成员之五：内部类（自己写比较少，但源码中会出现）</li>
<li>面试题</li>
<li>每日一考</li>
<li>声明抽象类，并包含抽象方法，测试类中创建一个继承抽象类的匿名子类对象</li>
</ol>
<span id="more"></span>
<h2 id="一关键字static">一、关键字：static</h2>
<ol type="1">
<li>static：静态的</li>
<li>static可用来修饰：属性、方法、代码块、内部类</li>
<li>使用static修饰属性：<strong>静态变量（或类变量）</strong>
<ul>
<li><p>属性：按是否使用static修饰，又分为静态属性 vs 非静态属性（实例变量）</p>
<ul>
<li>实例变量：创建类的多个对象，每个对象都<strong>独立的</strong>拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改</li>
<li>静态变量：创建类的多个对象，多个对象<strong>共享</strong>同一个静态变量，当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li>
</ul></li>
<li><p>static修饰属性的其他说明</p>
<ul>
<li>静态变量随着类的加载而加载，可通过“类.静态变量”的方式进行调用</li>
<li>静态变量加载要早于对象的创建</li>
<li>由于类只会加载一次，则静态变量也只会存在一份，存在方法区的静态域中</li>
</ul></li>
<li><p>静态属性举例</p>
<ul>
<li>System.out</li>
<li>Math.PI</li>
</ul></li>
<li><p>类变量 vs 实例变量的内存解析</p>
<figure>
<img src="/2021/12/04/Coding/Java/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8B/类变量和实例变量内存解析.png" alt="类变量和实例变量内存解析"><figcaption aria-hidden="true">类变量和实例变量内存解析</figcaption>
</figure></li>
</ul></li>
<li>使用static修饰方法：<strong>静态方法</strong>
<ul>
<li>随着类的加载而加载，可通过“类.静态方法”的方式调用</li>
<li>静态方法中只能调用静态的方法或属性。非静态方法中即可调用非静态的方法和属性、也可调用静态的方法和属性</li>
</ul></li>
<li>static注意点
<ul>
<li>静态方法中，不能使用this关键字和super关键字（this和super都是基于有当前对象才可调用的）<strong>？super调用父类中的static结构也不可</strong></li>
<li>静态属性和静态方法的使用，可从生命周期的角度分析</li>
</ul></li>
<li>开发中，如何确定一个属性是否要声明为static的？
<ul>
<li>属性可被多个对象所共享，不会随对象的不同而不同时</li>
<li>类中的常量也通常声明为static</li>
</ul></li>
<li>开发中，如何确定一个方法是否要声明为static的？
<ul>
<li>操作静态属性的方法通常设置为static的</li>
<li>工具类中的方法，习惯上声明为static的，如Math、Arrays、Collections</li>
</ul></li>
</ol>
<h3 id="单例singleton设计模式掌握可能在笔试时手写">单例（Singleton）设计模式【掌握，可能在笔试时手写】</h3>
<ol type="1">
<li>设计模式 定义
<ul>
<li>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路”</li>
</ul></li>
<li>单例设计模式 定义
<ul>
<li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</li>
<li>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。</li>
<li>因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</li>
</ul></li>
<li>单例设计模式实现【笔试时写线程安全的，不要写线程不安全的代码】
<ul>
<li><strong>饿汉式</strong>单例模式实现（先把对象创建出来）</li>
<li><strong>懒汉式</strong>单例设计模式（不用对象不造，用的时候才造对象）</li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式（单例模式）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 内部创建类的对象</span></span><br><span class="line">	<span class="comment">// 静态方法中操作的对象也需要是静态的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 提供公共的静态方法，返回类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1. 私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2. 声明当前类对象，无需初始化</span></span><br><span class="line">	<span class="comment">// 4. 此对象需声明为静态的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 3. 声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Order();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>区分饿汉式和懒汉式
<ul>
<li>饿汉式
<ul>
<li>坏处：对象加载的时间过长（先加载出来对象，有可能长时间不用）</li>
<li>好处：是线程安全的</li>
</ul></li>
<li>懒汉式：
<ul>
<li>好处：延迟对象的创建</li>
<li>目前写法的坏处：线程不安全 ---&gt;多线程项目时需修改</li>
</ul></li>
</ul></li>
<li>单例模式的优点
<ul>
<li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</li>
<li>举例：java.lang.Runtime</li>
</ul></li>
<li>单例模式的应用场景
<ul>
<li>网站的计数器，一般也是单例模式实现，否则难以同步。</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li>
<li>Application 也是单例的典型应用</li>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
</ul></li>
</ol>
<h2 id="二理解main方法的语法">二、理解main方法的语法</h2>
<ol type="1">
<li>main()方法作为程序的入口</li>
<li>main()方法也是一个普通的静态方法</li>
<li>main()方法可作为我们与控制台交互的方式（之前用的是Scanner）</li>
</ol>
<h2 id="三类的成员之四代码块或初始化块">三、类的成员之四：代码块（或初始化块）</h2>
<ol type="1">
<li>代码块的作用：用来初始化类、对象</li>
<li>代码块如有修饰，只能使用static。因此代码块分为<strong>静态代码块 vs 非静态代码块</strong></li>
<li>静态代码块
<ul>
<li>格式：static { ... }</li>
<li>内部可有输出语句</li>
<li>随着类的加载（使用到类时加载）而执行，只会执行一次，除非类被重新加载</li>
<li>作用：初始化类的信息</li>
<li>如一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li>
<li>静态代码块的执行优先于非静态代码块的执行（类和对象加载先后）。静态代码块只能调用静态属性、方法，不能调用非静态的结构</li>
</ul></li>
<li>非静态代码块
<ul>
<li>格式：{ ... }</li>
<li>内部可有输出语句</li>
<li>随着对象的创建而执行，每创建一个就执行一次</li>
<li>作用：在创建对象时，对对象的属性进行初始化</li>
<li>如一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li>
<li>非静态代码块既可调用静态属性、方法，也可调用非静态的结构</li>
</ul></li>
<li>静态代码块、构造器、静态方法（包含main）、非静态代码块执行的先后顺序：由父及子，静态先行。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> codeblock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Root</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">			+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">		<span class="keyword">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeafTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Leaf(); </span><br><span class="line">		<span class="comment">//new Leaf();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> codeblock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;11111111111&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;22222222222&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;33333333333&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;44444444444&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;55555555555&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;66666666666&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// 由父及子 静态先行</span></span><br><span class="line">		System.out.println(<span class="string">&quot;77777777777&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">		System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">		System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> Father();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>属性赋值的先后顺序：默认初始化 - 显式初始化 / 代码块（先后顺序） - 构造器中赋值 - 创建对象后通过对象.方法或对象.属性赋值</li>
</ol>
<h2 id="四关键字final">四、关键字：final</h2>
<p>final：最终的 1. final可用来修饰：类、方法、变量 2. final修饰类：此类即不可被其他类继承 - 例如：String类、System类、StringBuffer类 3. final修饰方法：此方法不可被重写 - 例如：Object类中的getClass()方法【native关键字表示其方法实现采用C/C++代码实现】 4. final修饰变量：此“变量”即为一个常量 - final修饰属性：可赋值的位置有显式初始化、代码块中赋值、构造器中初始化【不可使用默认值，不可采用set方法赋值（类的构造器执行完毕后对象及其内部结构就应被初始化，而方法晚于对象及属性初始化）】 - final修饰局部变量： - 尤其使用final修饰形参时，表明此形参为一个常量，当调用此方法时，给常量形参赋一个实参，一旦赋值后，就只能在方法体内使用此形参，不可进行赋值等修改操作</p>
<ol start="5" type="1">
<li>static final可用来修饰：属性、方法
<ul>
<li>修饰属性：全局（static）常量（final）</li>
</ul></li>
</ol>
<h2 id="五抽象类与抽象方法少数认为归为特征封装继承多态抽象一般归为关键字abstract">五、抽象类与抽象方法【少数认为归为特征（封装、继承、多态、抽象），一般归为关键字：abstract】</h2>
<ol type="1">
<li>抽象类定义</li>
</ol>
<ul>
<li>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</li>
</ul>
<ol start="2" type="1">
<li><p>abstract关键字的使用：abstract可用来修饰类、方法</p></li>
<li><p>abstract修饰类</p>
<ul>
<li>抽象类不能实例化</li>
<li>抽象类中一定有构造器，子类实例化时会调用</li>
<li>开发中，需提供抽象类的子类，让子类实例化，完成开发工作</li>
</ul></li>
<li><p>abstract修饰方法</p>
<ul>
<li>抽象方法只有方法的声明，无方法体</li>
<li>包含抽象方法的类一定是抽象类，反之抽象类中可以没有抽象方法</li>
<li>若子类重写了父类中的所有抽象方法，此类方可实例化；若子类没有重写父类中的所有抽象方法，此类仍需是抽象类，需使用abstract修饰类。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若子类重写了父类中的所有抽象方法，此类方可实例化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="comment">// Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若子类没有重写父类中的所有抽象方法，此类仍需是抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>abstract使用上的注意点：不可修饰属性、构造器；不可修饰私有方法、静态方法和final方法（私有方法和静态方法无法重写）</p></li>
</ol>
<h3 id="举例l">举例l</h3>
<p>IO流中涉及到的抽象类：InputStream / OutputStream / Reader / Writer，在其内部定义了抽象的read()、write()方法</p>
<h3 id="抽象类的匿名子类">抽象类的匿名子类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person为抽象类，含有一个eat抽象方法</span></span><br><span class="line"><span class="comment">// 匿名子类</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">method(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名子类的匿名对象</span></span><br><span class="line">method( <span class="keyword">new</span> Person()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<h3 id="模板方法设计模式templatemethod抽象类的应用">模板方法设计模式（TemplateMethod）【抽象类的应用】</h3>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p>解决的问题： - 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。 - 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		code(); <span class="comment">//不确定的部分； 像个钩子一样，挂哪个子类就执行那个子类的实现代码</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六接口interface关键字的使用">六、接口（interface）【关键字的使用】</h2>
<ul>
<li>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li>
<li>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须能...”的思想。继承是一个"是不是"的关系，而接口实现则是 "能不能" 的关系。</li>
<li>接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。</li>
</ul>
<h3 id="接口的使用jdk7及之前">接口的使用(JDK7及之前)</h3>
<ol type="1">
<li><p>接口使用interface来定义</p></li>
<li><p>Java中，接口和类是并列的两个结构</p></li>
<li><p>如何定义接口，定义接口中的成员</p>
<ul>
<li>JDK 7及以前，只能定义全局常量和抽象方法
<ul>
<li>全局常量：public static final的(可省略不写，但仍是全局常量)</li>
<li>抽象方法：public abstract的</li>
</ul></li>
<li>JDK 8：除了定义全局常量和抽象方法之外，还可定义静态方法、默认方法</li>
</ul></li>
<li><p>接口中不能定义构造器，意味着接口不可实例化</p></li>
<li><p>Java开发中接口通过让类去实现（implements）的方式使用。如果实现类覆盖了接口中所有抽象方法，此实现类即可实例化；否则，该类是抽象类，需使用abstract修饰</p></li>
<li><p>类中把abstract方法重写其实是<strong>实现</strong>，子类覆盖父类的方法叫重写</p></li>
<li><p>Java类可实现多个接口（多实现） ---&gt; 弥补了Java单继承的局限性。</p>
<ul>
<li>格式：class AA extends BB implements CC, DD, EE{} <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Attackable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 全局常量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SPEED = <span class="number">7900</span>; <span class="comment">//第一宇宙速度</span></span><br><span class="line">	<span class="keyword">int</span> MIN_SPEED = <span class="number">1</span>; <span class="comment">// 省略了public static final</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>; <span class="comment">// 省略了public abstract</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bullet</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Flyable</span>, <span class="title">Attackable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>接口和接口之间可以<strong>多继承</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BB</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CC</span> <span class="keyword">extends</span> <span class="title">AA</span>, <span class="title">BB</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">CC</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>接口的具体使用，体现多态性</p></li>
<li><p>接口实际上可看作是一种规范（例如USB是一种规范，具体的硬盘、U盘、打印机都需要去实现USB规范中的具体操作，驱动即是接口实现类的集合）</p></li>
<li><p>开发中，体会面向接口编程</p></li>
</ol>
<ul>
<li>接口的主要用途就是被实现类实现（面向接口编程）</li>
<li>项目的具体需求是多变的，我们必须以不变应万变才能从容开发，此处的不变就是规范，因此，开发项目往往是面向接口编程</li>
<li>例子：面向接口编程，在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个数据库厂商的API</li>
</ul>
<ol start="12" type="1">
<li>创建实现类对象的四种类型</li>
</ol>
<ul>
<li>非匿名实现类的非匿名对象</li>
<li>非匿名实现类的匿名对象</li>
<li>匿名实现类的非匿名对象</li>
<li>匿名实现类的匿名对象</li>
</ul>
<h3 id="接口的应用">接口的应用</h3>
<ol type="1">
<li>代理模式（Proxy）
<ul>
<li>应用场景
<ul>
<li>安全代理：屏蔽对真实角色的直接访问。</li>
<li>远程代理：通过代理类处理远程方法调用（RMI）</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li>
</ul></li>
<li>分类
<ul>
<li>静态代理（静态定义代理类）</li>
<li>动态代理（动态生成代理类）
<ul>
<li>JDK自带的动态代理，需要反射等知识</li>
</ul></li>
</ul></li>
</ul></li>
<li>工厂模式
<ul>
<li>简单工厂模式：class XxxFactory{}。创建Xxx对象的类</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul></li>
</ol>
<h3 id="接口的使用jdk8">接口的使用（JDK8）</h3>
<p>除了定义全局常量和抽象方法之外，还可定义静态方法、默认方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceJDK8</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 默认方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 此处只是省略了public</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method3&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>接口中定义的静态方法，只能通过接口来调用（接口名.静态方法），实现类无法调用</p></li>
<li><p>实现类的对象可调用接口中的默认方法。如果实现类重写了接口中的默认方法（重写时不加default关键字），调用时调用的是重写后的方法</p></li>
<li><p>如果子类或实现类继承的父类 和 实现的接口中声明了同名同参数的方法（默认方法），在子类没有重写此方法的情况下，调用的是父类中的同名同参数方法 --&gt; 类优先原则（只是指方法，属性不适用）</p></li>
<li><p>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，，那么在实现类没有重写此方法的情况下，报错 --&gt; 接口冲突。需要在实现类中重写此方法</p></li>
<li><p>在实现类方法中调用父类、接口中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 假设method3为SuperClass、InterfaceA、InterfaceB中有方法体的同名同参数方法</span></span><br><span class="line">        method3(); <span class="comment">//调用自己重写的方法</span></span><br><span class="line">        <span class="keyword">super</span>.method3(); <span class="comment">//调用父类中的方法</span></span><br><span class="line">        InterfaceA.<span class="keyword">super</span>.method3(); <span class="comment">//调用InterfaceA接口中的method3()方法</span></span><br><span class="line">        InterfaceB.<span class="keyword">super</span>.method3(); <span class="comment">//调用InterfaceB接口中的method3()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="七类的成员之五内部类自己写比较少但源码中会出现">七、类的成员之五：内部类（自己写比较少，但源码中会出现）</h2>
<ol type="1">
<li><p>Java中允许将一个类A声明在另一个类B中，则A为内部类，类B为外部类</p></li>
<li><p>内部类分类：成员内部类 vs 局部内部类（方法内、代码块内、构造期内...）</p></li>
<li><p>成员内部类</p>
<ul>
<li>作为外部类的成员：
<ul>
<li>可调用外部类结构</li>
<li>可被static修饰（内部类可被static修饰，外部类不可）</li>
<li>作为成员，可被四种权限修饰</li>
</ul></li>
<li>作为一个类：
<ul>
<li>类内部定义属性、方法、构造器等</li>
<li>可被final修饰，表示此类不可被继承。反之可被继承</li>
<li>可被abstract修饰</li>
</ul></li>
</ul></li>
<li><p>关注的3个问题</p></li>
</ol>
<ul>
<li><p>如何实例化成员内部类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 创建Dog实例（静态成员内部类）</span></span><br><span class="line">		Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 创建Bird实例（非静态成员内部类）</span></span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		Person.Bird bird = p.<span class="function">new <span class="title">Bird</span><span class="params">()</span></span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如何在成员内部类中区分调用外部类结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态成员内部类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">		<span class="comment">// 属性、构造器、方法、代码块</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 非静态成员内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">		<span class="comment">// 属性、构造器、方法、代码块</span></span><br><span class="line">		String name;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;形参：&quot;</span> + name);</span><br><span class="line">			System.out.println(<span class="string">&quot;内部类name：&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">			System.out.println(<span class="string">&quot;外部类name：&quot;</span> + Person.<span class="keyword">this</span>.name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>开发中局部内部类的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 开发中少见</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 方式一</span></span><br><span class="line">		<span class="comment">// 创建一个实现了Comparable接口的类: 局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyComparable</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyComparable();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 方式二</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5" type="1">
<li>注意点
<ul>
<li>在局部内部类方法中，如要在局部内部类所声明的方法中调用内部类所在方法中的局部变量的话，要求此变量声明为final的。JDK7之前，要求此局部变量显式声明为final，JDK8及之后，可省略显式声明。（移动端开发 （android开发）使用较多）【原因：每个类都会生成一个字节码文件，但是方法中的局部变量作用域和字节码文件作用域不同，因此需要声明局部变量为final，且传给内部类中的方法的变量值为该局部变量的副本】</li>
</ul></li>
<li>总结
<ul>
<li>成员内部类和局部内部类，在编译后都会生成字节码文件。格式：</li>
<li>成员内部类：外部类名$内部类名.class，例如：Person$Dog.class</li>
<li>局部内部类：外部类名$数字内部类名.class，例如：Person$1Bird.class</li>
</ul></li>
</ol>
<h2 id="面试题">面试题</h2>
<ol type="1">
<li><p>final 排错 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addOne</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ++x;</span><br><span class="line">		<span class="comment">// return x + 1;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Other o = <span class="keyword">new</span> Other();</span><br><span class="line">		<span class="keyword">new</span> Something().addOne(o);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">(<span class="keyword">final</span> Other o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// o = new Other();</span></span><br><span class="line">		o.i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure></p></li>
<li><p>抽象类和接口有哪些异同？</p>
<ul>
<li>相同点：
<ul>
<li>不可实例化，都包含抽象方法；</li>
</ul></li>
<li>不同点：
<ul>
<li>抽象类和接口定义、内部结构解释说明（JDK7及前，JDK8，JDK9）</li>
<li>抽象类有构造器，接口无构造器；</li>
<li>单继承和多继承</li>
<li>类与接口的关系：多实现</li>
</ul></li>
<li>JDK8新特性</li>
<li>JDK9新特性</li>
</ul></li>
<li><p>排错 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(x); <span class="comment">// 编译报错，变量不明确</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> C().pX();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Playable</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bounceable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Rollable</span> <span class="keyword">extends</span> <span class="title">Playable</span>, <span class="title">Bounceable</span> </span>&#123;</span><br><span class="line">	Ball ball = <span class="keyword">new</span> Ball(<span class="string">&quot;PingPang&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">implements</span> <span class="title">Rollable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Ball</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ball = <span class="keyword">new</span> Ball(<span class="string">&quot;Football&quot;</span>); </span><br><span class="line">		<span class="comment">// interface中声明和初始化的ball为常量，不可赋值，此处错误</span></span><br><span class="line">		System.out.println(ball.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li><p>static修饰的属性，相较于实例变量，有哪些特别之处</p>
<ul>
<li>随着类的加载而加载，早于对象的创建，只要权限允许，可通过对象.属性的方式进行调用，存在于方法区的静态域中。</li>
</ul></li>
<li><p>final可用来修饰那些结构，分别表示什么意思</p>
<ul>
<li>修饰类（不可继承）、方法（不可重写）、属性（常量）、局部变量（显式初始化、构造器、代码块）</li>
</ul></li>
<li><p>代码实现单例模式的饿汉式和懒汉式</p></li>
<li><p>类的属性赋值位置有哪些？先后顺序为？</p>
<ul>
<li>默认初始化 - 显式初始化 / 代码块 - 构造器 - 创建对象后采用对象.属性或对象.方法方式赋值</li>
</ul></li>
<li><p>abstract能修饰那些结构？修饰以后，有什么特点？</p>
<ul>
<li>abstract可修饰类、方法
<ul>
<li>抽象类无法直接创建对象，必须要被继承并重写内部的所有抽象方法才能创建对象</li>
<li>抽象方法无方法体，只定义了一种功能的标准，具体的执行过程，需要子类去实现</li>
</ul></li>
</ul></li>
<li><p>接口是否能继承接口？抽象类是否能实现接口？抽象类是否能继承非抽象的类</p>
<ul>
<li>接口可以继承接口，且可以多继承</li>
<li>抽象类可以实现接口</li>
<li>抽象类可以继承非抽象的类</li>
</ul></li>
<li><h2 id="声明抽象类并包含抽象方法测试类中创建一个继承抽象类的匿名子类对象">声明抽象类，并包含抽象方法，测试类中创建一个继承抽象类的匿名子类对象</h2></li>
<li><p>抽象类和接口有哪些共同点和区别？</p>
<ul>
<li>抽象类和接口都无法直接创建对象，都可被继承</li>
<li>抽象类有构造器，接口不能声明构造器；单继承 vs 多继承；</li>
</ul></li>
<li><p><strong>如何创建静态成员内部类和非静态成员内部类的对象</strong>？</p>
<ul>
<li>静态成员内部类的对象：外部类.内部类 引用名 = new 外部类.内部类();</li>
<li>非静态成员内部类对象：外部类.内部类 引用名 = 外部类对象名.new.(外部类.)内部类();</li>
</ul></li>
<li><p>static、final、abstract分别能用来修饰什么？联系和区别总结。</p></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章 面向对象编程-中</title>
    <url>/2021/11/30/Coding/Java/05%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%AD/</url>
    <content><![CDATA[<h1 id="第5章面向对象编程-中">第5章、面向对象编程-中</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>目录</li>
<li>一、面向对象的特征之二：继承性</li>
<li>二、方法的重写（override /overwrite）</li>
<li>三、super 关键字</li>
<li>四、子类对象实例化的全过程</li>
<li>五、面向对象特征之三：多态性（重难点）</li>
<li>六、Object 类的使用</li>
<li>七、包装类的使用</li>
<li>面试题</li>
<li>每日一考</li>
</ol>
<span id="more"></span>
<h2 id="一面向对象的特征之二继承性">一、面向对象的特征之二：继承性</h2>
<ol type="1">
<li>继承的好处：
<ul>
<li>减少代码冗余，提高代码复用性</li>
<li>便于功能扩展</li>
<li>为<strong>多态性</strong>的使用提供前提</li>
</ul></li>
<li>继承性格式：class A extends B{ ... }
<ul>
<li>A：子类、派生类、subclass</li>
<li>B：父类、超类、基类、superclass</li>
<li>一旦子类A继承父类B后，字类A中就获取了父类B中声明的所有属性和方法。特别的，父类中声明为私有的属性和方法，子类继承父类后，仍然认为获取了父类中私有的结构，只是因为封装性的影响，使得字类不能直接调用父类的结构而已。（继承是能不能拿到的问题，封装是能不能使用的问题）</li>
<li>子类继承父类后，还可以声明自己特有的属性或方法，实现功能的扩展</li>
<li>子类与父类的关系，不同于数学上子集和集合的关系</li>
<li>extends：延展、扩展</li>
</ul></li>
<li>Java中关于继承性的规定
<ul>
<li>一个类可被多个类继承</li>
<li>一个类只能有一个父类：Java中<strong>类的单继承性</strong></li>
<li>子父类是相对的，支持多层继承（直接父类、间接父类）
<ul>
<li>字类直接继承的父类：直接父类</li>
<li>子类间接继承的父类：间接父类</li>
</ul></li>
<li>字类继承父类后，就获取了直接父类和所有间接父类中声明的属性和方法</li>
</ul></li>
<li>如果没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类。所有的类（除java.lang.Object类）都直接或间接的继承于java.lang.Object类，意味着所有的Java类都具有java.lang.Object类声明的功能</li>
</ol>
<h3 id="附eclipse的debug如何调试程序">附：Eclipse的Debug，如何调试程序</h3>
<ul>
<li>System.out.println();</li>
<li>Eclipse的Debug调试</li>
</ul>
<h2 id="二方法的重写override-overwrite">二、方法的重写（override / overwrite）</h2>
<ol type="1">
<li>重写：字类继承父类后，可对父类中同名同参数的方法进行覆盖操作</li>
<li>应用：重写后，当创建子类对象后，<strong>通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类的方法</strong></li>
<li>面试题：区分方法的重载与重写
<ul>
<li>重载：除参数列表不同不同外，方法名、权限等相同</li>
</ul></li>
<li>重写的规定
<ul>
<li>方法的声明：权限修饰符 返回值类型 方法名(形参列表) { //方法体 }</li>
<li>约定俗成：子类中的叫“重写的方法”；父类中的叫“被重写的方法”</li>
<li>子类重写的方法的方法名和形参列表 与 父类被重写的方法的方法名和形参列表相同</li>
<li>子类重写的方法的权限修饰符 不小于 父类被重写的方法的权限修饰符（子类重写方法的可见性要高于父类的被重写方法）
<ul>
<li>子类不能重写父类中声明为private权限的方法（或者说 子类中与父类声明为private方法同名同参数的方法不能成为重写）</li>
</ul></li>
<li>返回值类型
<ul>
<li>父类中被重写方法返回值类型为void，则子类重写方法返回值类型只能是void</li>
<li>父类中被重写方法返回值类型为A类型，则子类重写方法返回值类型可以是A类型或A类型的子类</li>
<li>父类中被重写方法返回值类型为基本数据类型，则子类重写方法返回值类型必须是相同的基本数据类型</li>
</ul></li>
<li>子类中重写的方法抛出的异常类型不大于父类中被重写的方法抛出的异常类型</li>
<li>子类和父类中同名同参数的方法要么都声明为非static的（重写），要么都声明为static（不是重写，static方法不能覆盖 是随着类的加载而加载的）</li>
</ul></li>
</ol>
<h2 id="三super关键字">三、super关键字</h2>
<ol type="1">
<li>super理解为：父类的</li>
<li>super可用来显式调用父类中的属性、方法、构造器</li>
<li>super的使用，调用父类的属性或方法
<ul>
<li>可在子类的方法或构造器中，通过使用“super.属性”或“super.方法”的方式，显式的调用父类中声明的属性或方法。但通常习惯省略“super.”</li>
<li>特殊情况：当子类和父类中定义了同名的属性时，如想在子类中调用父类中声明的属性，则必须显式的使用“super.属性”的方式，表明调用的是父类中声明的属性。</li>
<li>特殊情况：当子类重写了父类方法后，若想在子类方法中调用父类中被重写的方法时，则必须显式的“super.方法”的方式，表明调用的是父类中被重写的方法。</li>
</ul></li>
<li>super调用父类的构造器
<ul>
<li>可在子类的构造器中显式的使用“super(形参列表)”的方式调用父类中生命的指定的构造器</li>
<li>“super(形参列表)”的使用必须声明在子类构造器的首行</li>
<li>在类的构造器中，针对于"this(形参列表)"或“super(形参列表)”只能二选一，不能同时出现</li>
<li>在构造器函数体首行，没有显式调用"this(形参列表)"和“super(形参列表)”，则默认调用的是父类中的空参构造器（ 即super() ）【一个类被继承时，父类中需要有空参构造器（定义有参构造器前需显式定义空参构造器，否则只有有参构造器时编译器将不会自动添加空参构造器），否则子类中显式定义的构造器会报错、或无显式定义构造器的子类定义处报错.若不想在父类中显式声明无参构造器，则可在子类中显式调用父类的有参构造器】【一个类中有n个构造器，则最多n-1个构造器使用this(形参列表)，剩下的那个使用的是super(形参列表)】</li>
<li>在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表) ”，调用父类的构造器。【子类中会有父类中的属性、方法，是因为调用了super(形参列表)】</li>
</ul></li>
</ol>
<h2 id="四子类对象实例化的全过程">四、子类对象实例化的全过程</h2>
<ul>
<li>从结果看：子类继承父类后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性</li>
<li>从过程看：当通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止，正因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑调用</li>
<li>明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终只是创建过一个对象，即为new的子类对象【构造器负责类中成员变量的初始化】</li>
</ul>
<h2 id="五面向对象特征之三多态性重难点">五、面向对象特征之三：多态性（重难点）</h2>
<h3 id="核心内容">核心内容</h3>
<ol type="1">
<li>多态性理解：一个事物的多种形态</li>
<li>多态性是什么：对象的多态性，父类的引用指向子类的对象（或子类对象赋给父类的引用）</li>
<li>多态性的使用：创建的对象调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法（<strong>虚拟方法调用（Virtual Method Invocation）</strong>）
<ul>
<li>ClassA a = new ClassB(); //A为B的父类</li>
<li>有了对象多态性后，在编译期，只能调用父类中声明的方法，但在运行期，实际执行的是子类重写父类的方法。【总结：编译看左边，运行看右边】对象a无法调用子类ClassB中单独定义的方法</li>
</ul></li>
<li>多态性使用前提
<ul>
<li>类的继承关系</li>
<li>方法的重写</li>
</ul></li>
<li>对象的多态性只适用于重写方法，不适用于同名同类型的属性（属性不构成重写）</li>
<li>虚拟方法：
<ul>
<li>子类中定义了与父 同名参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</li>
<li>虚拟方法调用的过程也可称为<strong>动态绑定</strong>，虚方法动态绑定的子类重写的方法</li>
<li>重载在方法调用之前，编译器就已经确定了所要调用的方法，称为“<strong>早绑定</strong>”或“<strong>静态绑定</strong>”；而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，称为“<strong>晚绑定</strong>”或“<strong>动态绑定</strong>”</li>
</ul></li>
</ol>
<h3 id="instanceof操作符">instanceof操作符</h3>
<p>有了对象的多态性后，内存中实际上是加载了子类特有的属性和方法的，但由于变量声明为父类类型，导致编译时只能允许调用父类中生命的属性和方法，子类中特有的属性和方法不能调用。</p>
<ol type="1">
<li>如何调用子类特有的属性和方法
<ul>
<li>强制类型转换（向下转型）：使用强转时可能出现ClassCastException的异常（编译无报错，运行报错） <img src="/2021/11/30/Coding/Java/05%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%AD/63%20Day%20-%2002.png" alt="向上转型与向下转型"></li>
<li>instanceof关键字（先判断后再强制类型转换）
<ul>
<li>a instanceof A; // 判断对象a是否是类型A的实例，如是则返回true，否则返回false</li>
<li>为了避免向下转型时出现ClassCastException异常，在向下转型前先进性instanceof的判断，一旦返回true就可进行向下转型，否则不能进行向下转型</li>
<li>已知a为A的实例对象，若a instanceof B也为true，则类型B为类型A的父类</li>
</ul></li>
</ul></li>
<li>笔试题 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ProgramExam;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldMethodTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Sub s = <span class="keyword">new</span> Sub();</span><br><span class="line">		System.out.println(s.count); <span class="comment">//20</span></span><br><span class="line">		s.display(); <span class="comment">//20</span></span><br><span class="line">		</span><br><span class="line">		Base b = s;</span><br><span class="line">		<span class="comment">// 对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同</span></span><br><span class="line">		System.out.println(b == s); <span class="comment">//true</span></span><br><span class="line">		System.out.println(b.count);<span class="comment">//10 声明为什么类型就去找那个类型所属的属性</span></span><br><span class="line">		b.display();<span class="comment">//20 重写的多态性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>若子类重写了父类方法，就意味着子类中定义的方法彻底覆盖了父类中的同名方法，系统将不可能把父类里的方法转移到子类中。编译看左边，运行看右边</li>
<li>对于实例变量则不存在这种现象，即使子类中定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。</li>
</ul>
<h2 id="六object类的使用">六、Object类的使用</h2>
<ol type="1">
<li>Object类是所有Java类的根父类</li>
<li>若在类的声明中未使用extends关键字知名其父类，则默认父类为java.lang.Object类</li>
<li>Object类中的功能（属性、方法）就具有通用性
<ul>
<li>无属性</li>
<li>方法：equals() / toString() / getClass() / hashCode() / clone() / finalize() / wait() / notify() / notifyAll()</li>
</ul></li>
<li>== 和equals()的区别：见《面试题》部分6.</li>
<li>Object类中的toString()的使用
<ul>
<li>当输出对象的引用时，实际上是调用当前对象的toString()方法（但当引用为Null时，直接输出引用为null，但调用toString()方法再输出则会出现NullPointerException异常） <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>像String、Date、File、包装类等都重写了Object类中的toString()方法，使得在调用toString()方法时，返回“实体内容”信息</li>
<li>自定义类也可重写toString()方法，当调用此方法时，返回对象的“实体内容”。</li>
<li>source --&gt; Generate toString()自动生成toString()方法</li>
</ul></li>
</ol>
<h2 id="七包装类的使用">七、包装类的使用</h2>
<ol type="1">
<li>java中的JUnit单元测试
<ul>
<li>选中当前工程，右键选择--&gt;build path - add libraries - JUnit 4 - 下一步</li>
<li>创建Java类，进行单元测试
<ul>
<li>此时的Java类要求：
<ul>
<li>此类是public的</li>
<li>此类提供公共的无参构造器</li>
</ul></li>
</ul></li>
<li>此类的单元测试方法
<ul>
<li>测试方法要求：方法的权限是public，没有返回值类型，没有形参</li>
</ul></li>
<li>此单元测试方法上需声明注解：<span class="citation" data-cites="Test">@Test</span>，并在单元测试类中导入：import org.junit.Test;</li>
<li>声明完成单元测试方法后，即可在方法体内测试相关代码</li>
<li>写完方法体代码后，左键双击选中单元测试方法名，右键，run as - JUnit Test</li>
<li>说明：
<ul>
<li>若执行结果没有任何异常，绿条</li>
<li>若执行结果出现异常，红条</li>
</ul></li>
</ul></li>
<li>包装类的使用
<ul>
<li>Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量<strong>具有类的特征</strong></li>
<li>基本数据类型、包装类、String三者之间的相互转换【掌握】
<ul>
<li>基本数据类型和包装类
<ul>
<li>基本数据类型--&gt;包装类：调用包装类的构造函数</li>
<li>包装类--&gt;基本数据类型：调用包装类的XxxValue()</li>
<li>JDK 5.0新特性：<strong>自动装箱 与 自动拆箱</strong>
<ul>
<li>自动装箱 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">Integer in1 = num;</span><br></pre></td></tr></table></figure></li>
<li>自动拆箱 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num2 = in1;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>基本数据类型和包装类 与 String之间的转换
<ul>
<li>基本数据类型不能直接转换为String类型，但可通过连接运算(String s = num + "")实现转换；或调用String重载的<strong>valueOf(Xxx xxx)</strong></li>
<li>String转换为基本数据类型及包装类：调用包装类的<strong>parseXxx()</strong>（int num = Integer.parseInt(str);）可能会报NumberFormatException异常</li>
</ul></li>
</ul></li>
<li>包装类练习题10 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wrappertestpackage;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">   <span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Practice10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 1. 从键盘读入学生成绩</span></span><br><span class="line">           Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 2. 创建Vector对象，存储学生成绩</span></span><br><span class="line">           Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 找出成绩最高分</span></span><br><span class="line">           <span class="keyword">int</span> maxScore = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;请输入学生成绩（以复数代表输入结束）&quot;</span>);</span><br><span class="line">               <span class="keyword">int</span> score = scan.nextInt();</span><br><span class="line">               <span class="keyword">if</span>(score &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt; <span class="number">100</span>)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;输入数据非法，请重新输入。&quot;</span>);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//JDK5.0前</span></span><br><span class="line">   <span class="comment">//			Integer inScore = new Integer(score);</span></span><br><span class="line">   <span class="comment">//			v.addElement(inScore);</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// JDK5.0后</span></span><br><span class="line">               v.addElement(score);<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(maxScore &lt; score)&#123;</span><br><span class="line">                   maxScore = score;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">&quot;最高成绩为：&quot;</span> + maxScore);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.size(); i++)&#123;</span><br><span class="line">               <span class="keyword">char</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//JDK5.0前</span></span><br><span class="line">   <span class="comment">//			Object obj = v.elementAt(i);</span></span><br><span class="line">   <span class="comment">//			Integer inScore = (Integer)obj;</span></span><br><span class="line">   <span class="comment">//			int score = inScore.intValue();</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// JDK5.0后</span></span><br><span class="line">               <span class="keyword">int</span> score = (<span class="keyword">int</span>)v.elementAt(i);</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span>(maxScore - score &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">                   level = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxScore - score &lt;= <span class="number">20</span>)&#123;</span><br><span class="line">                   level = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxScore - score &lt;= <span class="number">30</span>)&#123;</span><br><span class="line">                   level = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   level = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               System.out.println(<span class="string">&quot;student-&quot;</span> + i + <span class="string">&quot; score is &quot;</span> + score + <span class="string">&quot;, grade is &quot;</span> + level);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h2 id="面试题">面试题</h2>
<ol type="1">
<li>区分方法的重写和重载</li>
</ol>
<ul>
<li>二者的概念</li>
<li>重载和重写的具体规则</li>
<li>重载不表现为多态性，重写表现为多态性</li>
</ul>
<ol start="2" type="1">
<li><p>谈谈你对多态性的理解</p>
<ul>
<li>实现代码的通用性</li>
<li>举例：Object类中定义的public boolean equals(Object obj) {}。JDBC：使用Java操作程序（获取数据库连接、CRUD）数据库（MySQL、Oracle、DB2、SQL Server）</li>
<li>抽象类和接口的使用体现了多态性（抽象类、接口不能实例化）</li>
</ul></li>
<li><p>多态性是编译时行为，还是运行时行为？</p></li>
</ol>
<ul>
<li><p>证明见InterviewTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ProgramExam;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试题：多态是编译时行为还是运行时行为？</span></span><br><span class="line"><span class="comment">//证明如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>  </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal eat food&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;cat eat fish&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Dog eat bone&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>&#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Sheep eat grass&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal  <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Cat ();</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Dog ();</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Sheep ();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> key = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(key);</span><br><span class="line"></span><br><span class="line">		Animal  animal = getInstance(key);</span><br><span class="line">		</span><br><span class="line">		animal.eat();</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>考察多态的笔试题目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ProgramExam;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考查多态的笔试题目：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Base base = <span class="keyword">new</span> Sub();</span><br><span class="line">		base.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		Sub s = (Sub)base;</span></span><br><span class="line"><span class="comment">//		s.add(1,2,3);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;base&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;sub_1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	public void add(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;sub_2&quot;);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4" type="1">
<li>为什么super(形参列表)和this(形参列表)调用语句不能同时在一个构造器中出现？</li>
</ol>
<ul>
<li>因为super(形参列表)和this(形参列表)的调用语句都得出现在首行</li>
</ul>
<ol start="5" type="1">
<li>为什么super(形参列表)或this(形参列表)调用语句只能作为构造器的第一句出现？</li>
</ol>
<ul>
<li>无论通过那个构造器创建子类对象，需要保证先初始化父类。目的：当子类继承父类后，继承父类中所有的属性和方法，因此子类有必要知道父类如何为对象进行初始化</li>
</ul>
<ol start="6" type="1">
<li>final、finally、finalize的区别？</li>
</ol>
<ul>
<li>final、finally为关键词，finalize为函数名</li>
<li>功能差别</li>
</ul>
<ol start="7" type="1">
<li>== 和equals()的区别</li>
</ol>
<ul>
<li>== 运算符
<ul>
<li>可用在基本数据类型变量和引用数据类型的变量中</li>
<li>若比较的是基本数据类型变量，则比较两个变量保存的数据是否相等（不一定类型相同）</li>
<li>若比较的是引用数据类型变量，则比较两个变量保存的地址是否相等（两个引用是否指向同一个实体 或 两个对象的地址是否相等）</li>
<li>补充：==符号使用时，必须保证符号左右两边的变量类型一致（不一定相同）</li>
</ul></li>
<li>equals()方法的使用
<ul>
<li>是一个方法，不是运算符</li>
<li>只适用于引用数据类型</li>
<li>Object类中equals()的定义 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明：Object类中定义的equals()和==的作用是相同的</span></span><br></pre></td></tr></table></figure></li>
<li>像String、Date、File、包装类等都重写了Object类的equals()方法。重写后，比较的不再是两个引用指向的地址是否相同，而是比较两个对象的“实体内容”是否相同</li>
<li>通常情况下，自定义类使用equals()时也通常是比较两个对象的“实体内容”是否相同。那么就需要对Object类中的equals()进行重写 - 重写的原则：比较两个对象的实体 - 注意属性中的String对象比较时要调用equals()函数，不可使用==号 - source --&gt; Generate hashCode() and equals()自动生成自定义类的equals()方法（实际开发中一般使用自动生成的） <img src="/2021/11/30/Coding/Java/05%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%AD/64%20Day%20-%2002.png" alt="重写equals()方法原则"> <img src="/2021/11/30/Coding/Java/05%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%AD/65%20Day%20-%2002.png" alt="【面试题】==和equals()方法的区别"></li>
</ul></li>
</ul>
<ol start="8" type="1">
<li>包装类面试题 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wrappertestpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Object o1 = <span class="keyword">true</span>? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">		System.out.println(o1); <span class="comment">// 1.0 [三元运算符的类型自动提升]</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Object o2;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(o2); <span class="comment">// 1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		Integer j = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">		System.out.println(i == j);<span class="comment">// false</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[]，保存了从-128~127范围内的整数。</span></span><br><span class="line">		<span class="comment">//如果使用自动装箱的方式，给Integer赋值的范围在-128~127范围内时，可以直接使用数组内的元素，不用再去new对象了，</span></span><br><span class="line">		<span class="comment">//目的是提高效率。因此，</span></span><br><span class="line">		</span><br><span class="line">		Integer m = <span class="number">1</span>;</span><br><span class="line">		Integer n = <span class="number">1</span>;</span><br><span class="line">		System.out.println(m == n); <span class="comment">// true</span></span><br><span class="line">		<span class="comment">//采用自动装箱且赋值整数在-128~127范围内时，引用是直接指向同一地址的</span></span><br><span class="line">		</span><br><span class="line">		Integer x = <span class="number">128</span>;</span><br><span class="line">		Integer y = <span class="number">128</span>;</span><br><span class="line">		System.out.println(x == y);<span class="comment">// false</span></span><br><span class="line">		<span class="comment">//而当赋值整数超出这个范围时，自动装箱需要去new对象，因此两个引用的地址不相同</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li>什么是多态性？什么是虚拟方法调用？
<ul>
<li>对象的多态性：父类的引用指向子类的对象</li>
<li>调用方法时，编译看左边，运行看右边。在编译期，只能调用父类中声明的方法，但在运行期，实际执行的是子类重写父类的方法</li>
</ul></li>
<li>方法重写的具体规则有哪些？
<ul>
<li>继承关系</li>
<li>同名同参数的方法</li>
<li>权限修饰符</li>
<li>返回值类型</li>
<li>抛出的异常</li>
</ul></li>
<li>super调用构造器，有哪些具体的注意点
<ul>
<li>构造器中没有显式调用super(形参列表)和this(形参列表)时，构造器中会自动调用父类的空参构造器</li>
</ul></li>
<li>如何实现向下转型？需要注意什么问题？如何解决此问题
<ul>
<li>使用强转符(); 有可能出现ClassCastException异常；使用instanceof运算符</li>
</ul></li>
<li>==和equals()有什么区别？
<ul>
<li>==在比较基本数据类型变量时，比较变量存储的值；比较引用数据类型变量时，比较的是引用指向的地址是否相同；equals()为一个方法，只能用于引用数据类型，默认的equals()和==同样比较的是引用指向的地址，String、Date、包装类等类型的equals()进行了重写，比较的是两个对象的“实体内容”，自定义类通常比较的是“实体内容”，那么也需要重写equals()方法</li>
<li>回答套路：1. 直接描述，直到无法描述；2. 不记得的知识点，描述使用情景（表示用过，而不是死记硬背）</li>
</ul></li>
<li>写出8种基本数据类型及其对应的包装类</li>
<li>基本数据类型、包装类与String三者之间如何转换
<ul>
<li>自动装箱、自动拆箱</li>
<li>基本数据类型、包装类 --&gt; String: valueOf(Xxx xxx)</li>
<li>String --&gt; 基本数据类型、包装类：parseXxx(String s)</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章 面向对象编程-上</title>
    <url>/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="第4章面向对象编程-上">第4章、面向对象编程-上</h1>
<h2 id="学习面向对象内容的三条主线">学习面向对象内容的三条主线：</h2>
<ol type="1">
<li><span class="math inline">\(Java\)</span>类及类的成员：属性、方法、构造器；代码块、内部类（<span class="math inline">\(Java\)</span>两大要素：类、对象）</li>
<li>面向对象的三大特征：封装性、继承性、多态性（、抽象性）（关注对应代码落地）</li>
<li>其他关键字：<span class="math inline">\(this\)</span>、<span class="math inline">\(super\)</span>、<span class="math inline">\(static\)</span>、<span class="math inline">\(final\)</span>、<span class="math inline">\(abstract\)</span>、<span class="math inline">\(interface\)</span>、<span class="math inline">\(package\)</span>、<span class="math inline">\(import\)</span>等</li>
</ol>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、面向过程与面向对象</li>
<li>二、Java 基本元素：类和对象</li>
<li>三、对象的创建和使用</li>
<li>四、类的成员之一：属性</li>
<li>五、类的成员之二：方法</li>
<li>六、再谈方法</li>
<li>七、OOP 特征之一：封装与隐藏</li>
<li>八、类的成员之三：构造器（构造方法，constructor）</li>
<li>扩展：JavaBean</li>
<li>扩展：UML 类图</li>
<li>九、关键字：this</li>
<li>十、关键字：package、import</li>
<li>每日一考（构造器、this、package、import）</li>
<li>接下来是：项目二</li>
</ol>
<span id="more"></span>
<h2 id="一面向过程与面向对象">一、面向过程与面向对象</h2>
<ol type="1">
<li><p>面向过程（<span class="math inline">\(POP:\)</span><span class="math inline">\(Procedure\)</span> <span class="math inline">\(Oriented\)</span> <span class="math inline">\(Programming\)</span>）与面向对象（<span class="math inline">\(OOP:\)</span><span class="math inline">\(Object\)</span> <span class="math inline">\(Oriented\)</span> <span class="math inline">\(Programming\)</span>）</p>
<ul>
<li><p>二者都是一种思想，面向对象是相对于面向过程而言的。</p>
<ul>
<li>面向过程，强调的是<strong>功能行为</strong>，以函数为最小单位，考虑<strong>怎么做</strong>。</li>
<li>面向对象，将功能封装进对象，强调<strong>具备了功能的对象</strong>，以类/对象为最小单位，考虑<strong>谁来做</strong></li>
</ul></li>
<li><p>举例：人把大象装进冰箱</p>
<ul>
<li><p>面向过程：①把冰箱门打开；②抬起大象，塞进冰箱；③把冰箱门关闭</p></li>
<li><p>面向对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">人&#123; </span><br><span class="line">	打开(冰箱)&#123;</span><br><span class="line">		冰箱.开门(); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	抬起(大象)&#123;</span><br><span class="line">		大象.进入(冰箱);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	关闭(冰箱)&#123;</span><br><span class="line">		冰箱.关门();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">冰箱&#123;</span><br><span class="line">	开门()&#123;...&#125;</span><br><span class="line">	关门()&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">大象&#123;</span><br><span class="line">	进入(冰箱) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>面向对象的三大特征</p>
<ul>
<li>封装（<span class="math inline">\(Encapsulation\)</span>）</li>
<li>继承（<span class="math inline">\(Inheritance\)</span>）</li>
<li>多态（<span class="math inline">\(Polymorphism\)</span>）</li>
</ul></li>
<li><p>面向对象的思想概述</p>
<ul>
<li>程序员从面向过程的<strong>执行者</strong>转化为了面向对象的<strong>指挥者</strong></li>
<li>面向对象分析方法分析问题的思路和步骤
<ul>
<li>根据问题需要，选择问题所针对的现实世界中的实体</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类</li>
<li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义，即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构</li>
<li>将类实例化成计算机世界中的对象，对象是计算机世界中解决问题的最终工具</li>
</ul></li>
</ul></li>
</ol>
<h2 id="二java基本元素类和对象">二、<span class="math inline">\(Java\)</span>基本元素：类和对象</h2>
<ol type="1">
<li><p>面向对象的思想概述</p>
<ul>
<li>类（<span class="math inline">\(Class\)</span>）和对象（<span class="math inline">\(Object\)</span>）是面向对象的核心概念
<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义。例如水果、花、人，其在代码上的体现类似于<span class="math inline">\(int\)</span>、<span class="math inline">\(char\)</span>、<span class="math inline">\(String\)</span>。</li>
<li>对象是实际存在的该事物的个体，也被称为实例（<span class="math inline">\(Instance\)</span>）。例如苹果、玫瑰花、某个具体的人，在代码上的体现类似于某个数据类型声明的变量。</li>
<li>面向对象程序设计的重点是<strong>类的设计</strong>；类的设计，其实就是<strong>类的成员的设计</strong>。</li>
</ul></li>
<li>“万事万物皆对象”
<ul>
<li>Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构
<ul>
<li>Scanner、String等</li>
<li>文件，File</li>
<li>网络资源，URL</li>
</ul></li>
<li>涉及到Java语言与前端Html、后端数据库交互时，前后端的结构在Java层面交互时都体现为类和对象</li>
</ul></li>
</ul></li>
<li><p><span class="math inline">\(Java\)</span>类及类的成员</p>
<ul>
<li>Java代码世界是由诸多个不同功能的类构成的</li>
<li>Java中常见的类成员有：
<ul>
<li>属性 = 成员变量 = field = 域、字段，对应类中的成员变量</li>
<li>方法 = 成员方法 = 函数 = method，对应类中的成员方法</li>
</ul></li>
</ul></li>
</ol>
<h2 id="三对象的创建和使用">三、对象的创建和使用</h2>
<ol type="1">
<li><p>对象创建：<code>类名 对象名 = new 类名()</code>;</p>
<ul>
<li>创建类的对象 = 类的实例化 = 实例化类</li>
</ul></li>
<li><p>类和对象的使用（面向对象思想落地的实现）</p>
<ul>
<li>创建类，设计类的成员</li>
<li>创建类的对象</li>
<li>通过<code>"对象.属性"</code>或<code>"对象.方法"</code>调用对象的结构</li>
</ul></li>
<li><p>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性（非static），修改其中一个对象的属性不影响另一个对象的属性值。</p></li>
<li><p>对象的内存解析</p></li>
</ol>
<figure>
<img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/62%20Day4%20-%2001.png" alt="对象的内存解析"><figcaption aria-hidden="true">对象的内存解析</figcaption>
</figure>
<p>内存解析的说明：引用数据类型的变量只可能存两类值：null 或 地址值（含变量的类型）</p>
<h2 id="四类的成员之一属性">四、类的成员之一：属性</h2>
<ul>
<li>属性（成员变量）VS 局部变量
<ul>
<li>相同点
<ul>
<li>定义格式：数据类型 变量名 = 变量值;</li>
<li>先声明后使用</li>
<li>都有其对应的作用域</li>
</ul></li>
<li>不同点
<ul>
<li>在类中声明的位置不同：
<ul>
<li>属性直接定义在类的一对{}中、方法体外；</li>
<li>局部变量是声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量。</li>
</ul></li>
<li>权限修饰符不同：
<ul>
<li>属性：可在声明属性时，指明其权限、使用权限修饰符（常见修饰符：private、public、缺省、protected）</li>
<li>局部变量：不可使用权限修饰符，只能用final（其权限可由方法修饰符体现）</li>
</ul></li>
<li>默认初始化值
<ul>
<li>属性：根据其类型，都有其初始化值<br> 整形（byte、short、int、long）：0<br> 浮点型（float、double）：0.0<br> 字符型（char）：0或'000'<br> 布尔型（boolean）：false<br> 引用数据类型（类、接口、数组）：null<br></li>
<li>局部变量：没有默认初始化值，在调用局部变量前必须要显式赋值（特别的，形参在调用时赋值即可）。</li>
</ul></li>
<li>在内存中加载的位置
<ul>
<li>属性：加载到堆空间中（非static）</li>
<li>局部变量：加载到栈空间</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="五类的成员之二方法">五、类的成员之二：方法</h2>
<ul>
<li><p>方法：描述类应该具有的功能</p>
<ul>
<li><p>方法的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名([形参列表])&#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>说明</p>
<ul>
<li>权限修饰符：private、public、缺省、protected</li>
<li>返回值类型：有返回值 VS 无返回值
<ul>
<li>如方法有返回值，则必须在方法声明时，指定返回值类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量</li>
<li>如方法无返回值，则方法声明时使用void来表示。无返回值的方法中无需使用return，但可使用“return;”结束方法。（return后不能直接声明其他语句）</li>
</ul></li>
<li>方法名：标识符，遵循标识符的命名规则和规范，“见名知意”</li>
<li>形参列表：
<ul>
<li>方法可定义0个、1个或多个形参</li>
<li>格式：<code>数据类型1 形参1, 数据类型2 形参2, ...</code></li>
</ul></li>
<li>方法体：方法功能的体现。</li>
</ul></li>
<li><p>方法的使用中，可调用当前类的属性和方法。方法中不能定义方法</p></li>
</ul></li>
<li><p>练习</p>
<ol type="1">
<li>编写教师类和学生类，并通过测试类创建对象进行测试。</li>
<li>创建一个Person类，其定义如下：要求(1)创建Person类的对象，设置该对象的name、age、sex属性，调用study方法，输出字符串"studying"，调用showAge()方法显示age值，调用addAge()方法给对象的age属性增加2岁；(2)创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123; <span class="comment">//测试类</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">          <span class="comment">//构造Person类的对象</span></span><br><span class="line">          Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">          <span class="comment">//调用对象的结构：属性和方法</span></span><br><span class="line">          <span class="comment">//调用属性：“对象.属性”</span></span><br><span class="line">          p1.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">          p1.age = <span class="number">18</span>;</span><br><span class="line">          p1.sex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//调用方法：“对象.方法”</span></span><br><span class="line">          p1.study();</span><br><span class="line">          p1.showAge();</span><br><span class="line">          System.out.println(p1.addAge(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">          Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">          p2.name = <span class="string">&quot;sam&quot;</span>;</span><br><span class="line">          p2.age = <span class="number">12</span>;</span><br><span class="line">          p2.sex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//调用方法：“对象.方法”</span></span><br><span class="line">          p2.study();</span><br><span class="line">          p2.showAge();</span><br><span class="line">          System.out.println(p2.addAge(-<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; <span class="comment">//Person类</span></span><br><span class="line">      String name;</span><br><span class="line">      <span class="keyword">int</span> age;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * sex: 0 - Female; 1 - Male;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;studying&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(age);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addAge</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">          age += i;</span><br><span class="line">          <span class="keyword">return</span> age;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>利用面向对象的编程方法，设计类Circle计算圆的面积。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleTest</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">          Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">          c1.radius = <span class="number">10</span>;</span><br><span class="line">          System.out.println(c1.area());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">double</span> radius;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>编写程序，声明一个method方法，在方法中打印一个10*8的*型矩阵，在main方法中调用该方法</li>
</ol>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exer3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Exer3 m = <span class="keyword">new</span> Exer3();</span><br><span class="line">        m.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++)</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="5" type="1">
<li>修改上一个程序，在method方法中，除打印10*8的*型矩阵外，再计算该矩形的面积，并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。</li>
</ol>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exer3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Exer3 m = <span class="keyword">new</span> Exer3();</span><br><span class="line">        <span class="keyword">int</span> area = m.method();</span><br><span class="line">        System.out.println(<span class="string">&quot;面积为：&quot;</span>+ area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++)</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>*<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="6" type="1">
<li>修改上一个程序，在method方法提供m和n两个参数，方法中打印m*n的*型矩阵，并计算该矩阵的面积，将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。</li>
</ol>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exer3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Exer3 m = <span class="keyword">new</span> Exer3();</span><br><span class="line">        <span class="keyword">int</span> area = m.method(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;面积为：&quot;</span>+ area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m*n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="7" type="1">
<li>对象数组题目：定义类Student，包含3个属性：学号number(int)，年级state(int)，成绩score(int)，创建20个学生对象，学号为1到20，年级和成绩由随机数确定。
<ul>
<li>问题1：打印出3年级(state为3)的学生信息</li>
<li>问题2：使用冒泡排序按学生成绩排序，并遍历所有学生信息</li>
<li>提示：
<ul>
<li>生成随机数：Math.random();返回值为double类型</li>
<li>四舍五入取整：Math.round(double d);返回值为long类型</li>
</ul></li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">                   <span class="comment">//此处只是开辟一块20个Student类型的对象数组空间，该空间的首地址值赋值给数组名stu</span></span><br><span class="line">                   <span class="comment">//定义对象数组后，每个数组元素初始值为null。</span></span><br><span class="line">                   <span class="comment">//如不为每个元素初始化将会在后面调用时产生NullPointerException异常</span></span><br><span class="line"> 		Student[] stu = <span class="keyword">new</span> Student[<span class="number">20</span>];</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;stu.length; i++)&#123;</span><br><span class="line">                   <span class="comment">//数组元素的类型为Student，故初始化时使用new Student()分配内存空间</span></span><br><span class="line">                   <span class="comment">//并将空间的地址赋值给元素</span></span><br><span class="line">                   <span class="comment">//String、int等类型无需new，是因为数组元素为基本数据类型或可以直接赋值（地址传递），</span></span><br><span class="line">                   <span class="comment">//如String s = &quot;15sadw&quot;;（字符串常量或变量传递给字符串数组元素是地址传递）</span></span><br><span class="line">                   <span class="comment">//int类型数组元素的值是直接存在堆的相应位置的，无需再次分配空间</span></span><br><span class="line">                   <span class="comment">//分配内存空间就要使用 new关键字，并且返回空间的首地址值</span></span><br><span class="line">                   <span class="comment">//而自定义的类声明的对象也可进行地址传递,但需要先new一个该类型的变量然后再地址传递，</span></span><br><span class="line">                   <span class="comment">//也可直接开辟一块内存空间（new Student()），并将该空间首地址值赋给数组元素</span></span><br><span class="line"> 		stu[i] = <span class="keyword">new</span> Student();</span><br><span class="line"> 			stu[i].setNumber(i+<span class="number">1</span>);</span><br><span class="line"> 			stu[i].setState((<span class="keyword">int</span>)Math.round((Math.random()*<span class="number">5</span>)));</span><br><span class="line"> 			stu[i].setScore((<span class="keyword">int</span>)Math.round((Math.random()*<span class="number">100</span>)));</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">//遍历输出</span></span><br><span class="line"> 		System.out.println(<span class="string">&quot;初始化：&quot;</span>);</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;stu.length; i++)&#123;</span><br><span class="line"> 			System.out.println(stu[i].getNumber() + <span class="string">&quot;\tis @ grade_&quot;</span> + stu[i].getState() + <span class="string">&quot;, score is &quot;</span> + stu[i].getScore());</span><br><span class="line"> 		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//输出年级为3的学生信息</span></span><br><span class="line"> 		System.out.println(<span class="string">&quot;3年级学生信息：&quot;</span>);</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;stu.length; i++)&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(stu[i].getState() == <span class="number">3</span>)</span><br><span class="line"> 				System.out.println(stu[i].getNumber() + <span class="string">&quot;\tis @ grade_&quot;</span> + stu[i].getState() + <span class="string">&quot;, score is &quot;</span> + stu[i].getScore());</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line">		<span class="comment">//冒泡排序</span></span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;stu.length; i++)&#123;</span><br><span class="line"> 			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;stu.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line"> 				<span class="keyword">if</span>(stu[j].getScore() &gt; stu[j+<span class="number">1</span>].getScore())&#123;</span><br><span class="line"> 					Student temp = <span class="keyword">new</span> Student();</span><br><span class="line"> 					temp = stu[j];</span><br><span class="line"> 					stu[j] = stu[j+<span class="number">1</span>];</span><br><span class="line"> 					stu[j+<span class="number">1</span>] = temp;</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">//遍历输出</span></span><br><span class="line">	System.out.println(<span class="string">&quot;排完序后：&quot;</span>);</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;stu.length; i++)&#123;</span><br><span class="line"> 			System.out.println(stu[i].getNumber() + <span class="string">&quot;\tis @ grade_&quot;</span> + stu[i].getState() + <span class="string">&quot;, score is &quot;</span> + stu[i].getScore());</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * 学号, int型</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="keyword">int</span> number;</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 年级, int型</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="keyword">int</span> state;</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * 分数, int型</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="keyword">int</span> score;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * </span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@Description</span> 获得学生的分数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@date</span> 2020年10月16日下午4:40:40</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@return</span> int型 分数</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> score;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * </span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@Description</span> 获得学生的学号</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@date</span> 2020年10月16日下午4:40:58</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@return</span> int型 学号</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> number;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * </span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@Description</span> 获得学生的年级</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@date</span> 2020年10月16日下午4:42:02</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@return</span> int型 年级</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> state;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * </span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@Description</span> 设置学生的成绩</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@date</span> 2020年10月16日下午4:51:16</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@param</span> score</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">this</span>.score = score;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * </span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@Description</span> 设置学生的学号</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@date</span> 2020年10月16日下午4:50:57</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span> 设置学生的年级</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span> 2020年10月16日下午4:51:31</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>每日一考</p></li>
</ul>
<ol type="1">
<li><p>面向对象思想编程内容的三条主线分别是什么</p>
<ul>
<li><span class="math inline">\(Java\)</span>类及类的成员：属性、方法、构造器、代码块、内部类</li>
<li>面向对象三大特征：封装性、继承性、多态性（，抽象性）</li>
<li>其他关键字：<span class="math inline">\(this\)</span>、<span class="math inline">\(super\)</span>、<span class="math inline">\(static\)</span>、<span class="math inline">\(final\)</span>、<span class="math inline">\(abstract\)</span>、<span class="math inline">\(interface\)</span>、<span class="math inline">\(package\)</span>、<span class="math inline">\(import\)</span>等</li>
</ul></li>
<li><p>面向对象的编程思想？【面试】</p></li>
<li><p>谈谈你对面向对象中类和对象的理解，并指出二者的关系<br> 面试中，先进行一些描述，然后再举出一些例子，但是举的例子应为开发场景中的例子（比如我们和控制台交互需要提供一个类，这个API给我们提供好了叫做Scanner类，这是类的概念。我们真正执行的时候需要一个Scanner对象，然后通过这个对象来调用他所定义的功能方法，去完成与控制台的交互）</p>
<ul>
<li>类：抽象的、概念上的内容</li>
<li>对象：实实在在存在的一个实体</li>
<li>对象是由类派生出来的（new出来的）</li>
</ul></li>
<li><p>面向对象思想的体现一：类和对象的创建和执行操作有那三步？</p>
<ul>
<li>创建类</li>
<li>类的实例化</li>
<li>调用对象的结构：“对象.属性”、“对象.方法”</li>
</ul></li>
<li><p>类的方法内是否可以定义变量？是否可以调用属性？是否可以定义方法？是否可以调用方法？</p>
<p>是，是，否，是</p></li>
</ol>
<h3 id="补jvm内存结构">补：JVM内存结构</h3>
<ul>
<li>编译完源程序后，生成一个或多个字节码文件。我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析</li>
</ul>
<figure>
<img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/JVM内存结构.jpg" alt="JVM内存结构"><figcaption aria-hidden="true">JVM内存结构</figcaption>
</figure>
<ul>
<li>各个结构
<ul>
<li>虚拟机栈即为平时提到的栈结构。将局部变量存放在栈结构中</li>
<li>堆，将new出来的结构（如数组、对象）加载在堆空间中。补充：对象的属性（非static）加载在堆空间中</li>
<li>方法区：类的加载信息（方法、代码块等）、常量池、静态域（static）</li>
<li>本地方法栈：调用本地C/C++时使用</li>
</ul></li>
</ul>
<h3 id="补匿名对象">补：匿名对象</h3>
<ol type="1">
<li><p>创建的对象没有显式的赋给一个变量名，即为匿名对象</p></li>
<li><p>特征：一个匿名对象只能使用一次。</p></li>
<li><p>使用：无需另外定义一个变量即可创建一个对象并使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exer_2_1</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">         System.out.println(p);</span><br><span class="line"></span><br><span class="line">         p.sendEmail();</span><br><span class="line">         p.playGame();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//匿名对象</span></span><br><span class="line">         <span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line">         <span class="keyword">new</span> Phone().showPrice();</span><br><span class="line">	</span><br><span class="line">         <span class="comment">//匿名对象的使用</span></span><br><span class="line">         PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line">         mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span></span>&#123;</span><br><span class="line">             phone.sendEmail();</span><br><span class="line">             phone.playGame();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;手机价格为：&quot;</span> + price);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="六再谈方法">六、再谈方法</h2>
<ol type="1">
<li><p>方法的重载（overload）</p>
<ul>
<li>重载的概念
<ul>
<li>在同一个类中，允许存在一个以上的同名方法，<strong>只要</strong>它们的参数个数或者类型不同即可。</li>
</ul></li>
<li>重载的特点：
<ul>
<li>与返回值类型无关，只看参数列表,且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</li>
<li><strong>两同一不同</strong>：同一个类、相同方法名；参数列表不同：参数个数或参数类型或不同类型的参数顺序不同</li>
<li><strong>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系</strong></li>
</ul></li>
<li>重载示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回两个整数的和</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+y;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//返回三个整数的和</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+y+z;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//返回两个小数的和</span></span><br><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+y;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在通过对象调用方法时，如何确定某一个指定的方法：方法名--&gt;参数列表</li>
</ul></li>
<li><p>可变形参的方法</p>
<ul>
<li>定义：JavaSE5.0中提供了Varargs(variable number of arguments)机制，<strong>允许直接定义能和多个实参相匹配的形参</strong>。从而可以用一种更简单的方式，来传递个数可变的实参。</li>
<li>使用：
<ul>
<li>格式：<code>数据类型 ... 变量名</code></li>
<li>当调用可变个数形参的方法时，传入的参数个数可以是0个、1个、2个...</li>
<li>可变个数形参的方法与本类中其他的方法名相同、形参不同的方法构成重载</li>
<li>可变个数形参的方法与本类中其他的方法名相同、形参相同的方法不构成重载。（5.0前使用数组传入多个参数(String[] args)；5.0后使用...表示可变个数参数(String ... args)，在形参变量的使用上和数组使用方式相同）</li>
<li>可变个数形参在方法的形参中，必须声明在末尾（防止编译器分不清参数该传给谁）</li>
<li>可变个数形参在方法的形参中，最多只能声明一个可变形参</li>
</ul></li>
</ul></li>
<li><p>方法参数的值传递机制（难重点）</p>
<ul>
<li>变量赋值：传递的是栈空间的值
<ul>
<li>如变量是基本数据类型，则赋值的是变量所保存的数据值</li>
<li>如变量是引用数据类型，则赋值的是变量所保存的数据地址值</li>
</ul></li>
<li>形参与实参
<ul>
<li>形参：方法定义时，声明的小括号内的参数</li>
<li>实参：方法调用时，实际传递给形参的数据</li>
</ul></li>
<li><strong>方法形参的传递机制：值传递（不是引用传递）</strong>
<ul>
<li>如参数是基本数据类型，则实参赋给形参的值是实参所保存的数据值</li>
<li>如参数是引用数据类型，则实参赋给形参的值是实参所保存的数据地址值</li>
</ul></li>
</ul></li>
<li><p>递归方法</p>
<ul>
<li>定义：一个方法体内调用它本身</li>
</ul></li>
<li><p>每日一考</p>
<ul>
<li>什么是方法的重载
<ul>
<li>两同一不同</li>
</ul></li>
<li>说明Java方法中的参数传递机制的具体体现
<ul>
<li>如参数为基本数据类型，则传递的是...</li>
<li>如参数是引用数据类型，则传递的是...</li>
</ul></li>
<li>成员变量和局部变量在声明的位置上、是否有默认初始化值上、是否能有权限修饰符修饰上、内存分配的位置上有何不同
<ul>
<li>成员变量声明在类中，有默认初始化值，可有权限修饰符，内存分配在堆中</li>
<li>局部变量声明在方法中，无默认初始化值，不可有权限修饰符，内存分配在栈中</li>
</ul></li>
<li>谈谈return关键字的使用
<ul>
<li>返回方法执行结果</li>
<li>结束方法执行</li>
</ul></li>
</ul></li>
<li><p>面试题</p>
<ul>
<li>方法的重载与重写的区别？</li>
<li>throws  throw</li>
<li>String  StringBuffer StringBuilder</li>
<li>Collection  Collections</li>
<li>final  finally </li>
<li>...相似的概念或类及方法及时总结</li>
</ul></li>
</ol>
<h2 id="七oop特征之一封装与隐藏">七、<span class="math inline">\(OOP\)</span>特征之一：封装与隐藏</h2>
<ol type="1">
<li>为什么要封装和隐藏？其作用和含义是什么？
<ul>
<li>我们程序设计追求“高内聚，低耦合”。
<ul>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li>低耦合 ：仅对外暴露少量的方法用于使用。</li>
</ul></li>
<li>隐藏对象内部的复杂性，只外公开简单接口。便于外界调用从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。 <strong>这就是封装性的设计思想</strong></li>
</ul></li>
<li>问题的引入：
<ul>
<li>当我们创建一个类的对象后，我们可以通过<code>"对象.属性"</code>的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约，但是除此之外，没有其他制约条件。而在实际问题中，我们往往需要给属性赋值加入额外的限制条件（实际问题的逻辑限制），这个条件不能在属性声明时体现，我们只能通过属性所在类中的方法进行限制条件的添加。</li>
<li>同时，我们需要避免用户再使用<code>"对象.属性"</code>的方式对属性进行无逻辑限制的赋值，因此需要将属性声明为私有的（private）</li>
<li>以上针对属性就体现了封装性</li>
</ul></li>
<li>封装性的体现（不等同于封装性，只是封装性的一个体现）
<ul>
<li>我们将类的属性私有化（private），同时，提供公共（public）的方法来获取（getXxx）和设置（setXxx）此属性的值</li>
</ul></li>
<li>封装性的其他体现：① 如上3；②不对外暴露的私有方法；③ 单例模式；④ 如果不希望类在包外被调用，可将类设置为缺省的。</li>
<li>封装性的体现，需要权限修饰符来配合
<ul>
<li>Java规定了4种权限修饰符（从小到大）：private、缺省、protected、public；四种范围：类内、同一个包内、不同包的字类内、同一工程内 <img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/Chap4.7%20-%201.bmp" alt="4种权限修饰符"></li>
<li>4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类
<ul>
<li><strong>修饰类的话：只能使用缺省、public</strong>【问题：public类可在同一工程中访问，那为什么不同包中重名的类可以同时存在。解答：因为权限修饰符只是表明可见性的大小，调用不同的类可以用包名去区别，public只是表明可以在工程中的任意位置调用，并不限制同名是否可以存在】</li>
</ul></li>
</ul></li>
<li>总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</li>
</ol>
<h2 id="八类的成员之三构造器构造方法constructor">八、类的成员之三：构造器（构造方法，constructor）</h2>
<ol type="1">
<li>构造器的作用（只要造对象就要用构造器）
<ul>
<li>创建对象</li>
<li>初始化对象的信息（属性或方法）</li>
</ul></li>
<li>构造器使用说明
<ul>
<li>如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器（该构造器权限和类的权限是相同的）(一个类中一定有构造器)</li>
<li>定义构造器的格式：权限修饰符 类名(形参列表) { }</li>
<li>一个类中定义的多个构造器，彼此构成重载</li>
<li><strong>一旦显式的定义了类的构造器，系统就不再提供默认的空参构造器</strong></li>
<li>一个类中至少会有一个构造器</li>
</ul></li>
<li>构造器与方法有一定的区别：构造器是用来创建对象的；而方法是由对象进行调用的</li>
<li>属性的赋值过程，赋值顺序为① - ② - ③ - ④，其中① - ② - ③是在对象实例出前执行，只执行一次，而④是可以重复多次执行的
<ul>
<li>① 默认初始化值</li>
<li>② 显式初始化</li>
<li>③ 构造器中初始化</li>
<li>④ 通过“对象.属性”或“对象.方法”进行复制</li>
</ul></li>
</ol>
<h2 id="扩展javabean">扩展：JavaBean</h2>
<p>JavaBean是一种Java语言写成的可重用组件</p>
<ol type="1">
<li>定义：
<ul>
<li>所谓JavaBean是值符合如下标准的Java类：
<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的set和get方法</li>
</ul></li>
</ul></li>
</ol>
<h2 id="扩展uml类图">扩展：UML类图</h2>
<figure>
<img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/Chap4.8%20-%201.bmp" alt="UML类图"><figcaption aria-hidden="true">UML类图</figcaption>
</figure>
<h2 id="九关键字this">九、关键字：<span class="math inline">\(this\)</span></h2>
<ul>
<li>this的使用：可用来调用属性、方法、构造器
<ul>
<li>其中，this可理解为当前<strong>对象</strong>（针对方法） 或 当前正在创建的对象（针对构造器）
<ul>
<li>在类的方法中，可使用“this.属性”或“this.方法”的方式调用当前对象的属性或方法。但是，在通常情况下，我们都省略“this.”。在特殊情况下：例如方法或构造器的形参和类的属性同名时，我们必须显式的使用“this.属性”的方式表明此变量是属性，而非形参。</li>
<li>在类的构造器中，可使用“this.属性”或“this.方法”的方式调用当前正在创建的对象的属性或方法。但是，在通常情况下，我们都省略“this.”。在特殊情况下：例如构造器的形参和类的属性同名时，我们必须显式的使用“this.属性”的方式表明此变量是属性，而非形参。</li>
</ul></li>
<li>this调用构造器的用法
<ul>
<li>在类的<strong>构造器中</strong>，可显式的使用“this(形参列表)”方式，调用本类中指定的其他构造器</li>
<li>构造器中不能通过“this(形参列表)”的方式调用自己</li>
<li>如果一个类中有n个构造器，则最多有n-1构造器中使用了“this(形参列表)”</li>
<li>规定：“this(形参列表)”必须声明在当前构造器的首行</li>
<li>构造器内部，最多只能声明一个“this(形参列表)”用来调用其他的构造器</li>
</ul></li>
</ul></li>
</ul>
<h2 id="十关键字packageimport">十、关键字：<span class="math inline">\(package\)</span>、<span class="math inline">\(import\)</span></h2>
<ol type="1">
<li>package关键字的使用
<ul>
<li>为了更好的实现项目中类的管理，提供了包的概念</li>
<li>使用package声明类或接口所属的包，声明在源文件中的首行</li>
<li>包属于标识符，遵循标识符的命名规则（见名知意）、规范（小写）</li>
<li>每“.”一次，就代表一层文件目录</li>
<li>补充：<strong>同一个包下，不可以命名同名的接口、类；不同包下可命名同名的接口或类</strong></li>
<li>JDK中主要的包介绍 <img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/Chap4.10%20-%201.bmp" alt="JDK中主要的包"></li>
</ul></li>
<li>MVC设计模式 <img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/Chap4.10%20-%202.bmp" alt="MVC设计模式"></li>
<li>import关键字的使用
<ul>
<li>在源文件中显式的使用import结构导入指定包下的类或接口</li>
<li>声明位置：在源文件中的包声明和类声明之间</li>
<li>如需导入多个结构，则并列写出即可；</li>
<li>可使用xxx.*的方式导入xxx包下的所有结构（类或接口）</li>
<li>如果使用的类或接口是java.lang包下的，则可省略import结构</li>
<li>如果使用的类或接口是本包下的，则可省略import结构</li>
<li>如果在源文件中，使用了不同包下的两个同名类，则必须至少有一个需要以全类名的方式（xxx.xxxx.xx.类名）调用</li>
<li>使用“xxx.*”的方式可以调用xxx包下的所有结构，但如果使用的是xxx子包下的结构则仍需显式使用“xxx.子包”结构导入</li>
<li>import static 可以导入指定类或接口<strong>中</strong>的静态结构（属性或方法）</li>
</ul></li>
</ol>
<h2 id="每日一考构造器thispackageimport">每日一考（构造器、this、package、import）</h2>
<ol type="1">
<li>构造器的作用是什么？使用中有哪些注意点（&gt;= 3条）
<ul>
<li>作用：创建对象、初始化对象信息</li>
<li>注意点：
<ul>
<li>当没有显式声明构造器时，类会提供了一个默认的无参构造器</li>
<li>一个类中定义的多个构造器，彼此构成重载</li>
<li><strong>一旦显式的定义了类的构造器，系统就不再提供默认的空参构造器</strong></li>
</ul></li>
</ul></li>
<li>关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序
<ul>
<li>① 默认值</li>
<li>② 显式初始化</li>
<li>③ 构造器初始化</li>
<li>④ 通过<code>“对象.属性”</code>或<code>“对象.方法”</code>的方式赋值</li>
<li>先后顺序是：① - ② - ③ - ④</li>
</ul></li>
<li>this关键字可用来调用那些结构，简单说明一下其使用
<ul>
<li>this可用来调用属性、方法、构造器</li>
<li>this代表的是 当前使用的对象 或 正在创建的对象。使用“this.属性”或“this.方法”的方式调用正在使用对象中的属性或方法。使用“this(形参列表)”方式调用与其形参列表匹配的构造函数</li>
</ul></li>
<li>java中目前学习涉及到的四种权限修饰符都有什么？并说明各自的权限范围
<ul>
<li>private、缺省、protected、public</li>
<li>private仅能在同一个类中可见</li>
<li>缺省仅能在同一个类或同一包下可见</li>
<li>protected仅能在同一个类、同一包、不同包下的子类中可见</li>
<li>public可在同一个类、同一包、不同包下的子类、同一工程中可见</li>
</ul></li>
</ol>
<h1 id="接下来是项目二">接下来是：项目二</h1>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章 Java数组</title>
    <url>/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="第3章-数组">第3章 数组</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、数组的概述</li>
<li>二、一维数组的使用</li>
<li>三、多维数组的概念</li>
<li>四、二维数组的使用</li>
<li>五、扩展</li>
<li>六、数组中常用的算法</li>
<li>七、Arrays 工具类的使用</li>
<li>八、数组中常见的异常</li>
</ol>
<span id="more"></span>
<h2 id="一数组的概述">一、数组的概述</h2>
<ol type="1">
<li><p>数组，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p></li>
<li><p>数组的常见概念</p>
<ul>
<li>数组名</li>
<li>下标（索引）</li>
<li>元素</li>
<li>数组的长度：元素的个数</li>
</ul></li>
<li><p>数组的特点</p>
<ul>
<li>元素排列是有序的</li>
<li>数组属于<strong>引用数据类型的变量</strong>。元素即可是基本数据类型、也可是引用数据类型</li>
<li>创建数组对象会在内存中开辟一整块连续的空间</li>
<li>数组的长度一旦确定，就不能修改</li>
</ul></li>
<li><p>数组的分类</p>
<ul>
<li>按维数：一维数组、二维数组、...</li>
<li>按元素的类型：基本数据类型元素的数组、引用数据类型元素的数组</li>
</ul></li>
</ol>
<h2 id="二一维数组的使用">二、一维数组的使用</h2>
<ol type="1">
<li><p>一维数组的声明和初始化</p>
<ul>
<li>声明：<code>基本数据类型[ ] 数组名;</code></li>
<li>初始化
<ul>
<li><strong>静态初始化</strong>：数组的初始化和数组元素的赋值操作同时进行
<ul>
<li>例：<code>int[ ] ids; ids = new int[ ]&#123;1001, 1002, 1003, 1004&#125;;</code></li>
</ul></li>
<li><strong>动态初始化</strong>：数组的初始化和数组元素的赋值操作分开进行
<ul>
<li>例：<code>String[ ] names = new String[5];</code></li>
</ul></li>
</ul></li>
<li>错误写法：
<ul>
<li><code>int[] arr1 = new int[];</code></li>
<li><code>int[2] arr2 = new int[2];</code></li>
<li><code>int[] arr3 = new int[3]&#123;1,2,3&#125;;</code></li>
</ul></li>
<li>总结：数组一旦初始化完成，其长度就确定了（初始化完成后需要开辟内存空间）</li>
</ul></li>
<li><p>如何调用数组指定位置的元素：通过角标的方式调用</p>
<ul>
<li>数组的角标（或索引）从0开始，到数组长度-1结束</li>
<li>如需获得String元素类型数组的每个元素中的单个字符，只需对元素调用charAt方法</li>
</ul></li>
<li><p>如何获取数组的长度：属性——length</p>
<ul>
<li>array.length</li>
</ul></li>
<li><p>如何遍历数组: for循环</p></li>
<li><p>数组元素的默认初始化值</p>
<ul>
<li>在分配了数组内存空间后，在没有对数组元素显式赋值时，元素具有默认值</li>
<li>数组元素是整型时：默认值为0</li>
<li>数组元素是浮点型时：默认值为0.0</li>
<li>数组元素是char型时：默认值为0</li>
<li>数组元素是boolean型：默认值为false</li>
<li>数组元素是引用数据类型时：null（关键字）</li>
</ul></li>
<li><p>数组的内存解析（内存结构在JVM规范中有讲解）</p>
<ul>
<li><p>内存简化结构结构有栈（stack）、堆（heap）、方法区（又分为常量池、静态域）</p>
<ul>
<li>栈中主要存放局部变量（放在方法中的变量都是局部变量）</li>
<li>堆中主要存放new出来的结构：对象、数组</li>
<li>常量池主要存放String</li>
<li>静态域主要存放static</li>
</ul></li>
<li><p>对于以下代码 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">String[] arr1 = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">arr1[<span class="number">1</span>] = <span class="string">&quot;刘德华&quot;</span>;</span><br><span class="line">arr1[<span class="number">2</span>] = <span class="string">&quot;张学友&quot;</span>;</span><br><span class="line">arr1 = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p></li>
<li><p>第1行代码执行时内存中的变化为：</p>
<ul>
<li>因为方法中的变量都是局部变量，因此在main方法中声明并初始化的arr变量首先加入到栈中</li>
<li>再经过初始化，就需要给数组分配内存空间。因为数组主要存放在堆中，因此会在堆中开辟一定长度的连续空间，并将这段空间的首地址存入栈中的arr变量，且空间中各元素均为0；之后再将初始化值赋给各元素。</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/55%20Day3%20-%2001.png" alt="第1行代码执行时内存中的变化"><figcaption aria-hidden="true">第1行代码执行时内存中的变化</figcaption>
</figure>
<ul>
<li>第2行代码执行时内存中的变化为：
<ul>
<li>基本和第1行代码执行时变化相同</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/56%20Day3%20-%2002.png" alt="第2行代码执行时内存中的变化"><figcaption aria-hidden="true">第2行代码执行时内存中的变化</figcaption>
</figure>
<ul>
<li>第3行代码执行时内存中的变化为：
<ul>
<li>根据arr1在栈中的值找到堆中的一块空间，在该空间中从首地址开始寻找角标个元素空间即是要调用的值空间。</li>
<li>然后将该空间的值改为指定值即可</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/57%20Day3%20-%2003.png" alt="第3行代码执行时内存中的变化"><figcaption aria-hidden="true">第3行代码执行时内存中的变化</figcaption>
</figure>
<ul>
<li>第4行代码执行时内存中的变化为：
<ul>
<li>栈中的变量仍为arr1，只是需在堆中再次新开辟一块空间，并将新开辟空间的首地址赋值给arr1。因此相当于只更改了栈中arr1的值</li>
<li>此时垃圾回收器将会在之后的一个不确定的时间把之前的数组空间进行回收。垃圾回收使用的算法为引用计数算法，即判断堆中的一块空间是否还有栈空间中的引用指过来。（当main函数执行完后，局部变量都将会依此出栈，垃圾回收器判断堆中的空间是否还有栈中空间引用它，对于出完栈的变量将会把它之前引用的空间释放）</li>
</ul></li>
</ul></li>
<li><p>练习<br> 升景坊单间短期出租4个月 ，550 元/月（水电煤公摊，网费 35 元/月），空调、卫生间厨房齐全。屋内均是 IT 行业人士，喜欢安静。 所以要求来租者最好是同或刚毕的年轻爱干净、行业人士，喜欢安静。所以要求来租者最好是同或刚毕的年轻爱干净、</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用执行程序的方式筛选IT人士</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span> &#125;;</span><br><span class="line">            <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span> &#125;;</span><br><span class="line">            String tel = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">                tel += arr[index[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot; 联系方式： &quot;</span> + tel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从键盘输入学生的成绩，找出最高分，并输出学生的成绩等级：<br> 成绩&gt;=最高分-10分 等级为A<br> 成绩&gt;=最高分-20分 等级为B<br> 成绩&gt;=最高分-30分 等级为C<br> 其他 等级为D</p>
<figure>
<img src="/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/60%20Day3%20-%2006.png" alt="题目程序实现"><figcaption aria-hidden="true">题目程序实现</figcaption>
</figure>
<blockquote>
<p>请输入学生人数：5<br> 请输入5个学生的成绩：<br> 15<br> 20<br> 25<br> 50<br> 70<br> 最高分为:70<br> student 0 score is 15 grade is D<br> student 1 score is 20 grade is D<br> student 2 score is 25 grade is D<br> student 3 score is 50 grade is B<br> student 4 score is 70 grade is A<br></p>
</blockquote></li>
</ol>
<h2 id="三多维数组的概念">三、多维数组的概念</h2>
<p>因为数组为引用数据类型,而数组元素可以是基本数据类型、也可是引用数据类型，引用数据类型的元素可以是引用数据类型，即可看成一维数组arr1作为另一个一维数组arr2的元素就是二维数组。其实，从数组底层的运行机制来看，是没有多维数组的，只是数组名指向的数组中的元素指向的又是一个一维数组。</p>
<h2 id="四二维数组的使用">四、二维数组的使用</h2>
<ol type="1">
<li><p>二维数组的声明和初始化</p>
<ul>
<li>二维数组初始化
<ul>
<li>静态初始化：<code>int[][] arr1 = new int[][]&#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125; &#125;;</code></li>
<li>动态初始化：<code>String[][] arr2 = new String[3] [2];或String[][] arr2 = new String[3] [];</code></li>
<li>其他正确写法：<code>int[] arr1[] = new int[][]&#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125; &#125;;</code>或<code>int arr1[][] = new int[][]&#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125; &#125;;</code>或<code>int arr1[][] = &#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125; &#125;;（叫做类型推断，该用法只能将声明和初始化写在一行时有用，分开写时是错误的）</code></li>
</ul></li>
</ul></li>
<li><p>如何调用数组指定位置的元素：通过角标的方式调用</p>
<ul>
<li>当数组初始化时没有给内层数组初始化，如<code>String[][] arr2 = new String\[3][];</code>若在后面需要调用arr2[1][0]时，需在调用之前再次初始化内层数组：arr2[1] = new String[4];</li>
</ul></li>
<li><p>如何获取数组的长度：属性——length</p>
<ul>
<li>array.length输出第一维数组的长度</li>
<li>array[0].length输出第二维（第1行）的数组长度</li>
</ul></li>
<li><p>如何遍历数组 两层for循环： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; arr[i].length; j++)&#123;</span><br><span class="line">		System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>数组元素的默认初始化值 规定：二维数组分为外层数组元素和内层数组元素，且初始化值一般都说的是动态初始化的元素值</p>
<ul>
<li>外层数组元素
<ul>
<li>在动态初始化后，默认值为地址值：结构为“[类型缩写@地址”，例如int型外层数组元素的值为[I@1586135，int型二维数组名的值为[[I@15618641</li>
<li>当数组在初始化时并没有对内层数组初始化，则外层数组的默认值为null。因为引用数据类型的默认值都为null</li>
</ul></li>
<li>内层数组元素
<ul>
<li>初始化值为声明和初始化时类型的默认值（与一维数组初始化情况相同）</li>
<li>若数组在初始化时并没有对内层数组初始化，则调用内层数组元素时报错（空指针异常）</li>
</ul></li>
</ul></li>
<li><p>数组内存解析 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">arr1[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">30</span>;</span><br></pre></td></tr></table></figure> <img src="/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/61%20Day3%20-%2007.png" alt="数组内存解析示意图"></p></li>
<li><p>复习</p></li>
</ol>
<ul>
<li>写出一维数组初始化的两种方式
<ul>
<li>答：分为静态初始化和动态初始化
<ul>
<li>静态初始化：int[] arr1 = new int[]{1, 2, 3};</li>
<li>动态初始化：int[] arr1 = new int[3]; 数组一旦初始化，其长度就是确定的；数组长度一旦是确定的，就不可修改</li>
</ul></li>
</ul></li>
<li>写出二维数组初始化的两种方式
<ul>
<li>答：分为静态初始化和动态初始化
<ul>
<li>静态初始化：<code>int[] [] arr1 = new int\[][]&#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;7&#125; &#125;;</code></li>
<li>动态初始化：<code>int[] [] arr1 = new int[[3] [3];或int[] [] arr1 = new int[3] [];</code></li>
</ul></li>
</ul></li>
<li>如何遍历如下的二维数组 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>答： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; arr[i].length; j++)&#123;</span><br><span class="line">		System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>不同类型的一维数组元素的默认初始化值各是多少
<ul>
<li>答：分为基本数据类型和引用数据类型
<ul>
<li>对于基本数据类型：byte：0、short：0、char：0、int：0、long：0、boolean：false、float：0.0、double：0.0</li>
<li>对于引用数据类型：（类、数组、接口）都是null</li>
</ul></li>
</ul></li>
<li>一维数组的内存解析 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">strs[<span class="number">2</span>] = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">strs = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="8" type="1">
<li>练习</li>
</ol>
<ul>
<li>使用二维数组打印一个10行杨辉三角</li>
</ul>
<h2 id="五扩展">五、扩展</h2>
<ol type="1">
<li>数据结构：
<ul>
<li>数据与数据之间的逻辑关系：集合、一对一（链表）、一对多（树形结构）、多对多（网络、图）</li>
<li>数据的存储结构：
<ul>
<li>线性表（一对一）：顺序表、链表、栈、队列（堆）</li>
<li>树形结构（一对多）：二叉树、...</li>
<li>图形结构（多对多）：有向、无向图</li>
</ul></li>
</ul></li>
<li>算法：
<ul>
<li>排序算法</li>
<li>搜索算法</li>
</ul></li>
</ol>
<h2 id="六数组中常用的算法">六、数组中常用的算法</h2>
<ol type="1">
<li><p>数组元素的赋值（杨辉三角、回形数等）【笔试考查】：</p>
<p>【拓展之笔试题】：</p>
<ul>
<li><p>创建一个长度为6的int型数组，要求数组元素的值都在1-30之间，且是随机赋值。同时，要求元素的值各不相同</p></li>
<li><p>回形数格式方针的实现</p></li>
</ul></li>
<li><p>求数值型数组中元素的最大值、最小值、平均值、总和等</p>
<ul>
<li>定义一个int型的一维数组，包含10个元素，分别赋一些随机整数，然后求出所有元素的最大值、最小值、和、平均值，并输出。要求：所有随机数都是两位数</li>
</ul>
<p>随机数生成：(int)(Math.random() * (99 - 10 + 1) + 10);</p></li>
<li><p>数组的复制、反转、查找（线性查找、二分查找）【笔试考查】</p>
<ul>
<li><p>复制<br> 使用简单数组<br> (1)创建一个名为ArrayTest的类，在main()方法中声明array1和array2两个变量，他们是int[]类型的数组<br> (2)使用大括号{}，把array1初始化为8个素数：2, 3, 5, 7, 11, 13, 17, 19<br> (3)显示array1的内容<br> (4)赋值array2变量等于array1，修改array2中偶索引元素，使其等于索引值，打印出array1<br> <strong>思考</strong>：array1和array2是什么关系：array1和array2存储的地址值相同，都指向堆空间中的唯一一个数组实体<br> <strong>拓展</strong>：修改题目，实现array2对array1数组的复制</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//数组的复制</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exerc6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//声明array1和array2数组</span></span><br><span class="line">        <span class="keyword">int</span>[] array1, array2;</span><br><span class="line">        <span class="comment">//初始化array1</span></span><br><span class="line">        array1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>&#125;;</span><br><span class="line">        <span class="comment">//显示array1的内容</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.length; i++)&#123;</span><br><span class="line">            System.out.print(array1[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//赋值array2变量等于array1</span></span><br><span class="line">        array2 = array1;</span><br><span class="line">        <span class="comment">//修改array2中偶索引元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                array2[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示array1的内容</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.length; i++)&#123;</span><br><span class="line">            System.out.print(array1[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//array2对array1数组的复制</span></span><br><span class="line">        array2 = <span class="keyword">new</span> <span class="keyword">int</span>[array1.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.length; i++)&#123;</span><br><span class="line">            array2[i] = array1[i];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;DD&quot;</span>, <span class="string">&quot;EE&quot;</span>, <span class="string">&quot;FF&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组的复制</span></span><br><span class="line">        String[] arr1 = <span class="keyword">new</span> String[arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">            arr1[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组的反转</span></span><br><span class="line">        <span class="comment">//方法一</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            String temp = arr[i];</span><br><span class="line">            arr[i] = arr[arr.length - i - <span class="number">1</span>];</span><br><span class="line">            arr[arr.length - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方法二</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = arr.length - <span class="number">1</span>; i &lt; j; i++, j--)&#123;</span><br><span class="line">            String temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找/搜索</span></span><br><span class="line">        <span class="comment">//线性查找</span></span><br><span class="line">        String dest = <span class="string">&quot;BB&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dest.equals(arr[i]))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;找到了，位置是：&quot;</span> + i);</span><br><span class="line">                isFlag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="comment">//前提：所要查找的数组须是有序的</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">98</span>, -<span class="number">34</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">66</span>, <span class="number">79</span>, <span class="number">105</span>, <span class="number">210</span>, <span class="number">333</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dest1 = -<span class="number">34</span>;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>, end = arr2.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isFlag1 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (head + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr2[mid] == dest1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;找到了，位置为：&quot;</span> + mid);</span><br><span class="line">                isFlag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr2[mid] &lt; dest1)&#123;</span><br><span class="line">                head = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>数组元素的排序算法【笔试考查】</p>
<ul>
<li><p>排序算法</p>
<ul>
<li>排序：假设含有n个记录的序列为{R1, R2, ..., Rn}，其相应的关键字序列为{K1, K2, ..., Kn}。将这些记录重新排序为{Ri1, Ri2, ..., Rin}，使得相应的关键字值满足Ki1 &lt;= Ki2 &lt;= ... &lt;= Kin，这样的一种操作称为排序。</li>
<li>通常来说排序的目的是快速查找</li>
<li>衡量排序算法的优劣
<ul>
<li>时间复杂度：关键字的比较次数和记录的移动次数</li>
<li>空间复杂度：算法中需要多少辅助内存</li>
<li>稳定性（专指排序算法）：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。</li>
</ul></li>
<li>排序算法分类：
<ul>
<li>内部排序：整个排序过程不需要借助外部存储器，所有排序操作都在内存中完成</li>
<li>外部排序：参与排序的数据非常多、数据量大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器，外部排序最常见的是多路归并排序，可认为外部排序是由多次内部排序组成的。</li>
</ul></li>
<li>十大内部排序算法：
<ul>
<li>选择排序：直接选择排序，<strong>堆排序</strong>【了解思想】</li>
<li>交换排序：<strong>冒泡排序</strong>、<strong>快速排序</strong>【需会手写】</li>
<li>插入排序：直接插入排序、折半插入排序、Shell排序（希尔排序）</li>
<li><strong>归并排序</strong>【了解思想】</li>
<li>桶式排序</li>
<li>基数排序</li>
</ul></li>
</ul>
<p>冒泡排序（O(<span class="math inline">\(n^2\)</span>)） <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSortTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">43</span>, <span class="number">32</span>, <span class="number">76</span>, -<span class="number">98</span>, <span class="number">0</span>, <span class="number">64</span>, <span class="number">33</span>, -<span class="number">21</span>, <span class="number">32</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = arr.clone();</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="comment">//先找出最大的数，并从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i -<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    isFlag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先找出最小的数，并从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = arr1.length - <span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[j] &lt; arr1[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr1[j];</span><br><span class="line">                    arr1[j] = arr1[j-<span class="number">1</span>];</span><br><span class="line">                    arr1[j-<span class="number">1</span>] = temp;</span><br><span class="line">                    isFlag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr1[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 快速排序（O(<span class="math inline">\(nlog_{2}(n)\)</span>)） <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大话数据结构中的快速排序算法思想（递归章节）和讲到的算法思想区别</span></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ol>
<h2 id="七arrays工具类的使用">七、Arrays工具类的使用</h2>
<p>java.util.Arrays：操作数组的工具类，其中有许多操作数组的方法。具体可查看API文档。</p>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>boolean equals(int[] a, int[] b)</td>
<td>判断两个数组是否相等</td>
</tr>
<tr class="even">
<td>2</td>
<td>String toString(int[] a)</td>
<td>输出数组信息</td>
</tr>
<tr class="odd">
<td>3</td>
<td>void fill(int[] a, int val)</td>
<td>将指定值填充到数组之中</td>
</tr>
<tr class="even">
<td>4</td>
<td>void sort(int[] a)</td>
<td>对数组进行排序</td>
</tr>
<tr class="odd">
<td>5</td>
<td>int binarySearch(int[] a, int key)</td>
<td>对排序后的数组进行二分法检索指定的值</td>
</tr>
</tbody>
</table>
<h2 id="八数组中常见的异常">八、数组中常见的异常</h2>
<ol type="1">
<li><p>数组角标越界异常：<span class="math inline">\(ArrayIndexOutOfBoundsException\)</span></p>
<ul>
<li>索引超过数组索引范围的就属于角标越界异常，负数也是角标越界（python有些区别）</li>
</ul></li>
<li><p>空指针异常：<span class="math inline">\(NullPointerException\)</span></p>
<ul>
<li>情况1：</li>
<li>情况2：</li>
<li>情况3： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayException</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           <span class="comment">//情况1</span></span><br><span class="line">           <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">           arr1 = <span class="keyword">null</span>;</span><br><span class="line">           System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//情况2</span></span><br><span class="line">           <span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">           System.out.println(arr2[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//情况3</span></span><br><span class="line">           String[] arr3 = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;;</span><br><span class="line">           arr3[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line">           System.out.println(arr3[<span class="number">0</span>].toString());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章 Java基本语法</title>
    <url>/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="第2章-基本语法">第2章 基本语法</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、关键字与保留字</li>
<li>二、标识符（identifier）</li>
<li>三、变量</li>
<li>四、每日一考</li>
<li>五、运算符</li>
<li>六、流程控制</li>
<li>七、每日一考</li>
<li>八、补充</li>
</ol>
<span id="more"></span>
<h2 id="一关键字与保留字">一、关键字与保留字</h2>
<p>关键字（keyword）</p>
<ul>
<li>定义：被Java语言赋予了特殊含义，用作专门用途的字符串（单词）</li>
<li>特点：关键字中所有字母都为小写</li>
</ul>
<p><img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/05%20Day2%20-%2001.png" alt="Java关键字"> <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/05%20Day2%20-%2002.png" alt="Java关键字"></p>
<p>保留字（reserved word）</p>
<ul>
<li>Java保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字。例如goto、const</li>
</ul>
<h2 id="二标识符identifier">二、标识符（identifier）</h2>
<ul>
<li>标识符：
<ul>
<li>Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li>
<li>技巧：凡是要起名字的地方就是标识符</li>
</ul></li>
<li><strong>命名规则</strong>：
<ul>
<li>由26个英文字母大小写、0-9、_或$组成</li>
<li>不可以数字开头</li>
<li>不可使用关键字和保留字，但可包含关键字或保留字</li>
<li>Java中严格区分大小写、长度无限制</li>
<li>标识符不能包含空格</li>
</ul></li>
<li>Java中的名称<strong>命名规范</strong>：
<ul>
<li>包名：多单词组成时，所有单词<strong>都小写</strong>（xxyyzz）</li>
<li>类名、接口名：多单词组成时，所有单词首字母大写（XxYyZz）</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写、第二个单词开始每个单词首字母大写（xxYyZz）</li>
<li>常量名：所有字母<strong>都大写</strong>，多单词时每个单词用下划线连接（XX_YY_ZZ）</li>
<li>注意：
<ul>
<li>在起名字时要见名知意</li>
<li>java采用unicode字符集，因此标识符可使用汉字声明，但不建议使用</li>
<li>更多细节详见《代码整洁之道》</li>
</ul></li>
</ul></li>
</ul>
<h2 id="三变量">三、变量</h2>
<ul>
<li>变量的概念：
<ul>
<li>内存中的一个存储区域</li>
<li>该区域内数据可在同一类型范围内不断变化</li>
<li>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值</li>
</ul></li>
<li>变量的作用：
<ul>
<li>用于在内存中保存数据</li>
</ul></li>
<li>使用变量时注意：
<ul>
<li>Java中每个变量必须先声明、后使用</li>
<li>使用变量名来访问这块区域的数据</li>
<li>变量作用域：其定义所在的{}内</li>
<li>同一作用域内不能声明两个同名变量</li>
</ul></li>
<li>变量分类（按数据类型分类）：
<ul>
<li>基本数据类型（primitive type）
<ul>
<li>数值型
<ul>
<li>整数类型（byte、short、int、long）</li>
<li>浮点类型（float、double）</li>
</ul></li>
<li>字符型（char）</li>
<li>布尔型（boolean）</li>
</ul></li>
<li>引用数据类型（reference type）
<ul>
<li>类（class） &lt;-- 字符串在这里</li>
<li>接口（interface）</li>
<li>数组（[ ]）</li>
</ul></li>
</ul></li>
<li>变量分类（按在类中声明的位置分类）：
<ul>
<li>成员变量（在方法体外，类体内声明的变量称为成员变量）
<ul>
<li>实例变量（不以static修饰）</li>
<li>类变量（以static修饰）</li>
</ul></li>
<li>局部变量（在方法体内部声明的变量称为局部变量）
<ul>
<li>形参（方法、构造器中定义的变量）</li>
<li>方法局部变量（在方法内定义）</li>
<li>代码块局部变量（在代码块中定义）</li>
</ul></li>
<li>成员变量和局部变量在初始化值方面的异同
<ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，需显式初始化</li>
</ul></li>
</ul></li>
</ul>
<h3 id="一基本数据类型">（一）基本数据类型</h3>
<h4 id="整数类型byteshortintlong">整数类型：byte、short、int、long</h4>
<ul>
<li>Java中各整数类型<strong>有固定的表数范围和字段长度</strong>，不受OS影响，以保证Java程序的可移植性</li>
<li>Java整型<strong>常量</strong>默认为int，声明long型常量需要在其后加'l'或‘L’</li>
<li>Java中整数类型的位数表（超出对应的类型表数范围 编译报错）：</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类型</th>
<th style="text-align: center;">占用存储空间</th>
<th style="text-align: left;">表数范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">byte</td>
<td style="text-align: center;">1字节</td>
<td style="text-align: left;">-128 ~ 127</td>
</tr>
<tr class="even">
<td style="text-align: center;">short</td>
<td style="text-align: center;">2字节</td>
<td style="text-align: left;">-<span class="math inline">\(2^{15}\)</span> ~ <span class="math inline">\(2^{15}-1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">int</td>
<td style="text-align: center;">4字节</td>
<td style="text-align: left;">-<span class="math inline">\(2^{31}\)</span> ~ <span class="math inline">\(2^{31}-1\)</span>（约21亿）</td>
</tr>
<tr class="even">
<td style="text-align: center;">long</td>
<td style="text-align: center;">8字节</td>
<td style="text-align: left;">-<span class="math inline">\(2^{63}\)</span> ~ <span class="math inline">\(2^{63} - 1\)</span> （声明long型变量也需在初始化值后加'l'或‘L’）</td>
</tr>
</tbody>
</table>
<h4 id="浮点型floatdouble">浮点型：float、double</h4>
<ul>
<li>Java浮点型也<strong>有固定的表数范围和字段长度</strong>，不受OS影响</li>
<li>浮点型常量有2种表示形式：
<ul>
<li>十进制形式：5.12、512.0f、.512</li>
<li>科学计数法形式：5.12E2、512E2、100E-2</li>
</ul></li>
<li>float：单精度，尾数可精确到7位有效数字。多数情况下精度较难满足要求</li>
<li>double：双精度，精度是float的两倍，通常采用此类型</li>
<li>Java中浮点类型常量默认是double型，声明float型常量需在其后加'f'或'F'</li>
</ul>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>float</td>
<td>4字节</td>
<td>-3.403E38 ~ 3.403E38 （定义float变量时，初始化值需要以'f'或'F'结尾）</td>
</tr>
<tr class="even">
<td>double</td>
<td>8字节</td>
<td>-1.798E308 ~ 1.798E308</td>
</tr>
</tbody>
</table>
<h4 id="字符型char">字符型：char</h4>
<ul>
<li>一个字符占据2字节</li>
<li>定义char类型通常使用一对单引号 ‘ ’，且单引号内部只能有一个字符</li>
<li>Java中的<strong>所有字符</strong>都使用Unicode编码，故可存储任何国家的语言的一个字符</li>
<li>char类型表示方式：
<ul>
<li>声明一个字符（char c = 'A'）</li>
<li>转义字符（char c = '\n';）</li>
<li>直接使用Unicode值来表示字符型常量（char c = '\uXXXX'; XXXX代表一个十六进制数）</li>
</ul></li>
<li>char类型也可进行运算，因为每个字符都有对应的Unicode码</li>
<li>win10命令行读取文件默认采用GBK字符集，当文件编码方式不是GBK时某些字符会在输出时乱码。（EditPlus的ANSI即表示GBK编码）</li>
</ul>
<h4 id="布尔型boolean">布尔型：boolean</h4>
<ul>
<li>只能取两个值之一：true、false</li>
<li>用于条件判断</li>
<li>转义字符前再加一个\将会输出该转义字符（如：println( "\\\n") ）；println双引号中需要使用双引号强调某个字符时可在内部双引号前加\（如println( "...\"...\"..." ) ）</li>
</ul>
<h3 id="二基本数据类型转换只有7种类型变量之间的运算不包含boolean类型">（二）基本数据类型转换（只有7种类型变量之间的运算，不包含boolean类型）</h3>
<ul>
<li><p>自动类型提升：</p>
<ul>
<li><strong>自动类型转换</strong>：（不同容量大小的类型变量运算时）容量小的类型自动转换为容量大的数据类型
<ul>
<li>byte、char、short --&gt; int --&gt; long --&gt; float --&gt; double；</li>
<li>此处容量大小指的是表数范围大小</li>
</ul></li>
<li>有多种类型的数据混合运算时，系统首先自动将所有数据转换为容量最大的那种数据类型，然后再进行计算。
<ul>
<li>计算后的数据若不以容量大的类型变量接收，编译报错；</li>
<li>若以浮点型变量接收整形运算结果，输出时会在整数值后加上 .0</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/06%20Day2%20-%2003.png" alt="计算后的数据若不以容量大的类型变量接收，编译报错"><figcaption aria-hidden="true">计算后的数据若不以容量大的类型变量接收，编译报错</figcaption>
</figure>
<ul>
<li><p><strong>注意</strong>：</p></li>
<li><p><strong>byte、short、char</strong>之间<strong>不会相互转换</strong>，他们三者在混合计算或同种类型运算时<strong>首先转换为int类型</strong>（java在做运算时如果操作数均在int范围内，那么一律在int的空间内运算）</p>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/07%20Day2%20-%2004.png" alt="byte、short、char 之间不会相互转换，他们三者在混合计算或同种类型运算时首先转换为 int 类型"><figcaption aria-hidden="true">byte、short、char 之间不会相互转换，他们三者在混合计算或同种类型运算时首先转换为 int 类型</figcaption>
</figure>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/08%20Day2%20-%2005.png" alt="byte、short、char 之间不会相互转换，他们三者在混合计算或同种类型运算时首先转换为 int 类型"><figcaption aria-hidden="true">byte、short、char 之间不会相互转换，他们三者在混合计算或同种类型运算时首先转换为 int 类型</figcaption>
</figure>
<ul>
<li><p>boolean类型不能与其他数据类型运算</p></li>
<li><p>当把任何基本数据类型的值和字符串（String）进行连接运算（+）时，基本数据类型的值将自动转化为字符串（String）类型</p></li>
</ul></li>
</ul></li>
<li><p>强制类型转换：自动类型提升的<strong>逆运算</strong></p>
<ul>
<li>需要使用强转符： ()
<ul>
<li>如：int b1 = (int) d1;</li>
</ul></li>
<li>注意：强制类型转换可能导致精度转换（如double转化为int型时会将小数部分截断）</li>
</ul></li>
</ul>
<h3 id="三字符串类型string">（三）字符串类型：String</h3>
<ul>
<li>String类型不是基本数据类型，属于引用数据类型</li>
<li>使用方式与基本数据类型一致。例如：String str = "abcd";</li>
<li>一个字符串可串接另一个字符串、或直接串接其他类型的数据。运算的结果仍是String类型
<ul>
<li>str = str + "xyz";</li>
<li>int n = 100;</li>
<li>str = str + n; （此处+号为连接运算）</li>
</ul></li>
<li>字符型变量在单引号内必须有且只有1个；而字符串在双引号内可存放任意（包含0）个字符</li>
</ul>
<p>String类型和其他类型<strong>运算</strong>时的注意点：</p>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/09%20Day2%20-%2006.png" alt="String 类型和其他类型运算时的注意点"><figcaption aria-hidden="true">String 类型和其他类型运算时的注意点</figcaption>
</figure>
<h3 id="进制与进制之间的转换">进制与进制之间的转换</h3>
<ul>
<li>对于整数，计算机中有4种表示方式：
<ul>
<li>二进制（binary）：0, 1。以0b或0B开头</li>
<li>十进制（decimal）：0-9</li>
<li>八进制（octal）：0-7。以数字0开头</li>
<li>十六进制（hex）：0-9及A-F。以0x或0X开头，此处A-F不区分大小写</li>
</ul></li>
</ul>
<h4 id="二进制与十进制之间的转换">二进制与十进制之间的转换</h4>
<ul>
<li>二进制：
<ul>
<li>正数的原码、反码、补码都是一致的</li>
<li>负数的原码为其相反数原码且符号位为1；负数的反码为其原码除符号位取反；负数的补码为其反码+1（或 负数的补码为其相反数的原码取反+1）</li>
<li>计算机的底层都以<strong>补码</strong>的方式存储数据</li>
</ul></li>
<li>十进制转二进制：除2取余的逆</li>
</ul>
<h4 id="二进制与八进制十六进制之间的转换">二进制与八进制、十六进制之间的转换</h4>
<ul>
<li>二进制与八进制之间转换：每3位二进制数表示1位八进制数；每1位八进制数表示3位二进制数</li>
<li>二进制与十六进制转换：每4位二进制数表示1位十六进制数；每1位十六进制数表示4位二进制数</li>
</ul>
<h2 id="四每日一考">四、每日一考</h2>
<ol type="1">
<li><p>标识符的命名规则有哪些？</p>
<blockquote>
答：
<ul>
<li>标识符可由26个英文字母、0-9数字和_以及$组成，且不能以数字开头</li>
<li>不可使用关键字和保留字，但可包含关键字或保留字</li>
<li>Java中严格区分大小写、长度无限制</li>
<li>标识符不能包含空格</li>
</ul>
</blockquote></li>
<li><p>标识符的命名规范有哪些？</p>
<blockquote>
答：
<ul>
<li>包名：所有单词小写</li>
<li>类名和接口名：首字母大写</li>
<li>变量和方法：第一个单词全部小写，从第二个单词开始首字母大写</li>
<li>常量：全部大写，多个单词使用下划线连接</li>
<li>注意：
<ul>
<li>在起名字时要见名知意</li>
<li>java采用unicode字符集，因此标识符可使用汉字声明，但不建议使用</li>
<li>更多细节详见《代码整洁之道》</li>
</ul></li>
</ul>
</blockquote></li>
<li><p>Java变量按照数据类型怎么划分？并指出Java的基本数据类型有哪8种，并指出各自占用的内存大小</p>
<blockquote>
答：
<ul>
<li>基本数据类型
<ul>
<li>数值型
<ul>
<li>整数型【byte(1字节)、short(2字节)、int(4字节)、long(8字节)】</li>
<li>浮点型【float(4字节)、double(8字节)】</li>
</ul></li>
<li>字符型【char(2字节)】</li>
<li>布尔型【boolean】</li>
</ul></li>
<li>引用数据类型
<ul>
<li>类（class）</li>
<li>接口（interface）</li>
<li>数组（[ ]）</li>
</ul></li>
</ul>
</blockquote></li>
<li><p>说明基本数据类型变量之间自动类型提升的运算规则</p>
<blockquote>
答：
<ul>
<li>在多种类型变量混合运算时，容量小的先转换为容量大的类型，结果为容量最大的类型</li>
<li>byte、short、char类型变量混合运算或其中单一类型变量运算时，需首先转换为int类型再进行运算，结果为int类型</li>
<li>byte、char、short --&gt; int --&gt; long --&gt; float --&gt; double；</li>
</ul>
</blockquote></li>
<li><p>说明基本数据类型变量之间强制类型转换的使用规则和强转可能出现的问题</p>
<blockquote>
答：
<ul>
<li>当容量大的类型转换为容量小的类型时需要使用强制类型转换，强制类型转换使用方式：类型A 变量v = (类型A)变量b;</li>
<li>强转可能会损失数据精度</li>
</ul>
</blockquote></li>
</ol>
<h2 id="五运算符">五、运算符</h2>
<p>运算符是一种特殊符号，用以表示数据的运算、赋值、比较等。 分类：</p>
<ul>
<li>算术运算符</li>
<li>赋值运算符</li>
<li>比较运算符（关系运算符）</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>三元运算符</li>
</ul>
<h3 id="一算术运算符">（一）算术运算符</h3>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/10%20Day2%20-%2007.png" alt="Java中的算数运算符"><figcaption aria-hidden="true">Java中的算数运算符</figcaption>
</figure>
<ul>
<li>取模（%）运算结果的符号与被模数的符号一致，与模数符号无关</li>
<li>自增1 / 自减1
<ul>
<li>前++：先自增1，再运算（包括赋值）</li>
<li>后++：先运算（包括赋值），后自增1</li>
<li><strong>自增不会改变变量的数据类型（short b = 1; b++; 中b的类型不会变）</strong></li>
<li>前--和后--类似</li>
<li>自增或自减不能连续使用（num++++; 或 (num++)++; 或 ++num++;），否则会报错</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/11%20Day2%20-%2008.png" alt="前++和后++测试"><figcaption aria-hidden="true">前++和后++测试</figcaption>
</figure>
<h3 id="二赋值运算符">（二）赋值运算符</h3>
<ul>
<li>符号：=</li>
<li>扩展：+=，-=，*=，/=，%=；<strong>这些运算不会改变结果的数据类型（short i = 2; i += 1; 不会报错，与i = i + 1还是有区别的）</strong></li>
<li>用法：
<ul>
<li>可连续赋值：i1 = j1 =10;</li>
<li>共同使用一个类型：int i1 = 10, i2 = 9;</li>
<li>i1 += 2 等价于 i1 = i1 + 2;（其他类似）</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/12%20Day2%20-%2009.png" alt="赋值运算与++运算符混合运算测试"><figcaption aria-hidden="true">赋值运算与++运算符混合运算测试</figcaption>
</figure>
<h3 id="三比较运算符">（三）比较运算符</h3>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/13%20Day2%20-%2010.png" alt="Java中的比较运算符"><figcaption aria-hidden="true">Java中的比较运算符</figcaption>
</figure>
<ul>
<li>比较运算符的结果都是boolean型</li>
<li>&lt; &gt; &gt;= &lt;=只能用于数值类型数据之间</li>
<li>== 和 !=：不仅可以使用在数值类型数据之间，还可使用在其他引用类型变量之间(例如new的两个对象比较)</li>
</ul>
<h3 id="四逻辑运算符">（四）逻辑运算符</h3>
<p>​ &amp;：逻辑与；|：逻辑或；!：逻辑非；<br> ​ &amp;&amp;：短路与；||：短路或；^：逻辑异或</p>
<ul>
<li>逻辑运算符只能用于boolean变量或boolean常量，且结果也为boolean型</li>
<li>短路与/短路或 至少可判断一个boolean量（只要左边boolean能够判断出来最终结果，将不再计算右边的量），而逻辑与/逻辑或需要执行左右两边的boolean量（和左边boolean值无关，都要计算）</li>
</ul>
<h3 id="五位运算符">（五）位运算符</h3>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/14%20Day2%20-%2011.png" alt="Java中的位运算符"><figcaption aria-hidden="true">Java中的位运算符</figcaption>
</figure>
<ul>
<li><p>位运算符操作的都是整型的数据</p></li>
<li><p>左右移位：</p>
<ul>
<li><p>左移（&lt;&lt;）：在<strong>一定范围内</strong>，无论正负数，每向左移一位，整个数据相当于*2，且右侧补0。超过范围会出现正负数转换</p></li>
<li><p>右移（&gt;&gt;）时左侧空出来的位使用原来最高位（符号位）补</p></li>
<li><p>无符号右移（&gt;&gt;&gt;）是指无论原数是正数还是负数，最高位都以0补</p>
<blockquote>
<p>面试题： 最高效计算2*8？</p>
<ul>
<li>答：2&lt;&lt;3 或 8&lt;&lt;1</li>
</ul>
<p>交换2个变量值的方法： <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/15%20Day2%20-%2012.png" alt="使用位运算符交换2个变量值的方法"></p>
</blockquote></li>
</ul></li>
<li><p>&amp; | ^：操作左右两侧整型量的对应的二进制数</p></li>
</ul>
<h3 id="六三元运算符">（六）三元运算符</h3>
<ul>
<li>格式：
<ul>
<li><strong>(条件表达式)? 表达式1 : 表达式2;</strong></li>
<li>若条件为真，则执行表达式1；否则执行表达式2</li>
</ul></li>
<li>三元运算符和if-else异同：
<ul>
<li>三元运算符可简化为if-else语句，都可以嵌套使用</li>
<li>三元运算符必须返回一个结果</li>
<li>if后代码块可有多个语句</li>
</ul></li>
</ul>
<h3 id="七运算符优先级">（七）运算符优先级</h3>
<p>考试需要记，但优先级表较为难记，只需在编程中把想要优先运算的用小括号括起来即可。</p>
<h2 id="六流程控制">六、流程控制</h2>
<h3 id="一基本流程结构">（一）基本流程结构：</h3>
<ul>
<li>顺序结构</li>
<li>分支结构
<ul>
<li>根据条件，选择性的执行某段代码
<ul>
<li>有if-else和switch-case两种分支结构
<ul>
<li>if-else三种结构 <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/16%20Day2%20-%2013.png" alt="if-else三种结构"></li>
<li>switch-case结构 <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/22%20Day2%20-%2019.png" alt="switch-case结构"></li>
</ul></li>
</ul></li>
</ul></li>
<li>循环结构
<ul>
<li>根据循环条件，重复性执行某段代码</li>
<li>有while、do...while、for三种循环语句</li>
<li>注：JDK1.5提供了foreach循环，方便遍历集合、数组元素</li>
</ul></li>
</ul>
<h3 id="二分支结构">（二）分支结构</h3>
<h4 id="if-else结构">if-else结构</h4>
<ul>
<li>else结构是可选的</li>
<li>对于条件表达式
<ul>
<li>如果多个条件表达式之间是互斥的关系，各个条件表达式的顺序无所谓</li>
<li>否则，应根据实际情况考虑应将哪个条件置于前面、哪个置于后面</li>
</ul></li>
</ul>
<h4 id="switch-case结构">switch-case结构</h4>
<p>格式： <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/22%20Day2%20-%2019.png" alt="switch-case结构"></p>
<ul>
<li>根据switch表达式的值，依次匹配各个case中的常量，一旦匹配成功，则进入相应的case结构中，调用其执行语句，调用完执行语句后仍继续向下执行，直到遇到break或switch-case结尾</li>
<li>switch表达式<strong>只能是6种数据类型之一：byte、short、int、char、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）</strong></li>
<li>case之后只能声明常量，不能是表达式</li>
<li>default结构是可有可无的，且位置灵活（置于case前面时也是在所有case不匹配时调用，且该结构仍需先判断各个case）</li>
<li>凡是使用switch-case的结构，都可转换为if-else结构。反之不成立；当写分支结构时，两者都可使用情况下，优先使用switch-case，因为switch-case执行效率稍高</li>
</ul>
<h3 id="三循环结构">（三）循环结构</h3>
<h4 id="循环结构分类">循环结构分类</h4>
<ul>
<li>循环语句的四个组成部分：
<ul>
<li>① 初始化部分（init_statement）</li>
<li>② 循环条件部分（test_exp）</li>
<li>③ 循环体部分（body_statement）</li>
<li>④ 迭代部分（alter_statement）</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/23%20Day2%20-%2020.png" alt="循环语句的四个组成部分"><figcaption aria-hidden="true">循环语句的四个组成部分</figcaption>
</figure>
<ul>
<li>for循环结构：
<ul>
<li>格式：for(①; ②; ④) { ③ }</li>
<li>执行过程（满足②执行循环体）：① ② ③ ④ ② ③ ④ ... ② ③ ④ ②</li>
<li>意义：条件满足时执行循环体</li>
</ul></li>
<li>while循环结构：
<ul>
<li>格式：①; while(②) { ③; ④; }</li>
<li>执行过程（满足②执行循环体）：① ② ③ ④ ② ③ ④ ... ② ③ ④ ②</li>
<li>for循环和while循环可相互转换</li>
<li>意义：当条件满足时执行循环体</li>
</ul></li>
<li>do-while循环结构：
<ul>
<li>格式：①; do { ③; ④; }while(②);</li>
<li>执行过程（满足②执行循环体）：① ③ ④ ② ③ ④ ... ② ③ ④ ②</li>
<li>意义：执行 循环体，直到条件不满足（直译：执行(do)...在...时(while)）</li>
<li>需要注意：while(②)后需要加上分号</li>
</ul></li>
<li>while(true) {...} 等价于 for(; ; ;) {...}</li>
</ul>
<h4 id="嵌套循环">嵌套循环</h4>
<ul>
<li>嵌套循环：将一个循环结构A置于另一个循环结构B的循环体中，就构成嵌套循环</li>
<li>外层循环：循环结构B相对于循环结构A为外层循环；内层循环：循环结构A相对于循环结构B为内层循环；</li>
<li>例子：输出100以内的所有质数。（质数或素数为 只能被1和它自己整除的自然数） <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/25%20Day2%20-%2022.png" alt="输出 100 以内的所有质数"></li>
</ul>
<h4 id="特殊关键字使用breakcontinue">特殊关键字使用（break、continue）</h4>
<ul>
<li>break与continue
<ul>
<li>break：适用在switch-case 或 循环结构中</li>
<li>continue：适用于循环结构中</li>
<li>两者在循环中作用：break在循环中使用为 结束当前循环；continue在循环中为结束当次循环。两者之后都不能<strong>直接</strong>声明其他语句</li>
</ul></li>
<li>带标签的break和continue
<ul>
<li>不带标签的break执行后默认跳出包裹此关键词的最近的一个循环；不带标签的continue类似</li>
<li>带标签的break执行后会跳出该标签指明的那一层循环；带标签的continue类似 <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/26%20Day2%20-%2023.png" alt="带标签的break和continue测试"></li>
<li>使用带标签的break或continue输出100内所有的质数 <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/27%20Day2%20-%2024.png" alt="使用带标签的 break 或 continue 输出 100 内所有的质数"></li>
</ul></li>
</ul>
<h2 id="七每日一考">七、每日一考</h2>
<ol type="1">
<li><p>&amp; 和 &amp;&amp; 的异同</p>
<blockquote>
<p>答：&amp;为逻辑与，&amp;&amp;为短路与。逻辑与两侧的表达式都需计算并判断，而短路与在一侧表达式变量使得整个结果成立时即可不再计算并判断右侧表达式</p>
</blockquote></li>
<li><p>程序输出 <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/17%20Day2%20-%2014.png" alt="题目"></p>
<blockquote>
<p>答：输出44</p>
</blockquote></li>
<li><p>定义三个int型变量并赋值，使用三元运算符或者if-else获取这三个数中的较大数的实现</p>
<blockquote>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/18%20Day2%20-%2015.png" alt="代码实现"><figcaption aria-hidden="true">代码实现</figcaption>
</figure>
</blockquote></li>
<li><p>编写程序，声明2个double型变量并赋值。判断第一个数大于10.0，且第2个数小于20.0，打印两数之和。否则，打印两者的乘积</p>
<blockquote>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/19%20Day2%20-%2016.png" alt="代码实现"><figcaption aria-hidden="true">代码实现</figcaption>
</figure>
</blockquote></li>
<li><p>交换两个值的代码实现</p>
<blockquote>
<p>答：前文中有3种解决方案</p>
</blockquote></li>
<li><p>switch后面的表达式可以是哪些数据类型</p>
<blockquote>
<p>答：switch后表达式可跟 6种类型变量：byte、char、short、int、String和枚举类型</p>
</blockquote></li>
<li><p>谈谈你对三元运算符、if-else和switch-case结构使用场景的理解</p>
<blockquote>
<p>答：三元运算符为一个运算符，常应用在简单的判断上，并且必须返回一个数据；if-else为流程控制结构，用于控制程序的运行，常应用于在不同范围内的变量执行不同操作的逻辑中，用于判断的表达式必须为boolean类型；switch-case结构也为流程控制结构，常用于变量具有某几个确定值的逻辑中，表达式类型只能取6种类型之一 凡是能使用三元运算符的、switch-case结构的，都能转换为if-else；反之，则不成立。三者都能使用时，优先使用三元运算符或者switch-case结构</p>
</blockquote></li>
<li><p>如何从控制台获取String和int类型的变量，并输出？使用代码实现</p>
<blockquote>
答：
<ul>
<li>首先导包：import java.util.Scanner;</li>
<li>然后实例化对象：Scanner scan = new Scanner(System.in);</li>
<li>通过查询手册，获取String类型变量：String str = scan.next();</li>
<li>通过查询手册，获取int类型变量：int i = scan.nextInt();</li>
</ul>
</blockquote></li>
<li><p>使用for循环遍历100以内的奇数，并计算所有的奇数的和并输出</p>
<blockquote>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/24%20Day2%20-%2021.png" alt="代码实现"><figcaption aria-hidden="true">代码实现</figcaption>
</figure>
</blockquote></li>
<li><p>循环结构是如何最后退出循环的，有哪些不同的情况请说明。</p>
<blockquote>
答：
<ul>
<li>不满足循环条件情况下，退出循环</li>
<li>break关键字强制退出循环</li>
<li>在方法中可使用return关键字强制停止循环执行</li>
</ul>
</blockquote></li>
<li><p>带标签的break和continue意义</p>
<blockquote>
答：
<ul>
<li>带标签的break被执行后，将会退出该标签指定的循环结构</li>
<li>带标签的continue被执行后，将会跳过本次该标签指定的循环</li>
</ul>
</blockquote></li>
<li><p>一个数如果恰好等于她的因子之和，这个数就称为”完数“。例如6=1+2+3。编程找出1000以内的所有完数。（因子：除去这个数本身的其他约数）</p>
<blockquote>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/28%20Day2%20-%2025.png" alt="代码实现"><figcaption aria-hidden="true">代码实现</figcaption>
</figure>
</blockquote></li>
<li><p>说明break和continue使用上的相同点和不同点</p>
<blockquote>
答：
<ul>
<li>break和continue都可用于循环语句中，而break还可用于switch-case语句中</li>
<li>break为退出循环，而continue为跳过该次循环，直接执行下一次循环</li>
<li>两者语句之后不能直接声明执行语句。</li>
</ul>
</blockquote></li>
</ol>
<h2 id="八补充">八、补充</h2>
<p>从键盘获取输入数据：</p>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/20%20Day2%20-%2017.png" alt="从键盘获取输入数据代码实现"><figcaption aria-hidden="true">从键盘获取输入数据代码实现</figcaption>
</figure>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章 Java语言概述</title>
    <url>/2021/11/22/Coding/Java/01Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="第1章-java语言概述">第1章 Java语言概述</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、软件开发介绍</li>
<li>二、计算机编程语言介绍</li>
<li>三、Java 语言概述</li>
<li>四、Java 语言运行机制及运行过程</li>
<li>五、Java 的环境搭建</li>
<li>六、开发体验 ——helloworld &amp; 常见的问题及解决方法</li>
<li>八、注释（comment）</li>
<li>九、Java API 文档</li>
<li>对第一个程序的总结</li>
<li>十、良好的编程风格</li>
<li>十一、常用的 Java 编程工具</li>
<li>每日一考 <span id="more"></span></li>
</ol>
<h2 id="一软件开发介绍">一、软件开发介绍</h2>
<ul>
<li>软件：一系列按照特定顺序组织的计算机数据和指令的集合
<ul>
<li>软件分为系统软件和应用软件</li>
</ul></li>
<li>人机交互方式
<ul>
<li>图形化界面（Graphical User Interface, GUI）</li>
<li>命令行方式（Command Line Interface, CLI）</li>
</ul></li>
<li>常用Dos指令：
<ul>
<li>dir：列出当前目录下的文件及文件夹</li>
<li>md：创建目录</li>
<li>rd：删除目录</li>
<li>cd：进入指定目录</li>
<li>cd..：退回到上一级目录</li>
<li>cd：退回到根目录</li>
<li>del：删除文件</li>
<li>exit：退出Dos命令行</li>
<li>补充：echo javase&gt;1.doc</li>
</ul></li>
</ul>
<h2 id="二计算机编程语言介绍">二、计算机编程语言介绍</h2>
<ul>
<li>第一代语言：机器语言</li>
<li>第二代语言：汇编语言：使用助记符表示一条机器指令</li>
<li>第三代语言：高级语言
<ul>
<li>C、Pascal、Fortran面向过程的语言</li>
<li>C++面向过程/面向对象</li>
<li>Java跨平台的纯面向对象语言</li>
<li>.NET跨语言的平台</li>
<li>Python、Scala...</li>
</ul></li>
</ul>
<h2 id="三java语言概述">三、Java语言概述</h2>
<p>后台开发：Java（大型）、PHP、Python（头条后台使用python）、Go（宣传具有java开发效率、具有C/C++执行效率）、Node.js（做前端的学习）</p>
<p>Java语言简史：</p>
<ul>
<li>2004年，发布里程碑式版本JDK1.5，为突出重要性更名为JDK5.0。后续版本中只要是1.X其实就是JDK X.0（例如JDK1.6等同于JDK6.0）</li>
<li>2005年，J2SE-更名-&gt;JavaSE，J2EE-更名-&gt;JavaEE，J2ME-更名-&gt;JavaME</li>
<li>2014年，发布JDK8.0，是继JDK5.0以来变化最大的版本。通常目前公司使用版本一定是1.5以后的，一般是6.0、7.0、8.0</li>
<li>2018年3月，发布JDK10.0，版本号以时间命名：18.3</li>
</ul>
<p>Java体系平台</p>
<ul>
<li>Java SE（Java Standard Edition）标准版：主要用于开发桌面级应用。现在一般不再用Java写桌面级应用了</li>
<li>java EE（Java Enterprise Edition）企业版：为企业环境下开发应用程序，后台</li>
<li>Java ME（Java Micro Edition）小型版 &amp; Java Card：为移动终端开发应用程序</li>
</ul>
<p>Java应用领域</p>
<ul>
<li><strong>企业级应用</strong>：后台开发</li>
<li><strong>Android平台应用</strong>：作为Android开发语言出现</li>
<li><strong>大数据平台开发</strong>：后台大都基于Java后台，<strong>大数据</strong>自然要开放Java接口。各类框架有Hadoop、spark、storm、flink，各种中间件如flume、kafka、sqoop</li>
<li>移动领域</li>
</ul>
<p>Java是由C语言和C++继承而来的：</p>
<ul>
<li>java是一个纯粹的面向对象的语言；</li>
<li>Java舍弃了C语言中容易引起错误的指针（使用 引用 来取代）；</li>
<li>Java增加了垃圾回收器功能</li>
</ul>
<h2 id="四java语言运行机制及运行过程">四、Java语言运行机制及运行过程</h2>
<p>Java语言特点：</p>
<ul>
<li>特点一：面向对象
<ul>
<li>两个基本概念：类、对象</li>
<li>三大特性：封装、继承、多态</li>
</ul></li>
<li>特点二：健壮性
<ul>
<li>吸收了C/C++语言优点，但去掉了影响程序健壮性的部分（指针、内存申请及释放），提供了一个相对安全的内存管理和访问机制。</li>
</ul></li>
<li>特点三：跨平台性
<ul>
<li>跨平台性：Java语言编写的程序在不同的系统上都可以运行</li>
<li>原理：只需在需要运行Java应用的操作系统上安装Java虚拟机（Java Virtual Machine, JVM）即可。由JVM负责Java程序在该系统的运行。</li>
</ul></li>
</ul>
<p>核心机制——垃圾回收</p>
<ul>
<li>不使用的内存空间应当被回收——垃圾回收
<ul>
<li>C/C++中，由程序员负责回收无用内存</li>
<li>Java提供了一种系统级线程跟踪存储空间的分配情况，在JVM空闲时，检查并释放可被释放的内存空间</li>
</ul></li>
<li>垃圾回收在Java程序的运行过程中自动进行，程序员无法精确控制和干预</li>
<li>但Java程序仍然会有可能出现<strong>内存泄漏和内存溢出</strong>的问题</li>
</ul>
<h2 id="五java的环境搭建">五、Java的环境搭建</h2>
<p>JDK后续版本向下兼容，高版本与低版本之间关系为包含关系（如果换用了新版本并且改掉了旧版本内容会造成原先能运行的程序无法运行，故新版本是旧版本的添加）</p>
<p><strong>JDK及JRE</strong>：</p>
<ul>
<li>JDK：Java Development Kit Java开发工具包。JDK中包括<strong>Java开发工具（编译工具javac.exe，打包工具jar.exe）</strong>和<strong>JRE</strong>。Java开发必需。</li>
<li>JRE：Java Runtime Environment java运行环境。JRE包括<strong>Java虚拟机（JVM）</strong>和<strong>Java程序所需的核心类库</strong>。Java程序运行必需。</li>
<li>jdk-8u131-win.....exe中：u代表update，131表示在jdk8.0版本上已经更新到131了</li>
</ul>
<figure>
<img src="/2021/11/22/Coding/Java/01Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/01%20JDK-JRE-JVM.png" alt="JDK-JRE-JVM关系"><figcaption aria-hidden="true">JDK-JRE-JVM关系</figcaption>
</figure>
<p>JDK目录结构：</p>
<figure>
<img src="/2021/11/22/Coding/Java/01Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/02%20JDK%20Directory%20Architecture.png" alt="JDK目录结构"><figcaption aria-hidden="true">JDK目录结构</figcaption>
</figure>
<ul>
<li>bin目录：开发工具，包括编译工具javac.exe、文档生成工具javadoc.exe</li>
<li>db目录：java写的数据库</li>
<li>include目录：C语言编写的头文件，jni.h代表Java Native Interface</li>
<li>jre目录：JRE运行时环境</li>
<li>lib目录：jar包库文件</li>
<li>src压缩文件：java源码和开源类库</li>
</ul>
<p>配置环境变量：</p>
<ul>
<li>PC中环境变量path代表 Windows系统执行命令时要搜寻的路径</li>
<li>改进：把\bin目录的上层目录放到一个新的自定义变量中（例如JAVA_HOME），之后再将这个变量名动态的引用（例如%JAVA_HOME%;）。改进的原因是 之后搭建服务器时需要寻找JAVA_HOME环境变量，从而获得并使用一些库文件，因此需要配置JAVA_HOME</li>
</ul>
<h2 id="六开发体验helloworld-常见的问题及解决方法">六、开发体验——helloworld &amp; 常见的问题及解决方法</h2>
<p>步骤</p>
<ol type="1">
<li>将java代码写入到扩展名为.java的文件中。</li>
<li>通过javac命令将java文件进行编译，生成.class文件。<strong>生成的.class文件文件名为.java文件中类的类名</strong>。（由于Windows目录下不区分大小写，使用javac ---.java可以不区分大小写）</li>
<li>通过java命令对生成的.class文件进行运行。（运行命令时.class扩展名无需写）</li>
<li>每次修改.java文件，运行时都需要重新编译（运行时区分大小写，因为此时回到了java层面，查找的是类）</li>
</ol>
<h2 id="八注释comment">八、注释（comment）</h2>
<ul>
<li><p>用于注解说明解释程序的文字就是注释</p></li>
<li><p>Java中的注释类型：</p>
<ul>
<li><p>单行注释：//</p></li>
<li><p>多行注释：/* */</p></li>
<li><p>文档注释：<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 指定java程序的作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure> 注释的内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档</p>
<p>操作方法：javadoc -d mydoc -author -version HelloWorld.java</p></li>
</ul></li>
<li><p>一般先将自己的思想通过注释整理出来，再用代码实现</p></li>
</ul>
<h2 id="九java-api文档">九、Java API文档</h2>
<ul>
<li>API（Application Programming Interface, 应用程序编程接口）是Java提供的基本编程接口。通俗来说就是<strong>Java提供的一系列类库</strong>。</li>
</ul>
<h2 id="对第一个程序的总结">对第一个程序的总结</h2>
<ol type="1">
<li><p>Java程序编写-编译-运行的过程<br> 编写：将编写的java代码保存在以.java结尾的源文件中<br> 编译：使用javac.exe命令编译.java源文件。格式：javac 源文件名.java<br> 运行：使用java命令解释运行字节码文件。格式：java 类名<br></p></li>
<li><p>在一个Java源文件中可以声明多个类。但是只能最多有一个类被声明为public，且只能加到与文件名一致的类上，否则编译不通过</p></li>
</ol>
<p>实际上先有的 类名要与文件名一致，public只能加到与文件名一致的类上是结果</p>
<blockquote>
<p>为什么Java源文件中只能最多有一个public类？</p>
<p>答：每个编译单元（java源文件）都只能有一个public类，这表示每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果某个编译单元包含多个public类或者public类名与编译单元名不同，都会产生编译错误。（——《java编程思想 第四版》）</p>
<p>总结：一个编译单元可以存在多个类，在编译时产生多个不同的.class文件，.class文件即是程序运行的数据来源。Java将public类作为每个编译单元的数据接口，只能有一个，不然不能处理存在多个public类的Java文件。当一个编译单元有多个非public类时，运行时需要对数据来源进行选择。</p>
</blockquote>
<ol start="3" type="1">
<li><p>程序的入口是main方法，格式是固定的</p></li>
<li><p>输出语句：<br> System.out.println();<br> System.out.print();</p></li>
<li><p>编译的过程： 编译后会生成一个或多个字节码文件。字节码文件名与Java源文件中的类名相同（一个源文件有几个类就会在编译后生成几个字节码文件）</p></li>
<li><p>运行： 运行包含程序入口的字节码文件即可。 如果生成了多个字节码文件（一个源文件中有多个类）并且想要运行其他字节码文件就需要在其他类中定义程序入口main</p></li>
</ol>
<h2 id="十良好的编程风格">十、良好的编程风格</h2>
<ul>
<li><p>大括号可以是首尾式 public class HelloWorld {</p>
<p>}</p></li>
<li><p>大括号可以是单独一行 public class HelloWorld <br> {</p>
<p>}</p></li>
<li><p>适当位置加空格：a = b + c * d;</p></li>
</ul>
<h2 id="十一常用的java编程工具">十一、常用的Java编程工具</h2>
<ol type="1">
<li>文本编辑工具
<ul>
<li>记事本</li>
<li>UltraEdit</li>
<li>EditPlus</li>
<li>TextPad</li>
<li>NotePad</li>
</ul></li>
<li>集成开发环境（Integrated Development Environment，IDE）
<ul>
<li>NetBeans</li>
<li>Eclipse</li>
<li>IDEA</li>
</ul></li>
</ol>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li><p>JDK，JRE，JVM三者之间的关系，以及JDK、JRE包含的主要结构有哪些？</p>
<blockquote>
<p>答：JDK、JRE、JVM三者为包含关系。JDK包含JRE和一些Java开发工具，JRE包含JVM和Java程序运行的核心类库</p>
</blockquote></li>
<li><p>为什么要配置path环境变量？如何配置？</p>
<blockquote>
<p>答：</p>
<ul>
<li>配置path环境变量是因为(可以不在工具所在目录)可在任何文件目录即可调用并运行该工具</li>
<li>在我的电脑 - 属性 - 高级 - 环境变量；建立JAVA_HOME环境变量，path中只需动态调用JAVA_HOME、再加上</li>
</ul>
</blockquote></li>
<li><p>常用的几个命令行操作都有哪些？（至少4个）</p>
<blockquote>
<p>答：</p>
<ul>
<li>cd</li>
<li>md</li>
<li>dir</li>
<li>del</li>
<li>rd</li>
</ul>
</blockquote></li>
<li><p>创建如下的类，使得运行时能够输出：</p>
<blockquote>
<p>公众号：百家全匠</p>
<p>英文名：Encyclopedia Master 用途：获得资源、增长知识、学习技能……</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficialAccount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;公众号：百家全匠\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;英文名：Encyclopedia Master&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;用途：获得资源、增长知识、学习技能……&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编译和运行上述代码的指令</p></li>
</ol>
<figure>
<img src="/2021/11/22/Coding/Java/01Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/03%20Day1%20-%2002.png" alt="alt"><figcaption aria-hidden="true">alt</figcaption>
</figure>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
