<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第7章 异常处理</title>
    <url>/2022/09/02/Coding/Java/07%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="第7章异常处理">第7章、异常处理</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、异常概述与异常体系结构</li>
<li>二、常见异常</li>
<li>三、异常处理机制一：try - catch - finally (重点)</li>
<li>四、异常处理机制二：throws (重点)</li>
<li>五、手动抛出异常：throw</li>
<li>六、用户自定义异常类</li>
<li>面试题</li>
</ol>
<span id="more"></span>
<h2 id="一异常概述与异常体系结构">一、异常概述与异常体系结构</h2>
<h3 id="异常概述">异常概述</h3>
<p>异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。(开发过程中的语法错误和逻辑错误不是异常)</p>
<p>Java程序在执行过程中所发生的异常事件可分为两类（广义异常）：</p>
<ul>
<li>Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：java.lang.StackOverflowError（栈溢出）和java.lang.OutOfMemoryError（堆溢出，OOM）。一般不编写针对性的代码进行处理。</li>
<li>Exception（狭义异常）: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：
<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul></li>
</ul>
<ol type="1">
<li>对于这些错误，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。</li>
</ol>
<h3 id="异常体系结构">异常体系结构</h3>
<ul>
<li>java.lang.Throwable
<ul>
<li>java.lang.Error</li>
<li>java.lang.Exception
<ul>
<li>编译时异常（受检异常，checked）
<ul>
<li>IOException
<ul>
<li>FileNotFoundException</li>
</ul></li>
<li>ClassNotFoundException</li>
<li>...</li>
</ul></li>
<li>运行时异常（非受检异常，unchecked）java.lang.RuntimeException
<ul>
<li>NullPointerException</li>
<li>ArrayIndexOutOfBoundsException</li>
<li>ClassCastException</li>
<li>NumberFormatException</li>
<li>InputMismatchException</li>
<li>ArithmeticException</li>
<li>...</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="二常见异常">二、常见异常</h2>
<ul>
<li>java.lang.RuntimeException
<ul>
<li>ClassCastException</li>
<li>ArrayIndexOutOfBoundsException</li>
<li>NullPointerException</li>
<li>ArithmeticException</li>
<li>NumberFormatException</li>
<li>InputMismatchException</li>
<li>。。。</li>
</ul></li>
<li>java.io.IOExeption
<ul>
<li>FileNotFoundException</li>
<li>EOFException</li>
</ul></li>
<li>java.lang.ClassNotFoundException</li>
<li>java.lang.InterruptedException</li>
<li>java.io.FileNotFoundException</li>
<li>java.sql.SQLException</li>
</ul>
<h2 id="三异常处理机制一try---catch---finally重点">三、异常处理机制一：try - catch - finally(重点)</h2>
<h3 id="异常处理抓抛模型">异常处理：抓抛模型</h3>
<p>过程一：抛，程序在正常执行过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。一旦抛出对象后，其后的代码就不再执行</p>
<p>过程二：抓，理解为异常处理方式：①try - catch - finally</p>
<h3 id="try-catch-finally的使用">try-catch-finally的使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 处理异常类型1的处理方式方式1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 处理异常类型2的处理方式方式2</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">// 处理异常类型3的处理方式方式3</span></span><br><span class="line">&#125; </span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：
<ul>
<li>finally是可选的</li>
<li>使用try将可能出现异常的代码包装起来，执行过程中一旦出现异常，就会生成一个异常类的对象，根据此对象的类型，去catch中进行匹配</li>
<li>一旦try中的异常对象匹配到某个catch条件时，就进入catch中进行异常处理，一旦处理完成，就跳出当前的try-catch结构（无finally的情况），继续执行其后的代码</li>
<li>catch中的异常类型，如无子父类关系，谁声明在上、下无所谓；catch中的异常类型如满足子父类关系，则要求子类的catch语句声明在父类的catch语句上面，否则报错</li>
<li>常用的异常对象处理方式：①String getMessage(); ②printStackTrace();</li>
<li>try结构中声明的变量，出了try结构后就不能被调用了</li>
<li>try-catch-finally结构可以嵌套</li>
</ul></li>
<li>体会
<ul>
<li>使用try-catch-finally处理编译时异常，会使得程序在编译时不在报错，但在运行时可能会报错。相当于使用try-catch-finally结构将一个编译时可能出现的异常，延迟到运行时出现</li>
<li>开发中，由于运行时异常比较常见，所以通常不针对运行时异常编写try-catch-finally了。但针对编译时异常，一定要考虑异常处理（处理编译时异常使得可能出现的异常延迟，起码生成字节码文件）</li>
</ul></li>
</ul>
<h3 id="try-catch-finally中finally的使用">try-catch-finally中finally的使用</h3>
<ol type="1">
<li>finally是可选的</li>
<li>finally中声明的是一定会被执行的代码，即使catch中又出现异常、try中有return语句（被执行）、catch中有return语句（被执行）等情况。【如try、catch、finally中都有return语句，则最终返回的是finally中的return语句】</li>
<li>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，我们需要手动进行资源的释放，此时的资源释放代码<strong>需要声明在finally中</strong></li>
<li>右键 - surround with - try/catch block</li>
</ol>
<h2 id="四异常处理机制二throws重点">四、异常处理机制二：throws(重点)</h2>
<ol type="1">
<li>“throws + 异常类型” 卸载方法的声明处，指明此方法执行时可能会抛出的异常类型。一旦方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后的异常类型时就会被抛出（抛给调用者），异常代码后的代码就不再执行</li>
<li>体会：
<ul>
<li>try-catch-finally：真正的把异常处理掉了</li>
<li>throws的方式只是将异常抛给了方法的调用者，并没有真正的将异常处理掉</li>
</ul></li>
<li>开发中如何选择try-catch-finally，还是使用throws
<ul>
<li>如父类中被重写方法没有throws处理异常，则子类重写的方法也不能使用throws方式处理异常，意味着如果子类重写的方法中有可能出现异常，必须使用try-catch-finally方式处理异常</li>
<li>执行的方法a中，先后又调用了另外几个方法时，且这几个方法是递进关系执行的（下一个方法的执行依赖于上一个方法的正确结果），那么建议这几个方法使用throws方式进行处理，而执行的方法a可以考虑使用try-catch-finally方式进行处理</li>
</ul></li>
</ol>
<h3 id="方法重写的规则子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型">方法重写的规则：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</h3>
<p>重写的方法，在编译时看的父类被重写方法，因此在编译阶段认为：方法抛出异常后调用者处理的是父类中被重写方法的异常类型，然而由于多态性，运行时运行的是子类重写的方法，因此如果子类重写的方法抛出的异常类型大于父类被重写的方法抛出的异常，调用者处理异常的方法失效，编译报错</p>
<h2 id="五手动抛出异常throw">五、手动抛出异常：throw</h2>
<p>程序执行中，除了自动抛出异常对象的情况外，还可手动的throw一个异常类的对象</p>
<p>异常对象的产生：①系统自动生成的异常对象；②手动的生成一个异常对象，并抛出（throw）</p>
<h2 id="六用户自定义异常类">六、用户自定义异常类</h2>
<p>如何自定义异常类</p>
<ol type="1">
<li>继承于现有的异常结构：RuntimeException、Exception</li>
<li>提供全局常量serialVersionUID</li>
<li>提供重载的构造器</li>
</ol>
<h2 id="面试题">面试题</h2>
<ol type="1">
<li>常见的异常都有哪些？举例说明</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//		File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line"><span class="comment">//		FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		int data = fis.read();</span></span><br><span class="line"><span class="comment">//		while(data != -1)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.print((char)data);</span></span><br><span class="line"><span class="comment">//			data = fis.read();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		fis.close();</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line">	<span class="comment">//ArithmeticException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">		System.out.println(a / b);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//InputMismatchException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> score = scanner.nextInt();</span><br><span class="line">		System.out.println(score);</span><br><span class="line">		</span><br><span class="line">		scanner.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//NumberFormatException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">		str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//ClassCastException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Object obj = <span class="keyword">new</span> Date();</span><br><span class="line">		String str = (String)obj;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//		int[] arr = new int[10];</span></span><br><span class="line"><span class="comment">//		System.out.println(arr[10]);</span></span><br><span class="line">		<span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">		String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//NullPointerException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		int[] arr = null;</span></span><br><span class="line"><span class="comment">//		System.out.println(arr[3]);</span></span><br><span class="line">		</span><br><span class="line">		String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		str = <span class="keyword">null</span>;</span><br><span class="line">		System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>throw和throws有什么区别？
<ul>
<li>throws为一种异常处理方式
<ul>
<li>属于异常处理的一种方式，声明在方法的声明处</li>
</ul></li>
<li>throw为手动抛出异常对象
<ul>
<li>表示抛出一个异常类的对象，生成异常类对象的过程。声明在方法体内</li>
</ul></li>
</ul></li>
<li>final、finally、finalize三者区别（
<ul>
<li>结构相似的
<ul>
<li>Collection和Collections，</li>
<li>String、StringBuffer、StringBuilder，</li>
<li>ArrayList、LinkedList，</li>
<li>HashMap、LinkedHashMap，</li>
<li>重写、重载</li>
</ul></li>
<li>结构不相似的
<ul>
<li>抽象类、接口</li>
<li>==、equals()</li>
<li>sleep()、wait()</li>
</ul></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章 面向对象编程-下</title>
    <url>/2022/09/02/Coding/Java/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8B/</url>
    <content><![CDATA[<h1 id="第6章面向对象编程-下">第6章、面向对象编程-下</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、关键字：static</li>
<li>单例（Singleton）设计模式【掌握，可能在笔试时手写】</li>
<li>二、理解 main 方法的语法</li>
<li>三、类的成员之四：代码块（或初始化块）</li>
<li>四、关键字：final</li>
<li>五、抽象类与抽象方法【少数认为归为特征（封装、继承、多态、抽象），一般归为关键字：abstract】</li>
<li>六、接口（interface）【关键字的使用】</li>
<li>七、类的成员之五：内部类（自己写比较少，但源码中会出现）</li>
<li>面试题</li>
<li>每日一考</li>
<li>声明抽象类，并包含抽象方法，测试类中创建一个继承抽象类的匿名子类对象</li>
</ol>
<span id="more"></span>
<h2 id="一关键字static">一、关键字：static</h2>
<ol type="1">
<li>static：静态的</li>
<li>static可用来修饰：属性、方法、代码块、内部类</li>
<li>使用static修饰属性：<strong>静态变量（或类变量）</strong>
<ul>
<li><p>属性：按是否使用static修饰，又分为静态属性 vs 非静态属性（实例变量）</p>
<ul>
<li>实例变量：创建类的多个对象，每个对象都<strong>独立的</strong>拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改</li>
<li>静态变量：创建类的多个对象，多个对象<strong>共享</strong>同一个静态变量，当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li>
</ul></li>
<li><p>static修饰属性的其他说明</p>
<ul>
<li>静态变量随着类的加载而加载，可通过“类.静态变量”的方式进行调用</li>
<li>静态变量加载要早于对象的创建</li>
<li>由于类只会加载一次，则静态变量也只会存在一份，存在方法区的静态域中</li>
</ul></li>
<li><p>静态属性举例</p>
<ul>
<li>System.out</li>
<li>Math.PI</li>
</ul></li>
<li><p>类变量 vs 实例变量的内存解析</p>
<figure>
<img src="/2022/09/02/Coding/Java/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8B/类变量和实例变量内存解析.png" alt="类变量和实例变量内存解析"><figcaption aria-hidden="true">类变量和实例变量内存解析</figcaption>
</figure></li>
</ul></li>
<li>使用static修饰方法：<strong>静态方法</strong>
<ul>
<li>随着类的加载而加载，可通过“类.静态方法”的方式调用</li>
<li>静态方法中只能调用静态的方法或属性。非静态方法中即可调用非静态的方法和属性、也可调用静态的方法和属性</li>
</ul></li>
<li>static注意点
<ul>
<li>静态方法中，不能使用this关键字和super关键字（this和super都是基于有当前对象才可调用的）<strong>？super调用父类中的static结构也不可</strong></li>
<li>静态属性和静态方法的使用，可从生命周期的角度分析</li>
</ul></li>
<li>开发中，如何确定一个属性是否要声明为static的？
<ul>
<li>属性可被多个对象所共享，不会随对象的不同而不同时</li>
<li>类中的常量也通常声明为static</li>
</ul></li>
<li>开发中，如何确定一个方法是否要声明为static的？
<ul>
<li>操作静态属性的方法通常设置为static的</li>
<li>工具类中的方法，习惯上声明为static的，如Math、Arrays、Collections</li>
</ul></li>
</ol>
<h3 id="单例singleton设计模式掌握可能在笔试时手写">单例（Singleton）设计模式【掌握，可能在笔试时手写】</h3>
<ol type="1">
<li>设计模式 定义
<ul>
<li>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路”</li>
</ul></li>
<li>单例设计模式 定义
<ul>
<li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</li>
<li>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。</li>
<li>因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</li>
</ul></li>
<li>单例设计模式实现【笔试时写线程安全的，不要写线程不安全的代码】
<ul>
<li><strong>饿汉式</strong>单例模式实现（先把对象创建出来）</li>
<li><strong>懒汉式</strong>单例设计模式（不用对象不造，用的时候才造对象）</li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式（单例模式）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 内部创建类的对象</span></span><br><span class="line">	<span class="comment">// 静态方法中操作的对象也需要是静态的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 提供公共的静态方法，返回类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1. 私有化构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2. 声明当前类对象，无需初始化</span></span><br><span class="line">	<span class="comment">// 4. 此对象需声明为静态的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 3. 声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Order();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>区分饿汉式和懒汉式
<ul>
<li>饿汉式
<ul>
<li>坏处：对象加载的时间过长（先加载出来对象，有可能长时间不用）</li>
<li>好处：是线程安全的</li>
</ul></li>
<li>懒汉式：
<ul>
<li>好处：延迟对象的创建</li>
<li>目前写法的坏处：线程不安全 ---&gt;多线程项目时需修改</li>
</ul></li>
</ul></li>
<li>单例模式的优点
<ul>
<li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</li>
<li>举例：java.lang.Runtime</li>
</ul></li>
<li>单例模式的应用场景
<ul>
<li>网站的计数器，一般也是单例模式实现，否则难以同步。</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li>
<li>Application 也是单例的典型应用</li>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
</ul></li>
</ol>
<h2 id="二理解main方法的语法">二、理解main方法的语法</h2>
<ol type="1">
<li>main()方法作为程序的入口</li>
<li>main()方法也是一个普通的静态方法</li>
<li>main()方法可作为我们与控制台交互的方式（之前用的是Scanner）</li>
</ol>
<h2 id="三类的成员之四代码块或初始化块">三、类的成员之四：代码块（或初始化块）</h2>
<ol type="1">
<li>代码块的作用：用来初始化类、对象</li>
<li>代码块如有修饰，只能使用static。因此代码块分为<strong>静态代码块 vs 非静态代码块</strong></li>
<li>静态代码块
<ul>
<li>格式：static { ... }</li>
<li>内部可有输出语句</li>
<li>随着类的加载（使用到类时加载）而执行，只会执行一次，除非类被重新加载</li>
<li>作用：初始化类的信息</li>
<li>如一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li>
<li>静态代码块的执行优先于非静态代码块的执行（类和对象加载先后）。静态代码块只能调用静态属性、方法，不能调用非静态的结构</li>
</ul></li>
<li>非静态代码块
<ul>
<li>格式：{ ... }</li>
<li>内部可有输出语句</li>
<li>随着对象的创建而执行，每创建一个就执行一次</li>
<li>作用：在创建对象时，对对象的属性进行初始化</li>
<li>如一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li>
<li>非静态代码块既可调用静态属性、方法，也可调用非静态的结构</li>
</ul></li>
<li>静态代码块、构造器、静态方法（包含main）、非静态代码块执行的先后顺序：由父及子，静态先行。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> codeblock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Root</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">			+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">		<span class="keyword">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeafTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Leaf(); </span><br><span class="line">		<span class="comment">//new Leaf();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> codeblock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;11111111111&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;22222222222&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;33333333333&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;44444444444&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;55555555555&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;66666666666&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// 由父及子 静态先行</span></span><br><span class="line">		System.out.println(<span class="string">&quot;77777777777&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">		System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">		System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> Father();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>属性赋值的先后顺序：默认初始化 - 显式初始化 / 代码块（先后顺序） - 构造器中赋值 - 创建对象后通过对象.方法或对象.属性赋值</li>
</ol>
<h2 id="四关键字final">四、关键字：final</h2>
<p>final：最终的 1. final可用来修饰：类、方法、变量 2. final修饰类：此类即不可被其他类继承 - 例如：String类、System类、StringBuffer类 3. final修饰方法：此方法不可被重写 - 例如：Object类中的getClass()方法【native关键字表示其方法实现采用C/C++代码实现】 4. final修饰变量：此“变量”即为一个常量 - final修饰属性：可赋值的位置有显式初始化、代码块中赋值、构造器中初始化【不可使用默认值，不可采用set方法赋值（类的构造器执行完毕后对象及其内部结构就应被初始化，而方法晚于对象及属性初始化）】 - final修饰局部变量： - 尤其使用final修饰形参时，表明此形参为一个常量，当调用此方法时，给常量形参赋一个实参，一旦赋值后，就只能在方法体内使用此形参，不可进行赋值等修改操作</p>
<ol start="5" type="1">
<li>static final可用来修饰：属性、方法
<ul>
<li>修饰属性：全局（static）常量（final）</li>
</ul></li>
</ol>
<h2 id="五抽象类与抽象方法少数认为归为特征封装继承多态抽象一般归为关键字abstract">五、抽象类与抽象方法【少数认为归为特征（封装、继承、多态、抽象），一般归为关键字：abstract】</h2>
<ol type="1">
<li>抽象类定义</li>
</ol>
<ul>
<li>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</li>
</ul>
<ol start="2" type="1">
<li><p>abstract关键字的使用：abstract可用来修饰类、方法</p></li>
<li><p>abstract修饰类</p>
<ul>
<li>抽象类不能实例化</li>
<li>抽象类中一定有构造器，子类实例化时会调用</li>
<li>开发中，需提供抽象类的子类，让子类实例化，完成开发工作</li>
</ul></li>
<li><p>abstract修饰方法</p>
<ul>
<li>抽象方法只有方法的声明，无方法体</li>
<li>包含抽象方法的类一定是抽象类，反之抽象类中可以没有抽象方法</li>
<li>若子类重写了父类中的所有抽象方法，此类方可实例化；若子类没有重写父类中的所有抽象方法，此类仍需是抽象类，需使用abstract修饰类。 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若子类重写了父类中的所有抽象方法，此类方可实例化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="comment">// Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若子类没有重写父类中的所有抽象方法，此类仍需是抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>abstract使用上的注意点：不可修饰属性、构造器；不可修饰私有方法、静态方法和final方法（私有方法和静态方法无法重写）</p></li>
</ol>
<h3 id="举例l">举例l</h3>
<p>IO流中涉及到的抽象类：InputStream / OutputStream / Reader / Writer，在其内部定义了抽象的read()、write()方法</p>
<h3 id="抽象类的匿名子类">抽象类的匿名子类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person为抽象类，含有一个eat抽象方法</span></span><br><span class="line"><span class="comment">// 匿名子类</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">method(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名子类的匿名对象</span></span><br><span class="line">method( <span class="keyword">new</span> Person()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<h3 id="模板方法设计模式templatemethod抽象类的应用">模板方法设计模式（TemplateMethod）【抽象类的应用】</h3>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p>解决的问题： - 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。 - 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		code(); <span class="comment">//不确定的部分； 像个钩子一样，挂哪个子类就执行那个子类的实现代码</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六接口interface关键字的使用">六、接口（interface）【关键字的使用】</h2>
<ul>
<li>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li>
<li>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须能...”的思想。继承是一个"是不是"的关系，而接口实现则是 "能不能" 的关系。</li>
<li>接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。</li>
</ul>
<h3 id="接口的使用jdk7及之前">接口的使用(JDK7及之前)</h3>
<ol type="1">
<li><p>接口使用interface来定义</p></li>
<li><p>Java中，接口和类是并列的两个结构</p></li>
<li><p>如何定义接口，定义接口中的成员</p>
<ul>
<li>JDK 7及以前，只能定义全局常量和抽象方法
<ul>
<li>全局常量：public static final的(可省略不写，但仍是全局常量)</li>
<li>抽象方法：public abstract的</li>
</ul></li>
<li>JDK 8：除了定义全局常量和抽象方法之外，还可定义静态方法、默认方法</li>
</ul></li>
<li><p>接口中不能定义构造器，意味着接口不可实例化</p></li>
<li><p>Java开发中接口通过让类去实现（implements）的方式使用。如果实现类覆盖了接口中所有抽象方法，此实现类即可实例化；否则，该类是抽象类，需使用abstract修饰</p></li>
<li><p>类中把abstract方法重写其实是<strong>实现</strong>，子类覆盖父类的方法叫重写</p></li>
<li><p>Java类可实现多个接口（多实现） ---&gt; 弥补了Java单继承的局限性。</p>
<ul>
<li>格式：class AA extends BB implements CC, DD, EE{} <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Attackable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 全局常量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SPEED = <span class="number">7900</span>; <span class="comment">//第一宇宙速度</span></span><br><span class="line">	<span class="keyword">int</span> MIN_SPEED = <span class="number">1</span>; <span class="comment">// 省略了public static final</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>; <span class="comment">// 省略了public abstract</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bullet</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Flyable</span>, <span class="title">Attackable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>接口和接口之间可以<strong>多继承</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BB</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CC</span> <span class="keyword">extends</span> <span class="title">AA</span>, <span class="title">BB</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">CC</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>接口的具体使用，体现多态性</p></li>
<li><p>接口实际上可看作是一种规范（例如USB是一种规范，具体的硬盘、U盘、打印机都需要去实现USB规范中的具体操作，驱动即是接口实现类的集合）</p></li>
<li><p>开发中，体会面向接口编程</p></li>
</ol>
<ul>
<li>接口的主要用途就是被实现类实现（面向接口编程）</li>
<li>项目的具体需求是多变的，我们必须以不变应万变才能从容开发，此处的不变就是规范，因此，开发项目往往是面向接口编程</li>
<li>例子：面向接口编程，在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个数据库厂商的API</li>
</ul>
<ol start="12" type="1">
<li>创建实现类对象的四种类型</li>
</ol>
<ul>
<li>非匿名实现类的非匿名对象</li>
<li>非匿名实现类的匿名对象</li>
<li>匿名实现类的非匿名对象</li>
<li>匿名实现类的匿名对象</li>
</ul>
<h3 id="接口的应用">接口的应用</h3>
<ol type="1">
<li>代理模式（Proxy）
<ul>
<li>应用场景
<ul>
<li>安全代理：屏蔽对真实角色的直接访问。</li>
<li>远程代理：通过代理类处理远程方法调用（RMI）</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li>
</ul></li>
<li>分类
<ul>
<li>静态代理（静态定义代理类）</li>
<li>动态代理（动态生成代理类）
<ul>
<li>JDK自带的动态代理，需要反射等知识</li>
</ul></li>
</ul></li>
</ul></li>
<li>工厂模式
<ul>
<li>简单工厂模式：class XxxFactory{}。创建Xxx对象的类</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul></li>
</ol>
<h3 id="接口的使用jdk8">接口的使用（JDK8）</h3>
<p>除了定义全局常量和抽象方法之外，还可定义静态方法、默认方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceJDK8</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 默认方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 此处只是省略了public</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method3&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>接口中定义的静态方法，只能通过接口来调用（接口名.静态方法），实现类无法调用</p></li>
<li><p>实现类的对象可调用接口中的默认方法。如果实现类重写了接口中的默认方法（重写时不加default关键字），调用时调用的是重写后的方法</p></li>
<li><p>如果子类或实现类继承的父类 和 实现的接口中声明了同名同参数的方法（默认方法），在子类没有重写此方法的情况下，调用的是父类中的同名同参数方法 --&gt; 类优先原则（只是指方法，属性不适用）</p></li>
<li><p>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，，那么在实现类没有重写此方法的情况下，报错 --&gt; 接口冲突。需要在实现类中重写此方法</p></li>
<li><p>在实现类方法中调用父类、接口中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 假设method3为SuperClass、InterfaceA、InterfaceB中有方法体的同名同参数方法</span></span><br><span class="line">        method3(); <span class="comment">//调用自己重写的方法</span></span><br><span class="line">        <span class="keyword">super</span>.method3(); <span class="comment">//调用父类中的方法</span></span><br><span class="line">        InterfaceA.<span class="keyword">super</span>.method3(); <span class="comment">//调用InterfaceA接口中的method3()方法</span></span><br><span class="line">        InterfaceB.<span class="keyword">super</span>.method3(); <span class="comment">//调用InterfaceB接口中的method3()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="七类的成员之五内部类自己写比较少但源码中会出现">七、类的成员之五：内部类（自己写比较少，但源码中会出现）</h2>
<ol type="1">
<li><p>Java中允许将一个类A声明在另一个类B中，则A为内部类，类B为外部类</p></li>
<li><p>内部类分类：成员内部类 vs 局部内部类（方法内、代码块内、构造期内...）</p></li>
<li><p>成员内部类</p>
<ul>
<li>作为外部类的成员：
<ul>
<li>可调用外部类结构</li>
<li>可被static修饰（内部类可被static修饰，外部类不可）</li>
<li>作为成员，可被四种权限修饰</li>
</ul></li>
<li>作为一个类：
<ul>
<li>类内部定义属性、方法、构造器等</li>
<li>可被final修饰，表示此类不可被继承。反之可被继承</li>
<li>可被abstract修饰</li>
</ul></li>
</ul></li>
<li><p>关注的3个问题</p></li>
</ol>
<ul>
<li><p>如何实例化成员内部类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 创建Dog实例（静态成员内部类）</span></span><br><span class="line">		Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 创建Bird实例（非静态成员内部类）</span></span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		Person.Bird bird = p.<span class="function">new <span class="title">Bird</span><span class="params">()</span></span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如何在成员内部类中区分调用外部类结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 静态成员内部类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">		<span class="comment">// 属性、构造器、方法、代码块</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 非静态成员内部类</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">		<span class="comment">// 属性、构造器、方法、代码块</span></span><br><span class="line">		String name;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;形参：&quot;</span> + name);</span><br><span class="line">			System.out.println(<span class="string">&quot;内部类name：&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">			System.out.println(<span class="string">&quot;外部类name：&quot;</span> + Person.<span class="keyword">this</span>.name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>开发中局部内部类的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 开发中少见</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 方式一</span></span><br><span class="line">		<span class="comment">// 创建一个实现了Comparable接口的类: 局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyComparable</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyComparable();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 方式二</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5" type="1">
<li>注意点
<ul>
<li>在局部内部类方法中，如要在局部内部类所声明的方法中调用内部类所在方法中的局部变量的话，要求此变量声明为final的。JDK7之前，要求此局部变量显式声明为final，JDK8及之后，可省略显式声明。（移动端开发 （android开发）使用较多）【原因：每个类都会生成一个字节码文件，但是方法中的局部变量作用域和字节码文件作用域不同，因此需要声明局部变量为final，且传给内部类中的方法的变量值为该局部变量的副本】</li>
</ul></li>
<li>总结
<ul>
<li>成员内部类和局部内部类，在编译后都会生成字节码文件。格式：</li>
<li>成员内部类：外部类名$内部类名.class，例如：Person$Dog.class</li>
<li>局部内部类：外部类名$数字内部类名.class，例如：Person$1Bird.class</li>
</ul></li>
</ol>
<h2 id="面试题">面试题</h2>
<ol type="1">
<li><p>final 排错 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addOne</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ++x;</span><br><span class="line">		<span class="comment">// return x + 1;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Other o = <span class="keyword">new</span> Other();</span><br><span class="line">		<span class="keyword">new</span> Something().addOne(o);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">(<span class="keyword">final</span> Other o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// o = new Other();</span></span><br><span class="line">		o.i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure></p></li>
<li><p>抽象类和接口有哪些异同？</p>
<ul>
<li>相同点：
<ul>
<li>不可实例化，都包含抽象方法；</li>
</ul></li>
<li>不同点：
<ul>
<li>抽象类和接口定义、内部结构解释说明（JDK7及前，JDK8，JDK9）</li>
<li>抽象类有构造器，接口无构造器；</li>
<li>单继承和多继承</li>
<li>类与接口的关系：多实现</li>
</ul></li>
<li>JDK8新特性</li>
<li>JDK9新特性</li>
</ul></li>
<li><p>排错 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(x); <span class="comment">// 编译报错，变量不明确</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> C().pX();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Playable</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bounceable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Rollable</span> <span class="keyword">extends</span> <span class="title">Playable</span>, <span class="title">Bounceable</span> </span>&#123;</span><br><span class="line">	Ball ball = <span class="keyword">new</span> Ball(<span class="string">&quot;PingPang&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">implements</span> <span class="title">Rollable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Ball</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ball = <span class="keyword">new</span> Ball(<span class="string">&quot;Football&quot;</span>); </span><br><span class="line">		<span class="comment">// interface中声明和初始化的ball为常量，不可赋值，此处错误</span></span><br><span class="line">		System.out.println(ball.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li><p>static修饰的属性，相较于实例变量，有哪些特别之处</p>
<ul>
<li>随着类的加载而加载，早于对象的创建，只要权限允许，可通过对象.属性的方式进行调用，存在于方法区的静态域中。</li>
</ul></li>
<li><p>final可用来修饰那些结构，分别表示什么意思</p>
<ul>
<li>修饰类（不可继承）、方法（不可重写）、属性（常量）、局部变量（显式初始化、构造器、代码块）</li>
</ul></li>
<li><p>代码实现单例模式的饿汉式和懒汉式</p></li>
<li><p>类的属性赋值位置有哪些？先后顺序为？</p>
<ul>
<li>默认初始化 - 显式初始化 / 代码块 - 构造器 - 创建对象后采用对象.属性或对象.方法方式赋值</li>
</ul></li>
<li><p>abstract能修饰那些结构？修饰以后，有什么特点？</p>
<ul>
<li>abstract可修饰类、方法
<ul>
<li>抽象类无法直接创建对象，必须要被继承并重写内部的所有抽象方法才能创建对象</li>
<li>抽象方法无方法体，只定义了一种功能的标准，具体的执行过程，需要子类去实现</li>
</ul></li>
</ul></li>
<li><p>接口是否能继承接口？抽象类是否能实现接口？抽象类是否能继承非抽象的类</p>
<ul>
<li>接口可以继承接口，且可以多继承</li>
<li>抽象类可以实现接口</li>
<li>抽象类可以继承非抽象的类</li>
</ul></li>
<li><h2 id="声明抽象类并包含抽象方法测试类中创建一个继承抽象类的匿名子类对象">声明抽象类，并包含抽象方法，测试类中创建一个继承抽象类的匿名子类对象</h2></li>
<li><p>抽象类和接口有哪些共同点和区别？</p>
<ul>
<li>抽象类和接口都无法直接创建对象，都可被继承</li>
<li>抽象类有构造器，接口不能声明构造器；单继承 vs 多继承；</li>
</ul></li>
<li><p><strong>如何创建静态成员内部类和非静态成员内部类的对象</strong>？</p>
<ul>
<li>静态成员内部类的对象：外部类.内部类 引用名 = new 外部类.内部类();</li>
<li>非静态成员内部类对象：外部类.内部类 引用名 = 外部类对象名.new.(外部类.)内部类();</li>
</ul></li>
<li><p>static、final、abstract分别能用来修饰什么？联系和区别总结。</p></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章 面向对象编程-中</title>
    <url>/2022/01/11/Coding/Java/05%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%AD/</url>
    <content><![CDATA[<h1 id="第5章面向对象编程-中">第5章、面向对象编程-中</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>目录</li>
<li>一、面向对象的特征之二：继承性</li>
<li>二、方法的重写（override /overwrite）</li>
<li>三、super 关键字</li>
<li>四、子类对象实例化的全过程</li>
<li>五、面向对象特征之三：多态性（重难点）</li>
<li>六、Object 类的使用</li>
<li>七、包装类的使用</li>
<li>面试题</li>
<li>每日一考</li>
</ol>
<span id="more"></span>
<h2 id="一面向对象的特征之二继承性">一、面向对象的特征之二：继承性</h2>
<ol type="1">
<li>继承的好处：
<ul>
<li>减少代码冗余，提高代码复用性</li>
<li>便于功能扩展</li>
<li>为<strong>多态性</strong>的使用提供前提</li>
</ul></li>
<li>继承性格式：class A extends B{ ... }
<ul>
<li>A：子类、派生类、subclass</li>
<li>B：父类、超类、基类、superclass</li>
<li>一旦子类A继承父类B后，字类A中就获取了父类B中声明的所有属性和方法。特别的，父类中声明为私有的属性和方法，子类继承父类后，仍然认为获取了父类中私有的结构，只是因为封装性的影响，使得字类不能直接调用父类的结构而已。（继承是能不能拿到的问题，封装是能不能使用的问题）</li>
<li>子类继承父类后，还可以声明自己特有的属性或方法，实现功能的扩展</li>
<li>子类与父类的关系，不同于数学上子集和集合的关系</li>
<li>extends：延展、扩展</li>
</ul></li>
<li>Java中关于继承性的规定
<ul>
<li>一个类可被多个类继承</li>
<li>一个类只能有一个父类：Java中<strong>类的单继承性</strong></li>
<li>子父类是相对的，支持多层继承（直接父类、间接父类）
<ul>
<li>字类直接继承的父类：直接父类</li>
<li>子类间接继承的父类：间接父类</li>
</ul></li>
<li>字类继承父类后，就获取了直接父类和所有间接父类中声明的属性和方法</li>
</ul></li>
<li>如果没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类。所有的类（除java.lang.Object类）都直接或间接的继承于java.lang.Object类，意味着所有的Java类都具有java.lang.Object类声明的功能</li>
</ol>
<h3 id="附eclipse的debug如何调试程序">附：Eclipse的Debug，如何调试程序</h3>
<ul>
<li>System.out.println();</li>
<li>Eclipse的Debug调试</li>
</ul>
<h2 id="二方法的重写override-overwrite">二、方法的重写（override / overwrite）</h2>
<ol type="1">
<li>重写：字类继承父类后，可对父类中同名同参数的方法进行覆盖操作</li>
<li>应用：重写后，当创建子类对象后，<strong>通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类的方法</strong></li>
<li>面试题：区分方法的重载与重写
<ul>
<li>重载：除参数列表不同不同外，方法名、权限等相同</li>
</ul></li>
<li>重写的规定
<ul>
<li>方法的声明：权限修饰符 返回值类型 方法名(形参列表) { //方法体 }</li>
<li>约定俗成：子类中的叫“重写的方法”；父类中的叫“被重写的方法”</li>
<li>子类重写的方法的方法名和形参列表 与 父类被重写的方法的方法名和形参列表相同</li>
<li>子类重写的方法的权限修饰符 不小于 父类被重写的方法的权限修饰符（子类重写方法的可见性要高于父类的被重写方法）
<ul>
<li>子类不能重写父类中声明为private权限的方法（或者说 子类中与父类声明为private方法同名同参数的方法不能成为重写）</li>
</ul></li>
<li>返回值类型
<ul>
<li>父类中被重写方法返回值类型为void，则子类重写方法返回值类型只能是void</li>
<li>父类中被重写方法返回值类型为A类型，则子类重写方法返回值类型可以是A类型或A类型的子类</li>
<li>父类中被重写方法返回值类型为基本数据类型，则子类重写方法返回值类型必须是相同的基本数据类型</li>
</ul></li>
<li>子类中重写的方法抛出的异常类型不大于父类中被重写的方法抛出的异常类型</li>
<li>子类和父类中同名同参数的方法要么都声明为非static的（重写），要么都声明为static（不是重写，static方法不能覆盖 是随着类的加载而加载的）</li>
</ul></li>
</ol>
<h2 id="三super关键字">三、super关键字</h2>
<ol type="1">
<li>super理解为：父类的</li>
<li>super可用来显式调用父类中的属性、方法、构造器</li>
<li>super的使用，调用父类的属性或方法
<ul>
<li>可在子类的方法或构造器中，通过使用“super.属性”或“super.方法”的方式，显式的调用父类中声明的属性或方法。但通常习惯省略“super.”</li>
<li>特殊情况：当子类和父类中定义了同名的属性时，如想在子类中调用父类中声明的属性，则必须显式的使用“super.属性”的方式，表明调用的是父类中声明的属性。</li>
<li>特殊情况：当子类重写了父类方法后，若想在子类方法中调用父类中被重写的方法时，则必须显式的“super.方法”的方式，表明调用的是父类中被重写的方法。</li>
</ul></li>
<li>super调用父类的构造器
<ul>
<li>可在子类的构造器中显式的使用“super(形参列表)”的方式调用父类中生命的指定的构造器</li>
<li>“super(形参列表)”的使用必须声明在子类构造器的首行</li>
<li>在类的构造器中，针对于"this(形参列表)"或“super(形参列表)”只能二选一，不能同时出现</li>
<li>在构造器函数体首行，没有显式调用"this(形参列表)"和“super(形参列表)”，则默认调用的是父类中的空参构造器（ 即super() ）【一个类被继承时，父类中需要有空参构造器（定义有参构造器前需显式定义空参构造器，否则只有有参构造器时编译器将不会自动添加空参构造器），否则子类中显式定义的构造器会报错、或无显式定义构造器的子类定义处报错.若不想在父类中显式声明无参构造器，则可在子类中显式调用父类的有参构造器】【一个类中有n个构造器，则最多n-1个构造器使用this(形参列表)，剩下的那个使用的是super(形参列表)】</li>
<li>在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表) ”，调用父类的构造器。【子类中会有父类中的属性、方法，是因为调用了super(形参列表)】</li>
</ul></li>
</ol>
<h2 id="四子类对象实例化的全过程">四、子类对象实例化的全过程</h2>
<ul>
<li>从结果看：子类继承父类后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性</li>
<li>从过程看：当通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止，正因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑调用</li>
<li>明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终只是创建过一个对象，即为new的子类对象【构造器负责类中成员变量的初始化】</li>
</ul>
<h2 id="五面向对象特征之三多态性重难点">五、面向对象特征之三：多态性（重难点）</h2>
<h3 id="核心内容">核心内容</h3>
<ol type="1">
<li>多态性理解：一个事物的多种形态</li>
<li>多态性是什么：对象的多态性，父类的引用指向子类的对象（或子类对象赋给父类的引用）</li>
<li>多态性的使用：创建的对象调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法（<strong>虚拟方法调用（Virtual Method Invocation）</strong>）
<ul>
<li>ClassA a = new ClassB(); //A为B的父类</li>
<li>有了对象多态性后，在编译期，只能调用父类中声明的方法，但在运行期，实际执行的是子类重写父类的方法。【总结：编译看左边，运行看右边】对象a无法调用子类ClassB中单独定义的方法</li>
</ul></li>
<li>多态性使用前提
<ul>
<li>类的继承关系</li>
<li>方法的重写</li>
</ul></li>
<li>对象的多态性只适用于重写方法，不适用于同名同类型的属性（属性不构成重写）</li>
<li>虚拟方法：
<ul>
<li>子类中定义了与父 同名参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</li>
<li>虚拟方法调用的过程也可称为<strong>动态绑定</strong>，虚方法动态绑定的子类重写的方法</li>
<li>重载在方法调用之前，编译器就已经确定了所要调用的方法，称为“<strong>早绑定</strong>”或“<strong>静态绑定</strong>”；而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，称为“<strong>晚绑定</strong>”或“<strong>动态绑定</strong>”</li>
</ul></li>
</ol>
<h3 id="instanceof操作符">instanceof操作符</h3>
<p>有了对象的多态性后，内存中实际上是加载了子类特有的属性和方法的，但由于变量声明为父类类型，导致编译时只能允许调用父类中生命的属性和方法，子类中特有的属性和方法不能调用。</p>
<ol type="1">
<li>如何调用子类特有的属性和方法
<ul>
<li>强制类型转换（向下转型）：使用强转时可能出现ClassCastException的异常（编译无报错，运行报错） <img src="/2022/01/11/Coding/Java/05%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%AD/63%20Day%20-%2002.png" alt="向上转型与向下转型"></li>
<li>instanceof关键字（先判断后再强制类型转换）
<ul>
<li>a instanceof A; // 判断对象a是否是类型A的实例，如是则返回true，否则返回false</li>
<li>为了避免向下转型时出现ClassCastException异常，在向下转型前先进性instanceof的判断，一旦返回true就可进行向下转型，否则不能进行向下转型</li>
<li>已知a为A的实例对象，若a instanceof B也为true，则类型B为类型A的父类</li>
</ul></li>
</ul></li>
<li>笔试题 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ProgramExam;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldMethodTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Sub s = <span class="keyword">new</span> Sub();</span><br><span class="line">		System.out.println(s.count); <span class="comment">//20</span></span><br><span class="line">		s.display(); <span class="comment">//20</span></span><br><span class="line">		</span><br><span class="line">		Base b = s;</span><br><span class="line">		<span class="comment">// 对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同</span></span><br><span class="line">		System.out.println(b == s); <span class="comment">//true</span></span><br><span class="line">		System.out.println(b.count);<span class="comment">//10 声明为什么类型就去找那个类型所属的属性</span></span><br><span class="line">		b.display();<span class="comment">//20 重写的多态性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>若子类重写了父类方法，就意味着子类中定义的方法彻底覆盖了父类中的同名方法，系统将不可能把父类里的方法转移到子类中。编译看左边，运行看右边</li>
<li>对于实例变量则不存在这种现象，即使子类中定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。</li>
</ul>
<h2 id="六object类的使用">六、Object类的使用</h2>
<ol type="1">
<li>Object类是所有Java类的根父类</li>
<li>若在类的声明中未使用extends关键字知名其父类，则默认父类为java.lang.Object类</li>
<li>Object类中的功能（属性、方法）就具有通用性
<ul>
<li>无属性</li>
<li>方法：equals() / toString() / getClass() / hashCode() / clone() / finalize() / wait() / notify() / notifyAll()</li>
</ul></li>
<li>== 和equals()的区别：见《面试题》部分6.</li>
<li>Object类中的toString()的使用
<ul>
<li>当输出对象的引用时，实际上是调用当前对象的toString()方法（但当引用为Null时，直接输出引用为null，但调用toString()方法再输出则会出现NullPointerException异常） <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>像String、Date、File、包装类等都重写了Object类中的toString()方法，使得在调用toString()方法时，返回“实体内容”信息</li>
<li>自定义类也可重写toString()方法，当调用此方法时，返回对象的“实体内容”。</li>
<li>source --&gt; Generate toString()自动生成toString()方法</li>
</ul></li>
</ol>
<h2 id="七包装类的使用">七、包装类的使用</h2>
<ol type="1">
<li>java中的JUnit单元测试
<ul>
<li>选中当前工程，右键选择--&gt;build path - add libraries - JUnit 4 - 下一步</li>
<li>创建Java类，进行单元测试
<ul>
<li>此时的Java类要求：
<ul>
<li>此类是public的</li>
<li>此类提供公共的无参构造器</li>
</ul></li>
</ul></li>
<li>此类的单元测试方法
<ul>
<li>测试方法要求：方法的权限是public，没有返回值类型，没有形参</li>
</ul></li>
<li>此单元测试方法上需声明注解：<span class="citation" data-cites="Test">@Test</span>，并在单元测试类中导入：import org.junit.Test;</li>
<li>声明完成单元测试方法后，即可在方法体内测试相关代码</li>
<li>写完方法体代码后，左键双击选中单元测试方法名，右键，run as - JUnit Test</li>
<li>说明：
<ul>
<li>若执行结果没有任何异常，绿条</li>
<li>若执行结果出现异常，红条</li>
</ul></li>
</ul></li>
<li>包装类的使用
<ul>
<li>Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量<strong>具有类的特征</strong></li>
<li>基本数据类型、包装类、String三者之间的相互转换【掌握】
<ul>
<li>基本数据类型和包装类
<ul>
<li>基本数据类型--&gt;包装类：调用包装类的构造函数</li>
<li>包装类--&gt;基本数据类型：调用包装类的XxxValue()</li>
<li>JDK 5.0新特性：<strong>自动装箱 与 自动拆箱</strong>
<ul>
<li>自动装箱 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">Integer in1 = num;</span><br></pre></td></tr></table></figure></li>
<li>自动拆箱 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int num2 = in1;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>基本数据类型和包装类 与 String之间的转换
<ul>
<li>基本数据类型不能直接转换为String类型，但可通过连接运算(String s = num + "")实现转换；或调用String重载的<strong>valueOf(Xxx xxx)</strong></li>
<li>String转换为基本数据类型及包装类：调用包装类的<strong>parseXxx()</strong>（int num = Integer.parseInt(str);）可能会报NumberFormatException异常</li>
</ul></li>
</ul></li>
<li>包装类练习题10 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wrappertestpackage;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">   <span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Practice10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 1. 从键盘读入学生成绩</span></span><br><span class="line">           Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 2. 创建Vector对象，存储学生成绩</span></span><br><span class="line">           Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 找出成绩最高分</span></span><br><span class="line">           <span class="keyword">int</span> maxScore = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;请输入学生成绩（以复数代表输入结束）&quot;</span>);</span><br><span class="line">               <span class="keyword">int</span> score = scan.nextInt();</span><br><span class="line">               <span class="keyword">if</span>(score &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt; <span class="number">100</span>)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;输入数据非法，请重新输入。&quot;</span>);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//JDK5.0前</span></span><br><span class="line">   <span class="comment">//			Integer inScore = new Integer(score);</span></span><br><span class="line">   <span class="comment">//			v.addElement(inScore);</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// JDK5.0后</span></span><br><span class="line">               v.addElement(score);<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(maxScore &lt; score)&#123;</span><br><span class="line">                   maxScore = score;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">&quot;最高成绩为：&quot;</span> + maxScore);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.size(); i++)&#123;</span><br><span class="line">               <span class="keyword">char</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//JDK5.0前</span></span><br><span class="line">   <span class="comment">//			Object obj = v.elementAt(i);</span></span><br><span class="line">   <span class="comment">//			Integer inScore = (Integer)obj;</span></span><br><span class="line">   <span class="comment">//			int score = inScore.intValue();</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// JDK5.0后</span></span><br><span class="line">               <span class="keyword">int</span> score = (<span class="keyword">int</span>)v.elementAt(i);</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span>(maxScore - score &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">                   level = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxScore - score &lt;= <span class="number">20</span>)&#123;</span><br><span class="line">                   level = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxScore - score &lt;= <span class="number">30</span>)&#123;</span><br><span class="line">                   level = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   level = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               System.out.println(<span class="string">&quot;student-&quot;</span> + i + <span class="string">&quot; score is &quot;</span> + score + <span class="string">&quot;, grade is &quot;</span> + level);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h2 id="面试题">面试题</h2>
<ol type="1">
<li>区分方法的重写和重载</li>
</ol>
<ul>
<li>二者的概念</li>
<li>重载和重写的具体规则</li>
<li>重载不表现为多态性，重写表现为多态性</li>
</ul>
<ol start="2" type="1">
<li><p>谈谈你对多态性的理解</p>
<ul>
<li>实现代码的通用性</li>
<li>举例：Object类中定义的public boolean equals(Object obj) {}。JDBC：使用Java操作程序（获取数据库连接、CRUD）数据库（MySQL、Oracle、DB2、SQL Server）</li>
<li>抽象类和接口的使用体现了多态性（抽象类、接口不能实例化）</li>
</ul></li>
<li><p>多态性是编译时行为，还是运行时行为？</p></li>
</ol>
<ul>
<li><p>证明见InterviewTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ProgramExam;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试题：多态是编译时行为还是运行时行为？</span></span><br><span class="line"><span class="comment">//证明如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>  </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal eat food&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;cat eat fish&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Dog eat bone&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>&#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Sheep eat grass&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal  <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Cat ();</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Dog ();</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Sheep ();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> key = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(key);</span><br><span class="line"></span><br><span class="line">		Animal  animal = getInstance(key);</span><br><span class="line">		</span><br><span class="line">		animal.eat();</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>考察多态的笔试题目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ProgramExam;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考查多态的笔试题目：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Base base = <span class="keyword">new</span> Sub();</span><br><span class="line">		base.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		Sub s = (Sub)base;</span></span><br><span class="line"><span class="comment">//		s.add(1,2,3);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;base&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;sub_1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	public void add(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;sub_2&quot;);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4" type="1">
<li>为什么super(形参列表)和this(形参列表)调用语句不能同时在一个构造器中出现？</li>
</ol>
<ul>
<li>因为super(形参列表)和this(形参列表)的调用语句都得出现在首行</li>
</ul>
<ol start="5" type="1">
<li>为什么super(形参列表)或this(形参列表)调用语句只能作为构造器的第一句出现？</li>
</ol>
<ul>
<li>无论通过那个构造器创建子类对象，需要保证先初始化父类。目的：当子类继承父类后，继承父类中所有的属性和方法，因此子类有必要知道父类如何为对象进行初始化</li>
</ul>
<ol start="6" type="1">
<li>final、finally、finalize的区别？</li>
</ol>
<ul>
<li>final、finally为关键词，finalize为函数名</li>
<li>功能差别</li>
</ul>
<ol start="7" type="1">
<li>== 和equals()的区别</li>
</ol>
<ul>
<li>== 运算符
<ul>
<li>可用在基本数据类型变量和引用数据类型的变量中</li>
<li>若比较的是基本数据类型变量，则比较两个变量保存的数据是否相等（不一定类型相同）</li>
<li>若比较的是引用数据类型变量，则比较两个变量保存的地址是否相等（两个引用是否指向同一个实体 或 两个对象的地址是否相等）</li>
<li>补充：==符号使用时，必须保证符号左右两边的变量类型一致（不一定相同）</li>
</ul></li>
<li>equals()方法的使用
<ul>
<li>是一个方法，不是运算符</li>
<li>只适用于引用数据类型</li>
<li>Object类中equals()的定义 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明：Object类中定义的equals()和==的作用是相同的</span></span><br></pre></td></tr></table></figure></li>
<li>像String、Date、File、包装类等都重写了Object类的equals()方法。重写后，比较的不再是两个引用指向的地址是否相同，而是比较两个对象的“实体内容”是否相同</li>
<li>通常情况下，自定义类使用equals()时也通常是比较两个对象的“实体内容”是否相同。那么就需要对Object类中的equals()进行重写 - 重写的原则：比较两个对象的实体 - 注意属性中的String对象比较时要调用equals()函数，不可使用==号 - source --&gt; Generate hashCode() and equals()自动生成自定义类的equals()方法（实际开发中一般使用自动生成的） <img src="/2022/01/11/Coding/Java/05%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%AD/64%20Day%20-%2002.png" alt="重写equals()方法原则"> <img src="/2022/01/11/Coding/Java/05%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%AD/65%20Day%20-%2002.png" alt="【面试题】==和equals()方法的区别"></li>
</ul></li>
</ul>
<ol start="8" type="1">
<li>包装类面试题 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wrappertestpackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Object o1 = <span class="keyword">true</span>? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">		System.out.println(o1); <span class="comment">// 1.0 [三元运算符的类型自动提升]</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Object o2;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(o2); <span class="comment">// 1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">		Integer j = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">		System.out.println(i == j);<span class="comment">// false</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[]，保存了从-128~127范围内的整数。</span></span><br><span class="line">		<span class="comment">//如果使用自动装箱的方式，给Integer赋值的范围在-128~127范围内时，可以直接使用数组内的元素，不用再去new对象了，</span></span><br><span class="line">		<span class="comment">//目的是提高效率。因此，</span></span><br><span class="line">		</span><br><span class="line">		Integer m = <span class="number">1</span>;</span><br><span class="line">		Integer n = <span class="number">1</span>;</span><br><span class="line">		System.out.println(m == n); <span class="comment">// true</span></span><br><span class="line">		<span class="comment">//采用自动装箱且赋值整数在-128~127范围内时，引用是直接指向同一地址的</span></span><br><span class="line">		</span><br><span class="line">		Integer x = <span class="number">128</span>;</span><br><span class="line">		Integer y = <span class="number">128</span>;</span><br><span class="line">		System.out.println(x == y);<span class="comment">// false</span></span><br><span class="line">		<span class="comment">//而当赋值整数超出这个范围时，自动装箱需要去new对象，因此两个引用的地址不相同</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li>什么是多态性？什么是虚拟方法调用？
<ul>
<li>对象的多态性：父类的引用指向子类的对象</li>
<li>调用方法时，编译看左边，运行看右边。在编译期，只能调用父类中声明的方法，但在运行期，实际执行的是子类重写父类的方法</li>
</ul></li>
<li>方法重写的具体规则有哪些？
<ul>
<li>继承关系</li>
<li>同名同参数的方法</li>
<li>权限修饰符</li>
<li>返回值类型</li>
<li>抛出的异常</li>
</ul></li>
<li>super调用构造器，有哪些具体的注意点
<ul>
<li>构造器中没有显式调用super(形参列表)和this(形参列表)时，构造器中会自动调用父类的空参构造器</li>
</ul></li>
<li>如何实现向下转型？需要注意什么问题？如何解决此问题
<ul>
<li>使用强转符(); 有可能出现ClassCastException异常；使用instanceof运算符</li>
</ul></li>
<li>==和equals()有什么区别？
<ul>
<li>==在比较基本数据类型变量时，比较变量存储的值；比较引用数据类型变量时，比较的是引用指向的地址是否相同；equals()为一个方法，只能用于引用数据类型，默认的equals()和==同样比较的是引用指向的地址，String、Date、包装类等类型的equals()进行了重写，比较的是两个对象的“实体内容”，自定义类通常比较的是“实体内容”，那么也需要重写equals()方法</li>
<li>回答套路：1. 直接描述，直到无法描述；2. 不记得的知识点，描述使用情景（表示用过，而不是死记硬背）</li>
</ul></li>
<li>写出8种基本数据类型及其对应的包装类</li>
<li>基本数据类型、包装类与String三者之间如何转换
<ul>
<li>自动装箱、自动拆箱</li>
<li>基本数据类型、包装类 --&gt; String: valueOf(Xxx xxx)</li>
<li>String --&gt; 基本数据类型、包装类：parseXxx(String s)</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章 面向对象编程-上</title>
    <url>/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="第4章面向对象编程-上">第4章、面向对象编程-上</h1>
<h2 id="学习面向对象内容的三条主线">学习面向对象内容的三条主线：</h2>
<ol type="1">
<li><span class="math inline">\(Java\)</span>类及类的成员：属性、方法、构造器；代码块、内部类（<span class="math inline">\(Java\)</span>两大要素：类、对象）</li>
<li>面向对象的三大特征：封装性、继承性、多态性（、抽象性）（关注对应代码落地）</li>
<li>其他关键字：<span class="math inline">\(this\)</span>、<span class="math inline">\(super\)</span>、<span class="math inline">\(static\)</span>、<span class="math inline">\(final\)</span>、<span class="math inline">\(abstract\)</span>、<span class="math inline">\(interface\)</span>、<span class="math inline">\(package\)</span>、<span class="math inline">\(import\)</span>等</li>
</ol>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、面向过程与面向对象</li>
<li>二、Java 基本元素：类和对象</li>
<li>三、对象的创建和使用</li>
<li>四、类的成员之一：属性</li>
<li>五、类的成员之二：方法</li>
<li>六、再谈方法</li>
<li>七、OOP 特征之一：封装与隐藏</li>
<li>八、类的成员之三：构造器（构造方法，constructor）</li>
<li>扩展：JavaBean</li>
<li>扩展：UML 类图</li>
<li>九、关键字：this</li>
<li>十、关键字：package、import</li>
<li>每日一考（构造器、this、package、import）</li>
<li>接下来是：项目二</li>
</ol>
<span id="more"></span>
<h2 id="一面向过程与面向对象">一、面向过程与面向对象</h2>
<ol type="1">
<li><p>面向过程（<span class="math inline">\(POP:\)</span><span class="math inline">\(Procedure\)</span> <span class="math inline">\(Oriented\)</span> <span class="math inline">\(Programming\)</span>）与面向对象（<span class="math inline">\(OOP:\)</span><span class="math inline">\(Object\)</span> <span class="math inline">\(Oriented\)</span> <span class="math inline">\(Programming\)</span>）</p>
<ul>
<li><p>二者都是一种思想，面向对象是相对于面向过程而言的。</p>
<ul>
<li>面向过程，强调的是<strong>功能行为</strong>，以函数为最小单位，考虑<strong>怎么做</strong>。</li>
<li>面向对象，将功能封装进对象，强调<strong>具备了功能的对象</strong>，以类/对象为最小单位，考虑<strong>谁来做</strong></li>
</ul></li>
<li><p>举例：人把大象装进冰箱</p>
<ul>
<li><p>面向过程：①把冰箱门打开；②抬起大象，塞进冰箱；③把冰箱门关闭</p></li>
<li><p>面向对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">人&#123; </span><br><span class="line">	打开(冰箱)&#123;</span><br><span class="line">		冰箱.开门(); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	抬起(大象)&#123;</span><br><span class="line">		大象.进入(冰箱);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	关闭(冰箱)&#123;</span><br><span class="line">		冰箱.关门();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">冰箱&#123;</span><br><span class="line">	开门()&#123;...&#125;</span><br><span class="line">	关门()&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">大象&#123;</span><br><span class="line">	进入(冰箱) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>面向对象的三大特征</p>
<ul>
<li>封装（<span class="math inline">\(Encapsulation\)</span>）</li>
<li>继承（<span class="math inline">\(Inheritance\)</span>）</li>
<li>多态（<span class="math inline">\(Polymorphism\)</span>）</li>
</ul></li>
<li><p>面向对象的思想概述</p>
<ul>
<li>程序员从面向过程的<strong>执行者</strong>转化为了面向对象的<strong>指挥者</strong></li>
<li>面向对象分析方法分析问题的思路和步骤
<ul>
<li>根据问题需要，选择问题所针对的现实世界中的实体</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类</li>
<li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义，即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构</li>
<li>将类实例化成计算机世界中的对象，对象是计算机世界中解决问题的最终工具</li>
</ul></li>
</ul></li>
</ol>
<h2 id="二java基本元素类和对象">二、<span class="math inline">\(Java\)</span>基本元素：类和对象</h2>
<ol type="1">
<li><p>面向对象的思想概述</p>
<ul>
<li>类（<span class="math inline">\(Class\)</span>）和对象（<span class="math inline">\(Object\)</span>）是面向对象的核心概念
<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义。例如水果、花、人，其在代码上的体现类似于<span class="math inline">\(int\)</span>、<span class="math inline">\(char\)</span>、<span class="math inline">\(String\)</span>。</li>
<li>对象是实际存在的该事物的个体，也被称为实例（<span class="math inline">\(Instance\)</span>）。例如苹果、玫瑰花、某个具体的人，在代码上的体现类似于某个数据类型声明的变量。</li>
<li>面向对象程序设计的重点是<strong>类的设计</strong>；类的设计，其实就是<strong>类的成员的设计</strong>。</li>
</ul></li>
<li>“万事万物皆对象”
<ul>
<li>Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构
<ul>
<li>Scanner、String等</li>
<li>文件，File</li>
<li>网络资源，URL</li>
</ul></li>
<li>涉及到Java语言与前端Html、后端数据库交互时，前后端的结构在Java层面交互时都体现为类和对象</li>
</ul></li>
</ul></li>
<li><p><span class="math inline">\(Java\)</span>类及类的成员</p>
<ul>
<li>Java代码世界是由诸多个不同功能的类构成的</li>
<li>Java中常见的类成员有：
<ul>
<li>属性 = 成员变量 = field = 域、字段，对应类中的成员变量</li>
<li>方法 = 成员方法 = 函数 = method，对应类中的成员方法</li>
</ul></li>
</ul></li>
</ol>
<h2 id="三对象的创建和使用">三、对象的创建和使用</h2>
<ol type="1">
<li><p>对象创建：<code>类名 对象名 = new 类名()</code>;</p>
<ul>
<li>创建类的对象 = 类的实例化 = 实例化类</li>
</ul></li>
<li><p>类和对象的使用（面向对象思想落地的实现）</p>
<ul>
<li>创建类，设计类的成员</li>
<li>创建类的对象</li>
<li>通过<code>"对象.属性"</code>或<code>"对象.方法"</code>调用对象的结构</li>
</ul></li>
<li><p>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性（非static），修改其中一个对象的属性不影响另一个对象的属性值。</p></li>
<li><p>对象的内存解析</p></li>
</ol>
<figure>
<img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/62%20Day4%20-%2001.png" alt="对象的内存解析"><figcaption aria-hidden="true">对象的内存解析</figcaption>
</figure>
<p>内存解析的说明：引用数据类型的变量只可能存两类值：null 或 地址值（含变量的类型）</p>
<h2 id="四类的成员之一属性">四、类的成员之一：属性</h2>
<ul>
<li>属性（成员变量）VS 局部变量
<ul>
<li>相同点
<ul>
<li>定义格式：数据类型 变量名 = 变量值;</li>
<li>先声明后使用</li>
<li>都有其对应的作用域</li>
</ul></li>
<li>不同点
<ul>
<li>在类中声明的位置不同：
<ul>
<li>属性直接定义在类的一对{}中、方法体外；</li>
<li>局部变量是声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量。</li>
</ul></li>
<li>权限修饰符不同：
<ul>
<li>属性：可在声明属性时，指明其权限、使用权限修饰符（常见修饰符：private、public、缺省、protected）</li>
<li>局部变量：不可使用权限修饰符，只能用final（其权限可由方法修饰符体现）</li>
</ul></li>
<li>默认初始化值
<ul>
<li>属性：根据其类型，都有其初始化值<br> 整形（byte、short、int、long）：0<br> 浮点型（float、double）：0.0<br> 字符型（char）：0或'000'<br> 布尔型（boolean）：false<br> 引用数据类型（类、接口、数组）：null<br></li>
<li>局部变量：没有默认初始化值，在调用局部变量前必须要显式赋值（特别的，形参在调用时赋值即可）。</li>
</ul></li>
<li>在内存中加载的位置
<ul>
<li>属性：加载到堆空间中（非static）</li>
<li>局部变量：加载到栈空间</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="五类的成员之二方法">五、类的成员之二：方法</h2>
<ul>
<li><p>方法：描述类应该具有的功能</p>
<ul>
<li><p>方法的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名([形参列表])&#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>说明</p>
<ul>
<li>权限修饰符：private、public、缺省、protected</li>
<li>返回值类型：有返回值 VS 无返回值
<ul>
<li>如方法有返回值，则必须在方法声明时，指定返回值类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量</li>
<li>如方法无返回值，则方法声明时使用void来表示。无返回值的方法中无需使用return，但可使用“return;”结束方法。（return后不能直接声明其他语句）</li>
</ul></li>
<li>方法名：标识符，遵循标识符的命名规则和规范，“见名知意”</li>
<li>形参列表：
<ul>
<li>方法可定义0个、1个或多个形参</li>
<li>格式：<code>数据类型1 形参1, 数据类型2 形参2, ...</code></li>
</ul></li>
<li>方法体：方法功能的体现。</li>
</ul></li>
<li><p>方法的使用中，可调用当前类的属性和方法。方法中不能定义方法</p></li>
</ul></li>
<li><p>练习</p>
<ol type="1">
<li>编写教师类和学生类，并通过测试类创建对象进行测试。</li>
<li>创建一个Person类，其定义如下：要求(1)创建Person类的对象，设置该对象的name、age、sex属性，调用study方法，输出字符串"studying"，调用showAge()方法显示age值，调用addAge()方法给对象的age属性增加2岁；(2)创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123; <span class="comment">//测试类</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">          <span class="comment">//构造Person类的对象</span></span><br><span class="line">          Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">          <span class="comment">//调用对象的结构：属性和方法</span></span><br><span class="line">          <span class="comment">//调用属性：“对象.属性”</span></span><br><span class="line">          p1.name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">          p1.age = <span class="number">18</span>;</span><br><span class="line">          p1.sex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//调用方法：“对象.方法”</span></span><br><span class="line">          p1.study();</span><br><span class="line">          p1.showAge();</span><br><span class="line">          System.out.println(p1.addAge(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">          Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">          p2.name = <span class="string">&quot;sam&quot;</span>;</span><br><span class="line">          p2.age = <span class="number">12</span>;</span><br><span class="line">          p2.sex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//调用方法：“对象.方法”</span></span><br><span class="line">          p2.study();</span><br><span class="line">          p2.showAge();</span><br><span class="line">          System.out.println(p2.addAge(-<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; <span class="comment">//Person类</span></span><br><span class="line">      String name;</span><br><span class="line">      <span class="keyword">int</span> age;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * sex: 0 - Female; 1 - Male;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;studying&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(age);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addAge</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">          age += i;</span><br><span class="line">          <span class="keyword">return</span> age;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>利用面向对象的编程方法，设计类Circle计算圆的面积。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleTest</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">          Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">          c1.radius = <span class="number">10</span>;</span><br><span class="line">          System.out.println(c1.area());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">double</span> radius;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>编写程序，声明一个method方法，在方法中打印一个10*8的*型矩阵，在main方法中调用该方法</li>
</ol>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exer3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Exer3 m = <span class="keyword">new</span> Exer3();</span><br><span class="line">        m.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++)</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="5" type="1">
<li>修改上一个程序，在method方法中，除打印10*8的*型矩阵外，再计算该矩形的面积，并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。</li>
</ol>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exer3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Exer3 m = <span class="keyword">new</span> Exer3();</span><br><span class="line">        <span class="keyword">int</span> area = m.method();</span><br><span class="line">        System.out.println(<span class="string">&quot;面积为：&quot;</span>+ area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++)</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>*<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="6" type="1">
<li>修改上一个程序，在method方法提供m和n两个参数，方法中打印m*n的*型矩阵，并计算该矩阵的面积，将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。</li>
</ol>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exer3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Exer3 m = <span class="keyword">new</span> Exer3();</span><br><span class="line">        <span class="keyword">int</span> area = m.method(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;面积为：&quot;</span>+ area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m*n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="7" type="1">
<li>对象数组题目：定义类Student，包含3个属性：学号number(int)，年级state(int)，成绩score(int)，创建20个学生对象，学号为1到20，年级和成绩由随机数确定。
<ul>
<li>问题1：打印出3年级(state为3)的学生信息</li>
<li>问题2：使用冒泡排序按学生成绩排序，并遍历所有学生信息</li>
<li>提示：
<ul>
<li>生成随机数：Math.random();返回值为double类型</li>
<li>四舍五入取整：Math.round(double d);返回值为long类型</li>
</ul></li>
</ul></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">                   <span class="comment">//此处只是开辟一块20个Student类型的对象数组空间，该空间的首地址值赋值给数组名stu</span></span><br><span class="line">                   <span class="comment">//定义对象数组后，每个数组元素初始值为null。</span></span><br><span class="line">                   <span class="comment">//如不为每个元素初始化将会在后面调用时产生NullPointerException异常</span></span><br><span class="line"> 		Student[] stu = <span class="keyword">new</span> Student[<span class="number">20</span>];</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;stu.length; i++)&#123;</span><br><span class="line">                   <span class="comment">//数组元素的类型为Student，故初始化时使用new Student()分配内存空间</span></span><br><span class="line">                   <span class="comment">//并将空间的地址赋值给元素</span></span><br><span class="line">                   <span class="comment">//String、int等类型无需new，是因为数组元素为基本数据类型或可以直接赋值（地址传递），</span></span><br><span class="line">                   <span class="comment">//如String s = &quot;15sadw&quot;;（字符串常量或变量传递给字符串数组元素是地址传递）</span></span><br><span class="line">                   <span class="comment">//int类型数组元素的值是直接存在堆的相应位置的，无需再次分配空间</span></span><br><span class="line">                   <span class="comment">//分配内存空间就要使用 new关键字，并且返回空间的首地址值</span></span><br><span class="line">                   <span class="comment">//而自定义的类声明的对象也可进行地址传递,但需要先new一个该类型的变量然后再地址传递，</span></span><br><span class="line">                   <span class="comment">//也可直接开辟一块内存空间（new Student()），并将该空间首地址值赋给数组元素</span></span><br><span class="line"> 		stu[i] = <span class="keyword">new</span> Student();</span><br><span class="line"> 			stu[i].setNumber(i+<span class="number">1</span>);</span><br><span class="line"> 			stu[i].setState((<span class="keyword">int</span>)Math.round((Math.random()*<span class="number">5</span>)));</span><br><span class="line"> 			stu[i].setScore((<span class="keyword">int</span>)Math.round((Math.random()*<span class="number">100</span>)));</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">//遍历输出</span></span><br><span class="line"> 		System.out.println(<span class="string">&quot;初始化：&quot;</span>);</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;stu.length; i++)&#123;</span><br><span class="line"> 			System.out.println(stu[i].getNumber() + <span class="string">&quot;\tis @ grade_&quot;</span> + stu[i].getState() + <span class="string">&quot;, score is &quot;</span> + stu[i].getScore());</span><br><span class="line"> 		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//输出年级为3的学生信息</span></span><br><span class="line"> 		System.out.println(<span class="string">&quot;3年级学生信息：&quot;</span>);</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;stu.length; i++)&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(stu[i].getState() == <span class="number">3</span>)</span><br><span class="line"> 				System.out.println(stu[i].getNumber() + <span class="string">&quot;\tis @ grade_&quot;</span> + stu[i].getState() + <span class="string">&quot;, score is &quot;</span> + stu[i].getScore());</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line">		<span class="comment">//冒泡排序</span></span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;stu.length; i++)&#123;</span><br><span class="line"> 			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;stu.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line"> 				<span class="keyword">if</span>(stu[j].getScore() &gt; stu[j+<span class="number">1</span>].getScore())&#123;</span><br><span class="line"> 					Student temp = <span class="keyword">new</span> Student();</span><br><span class="line"> 					temp = stu[j];</span><br><span class="line"> 					stu[j] = stu[j+<span class="number">1</span>];</span><br><span class="line"> 					stu[j+<span class="number">1</span>] = temp;</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		<span class="comment">//遍历输出</span></span><br><span class="line">	System.out.println(<span class="string">&quot;排完序后：&quot;</span>);</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;stu.length; i++)&#123;</span><br><span class="line"> 			System.out.println(stu[i].getNumber() + <span class="string">&quot;\tis @ grade_&quot;</span> + stu[i].getState() + <span class="string">&quot;, score is &quot;</span> + stu[i].getScore());</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * 学号, int型</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="keyword">int</span> number;</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 年级, int型</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="keyword">int</span> state;</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * 分数, int型</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="keyword">int</span> score;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * </span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@Description</span> 获得学生的分数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@date</span> 2020年10月16日下午4:40:40</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@return</span> int型 分数</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> score;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * </span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@Description</span> 获得学生的学号</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@date</span> 2020年10月16日下午4:40:58</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@return</span> int型 学号</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> number;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * </span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@Description</span> 获得学生的年级</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@date</span> 2020年10月16日下午4:42:02</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@return</span> int型 年级</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> state;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * </span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@Description</span> 设置学生的成绩</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@date</span> 2020年10月16日下午4:51:16</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@param</span> score</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">this</span>.score = score;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * </span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@Description</span> 设置学生的学号</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@date</span> 2020年10月16日下午4:50:57</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span> 设置学生的年级</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> Hunter Wu</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span> 2020年10月16日下午4:51:31</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>每日一考</p></li>
</ul>
<ol type="1">
<li><p>面向对象思想编程内容的三条主线分别是什么</p>
<ul>
<li><span class="math inline">\(Java\)</span>类及类的成员：属性、方法、构造器、代码块、内部类</li>
<li>面向对象三大特征：封装性、继承性、多态性（，抽象性）</li>
<li>其他关键字：<span class="math inline">\(this\)</span>、<span class="math inline">\(super\)</span>、<span class="math inline">\(static\)</span>、<span class="math inline">\(final\)</span>、<span class="math inline">\(abstract\)</span>、<span class="math inline">\(interface\)</span>、<span class="math inline">\(package\)</span>、<span class="math inline">\(import\)</span>等</li>
</ul></li>
<li><p>面向对象的编程思想？【面试】</p></li>
<li><p>谈谈你对面向对象中类和对象的理解，并指出二者的关系<br> 面试中，先进行一些描述，然后再举出一些例子，但是举的例子应为开发场景中的例子（比如我们和控制台交互需要提供一个类，这个API给我们提供好了叫做Scanner类，这是类的概念。我们真正执行的时候需要一个Scanner对象，然后通过这个对象来调用他所定义的功能方法，去完成与控制台的交互）</p>
<ul>
<li>类：抽象的、概念上的内容</li>
<li>对象：实实在在存在的一个实体</li>
<li>对象是由类派生出来的（new出来的）</li>
</ul></li>
<li><p>面向对象思想的体现一：类和对象的创建和执行操作有那三步？</p>
<ul>
<li>创建类</li>
<li>类的实例化</li>
<li>调用对象的结构：“对象.属性”、“对象.方法”</li>
</ul></li>
<li><p>类的方法内是否可以定义变量？是否可以调用属性？是否可以定义方法？是否可以调用方法？</p>
<p>是，是，否，是</p></li>
</ol>
<h3 id="补jvm内存结构">补：JVM内存结构</h3>
<ul>
<li>编译完源程序后，生成一个或多个字节码文件。我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析</li>
</ul>
<figure>
<img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/JVM内存结构.jpg" alt="JVM内存结构"><figcaption aria-hidden="true">JVM内存结构</figcaption>
</figure>
<ul>
<li>各个结构
<ul>
<li>虚拟机栈即为平时提到的栈结构。将局部变量存放在栈结构中</li>
<li>堆，将new出来的结构（如数组、对象）加载在堆空间中。补充：对象的属性（非static）加载在堆空间中</li>
<li>方法区：类的加载信息（方法、代码块等）、常量池、静态域（static）</li>
<li>本地方法栈：调用本地C/C++时使用</li>
</ul></li>
</ul>
<h3 id="补匿名对象">补：匿名对象</h3>
<ol type="1">
<li><p>创建的对象没有显式的赋给一个变量名，即为匿名对象</p></li>
<li><p>特征：一个匿名对象只能使用一次。</p></li>
<li><p>使用：无需另外定义一个变量即可创建一个对象并使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exer_2_1</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line">         System.out.println(p);</span><br><span class="line"></span><br><span class="line">         p.sendEmail();</span><br><span class="line">         p.playGame();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//匿名对象</span></span><br><span class="line">         <span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line">         <span class="keyword">new</span> Phone().showPrice();</span><br><span class="line">	</span><br><span class="line">         <span class="comment">//匿名对象的使用</span></span><br><span class="line">         PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line">         mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span></span>&#123;</span><br><span class="line">             phone.sendEmail();</span><br><span class="line">             phone.playGame();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;手机价格为：&quot;</span> + price);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="六再谈方法">六、再谈方法</h2>
<ol type="1">
<li><p>方法的重载（overload）</p>
<ul>
<li>重载的概念
<ul>
<li>在同一个类中，允许存在一个以上的同名方法，<strong>只要</strong>它们的参数个数或者类型不同即可。</li>
</ul></li>
<li>重载的特点：
<ul>
<li>与返回值类型无关，只看参数列表,且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</li>
<li><strong>两同一不同</strong>：同一个类、相同方法名；参数列表不同：参数个数或参数类型或不同类型的参数顺序不同</li>
<li><strong>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系</strong></li>
</ul></li>
<li>重载示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回两个整数的和</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+y;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//返回三个整数的和</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+y+z;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//返回两个小数的和</span></span><br><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+y;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在通过对象调用方法时，如何确定某一个指定的方法：方法名--&gt;参数列表</li>
</ul></li>
<li><p>可变形参的方法</p>
<ul>
<li>定义：JavaSE5.0中提供了Varargs(variable number of arguments)机制，<strong>允许直接定义能和多个实参相匹配的形参</strong>。从而可以用一种更简单的方式，来传递个数可变的实参。</li>
<li>使用：
<ul>
<li>格式：<code>数据类型 ... 变量名</code></li>
<li>当调用可变个数形参的方法时，传入的参数个数可以是0个、1个、2个...</li>
<li>可变个数形参的方法与本类中其他的方法名相同、形参不同的方法构成重载</li>
<li>可变个数形参的方法与本类中其他的方法名相同、形参相同的方法不构成重载。（5.0前使用数组传入多个参数(String[] args)；5.0后使用...表示可变个数参数(String ... args)，在形参变量的使用上和数组使用方式相同）</li>
<li>可变个数形参在方法的形参中，必须声明在末尾（防止编译器分不清参数该传给谁）</li>
<li>可变个数形参在方法的形参中，最多只能声明一个可变形参</li>
</ul></li>
</ul></li>
<li><p>方法参数的值传递机制（难重点）</p>
<ul>
<li>变量赋值：传递的是栈空间的值
<ul>
<li>如变量是基本数据类型，则赋值的是变量所保存的数据值</li>
<li>如变量是引用数据类型，则赋值的是变量所保存的数据地址值</li>
</ul></li>
<li>形参与实参
<ul>
<li>形参：方法定义时，声明的小括号内的参数</li>
<li>实参：方法调用时，实际传递给形参的数据</li>
</ul></li>
<li><strong>方法形参的传递机制：值传递（不是引用传递）</strong>
<ul>
<li>如参数是基本数据类型，则实参赋给形参的值是实参所保存的数据值</li>
<li>如参数是引用数据类型，则实参赋给形参的值是实参所保存的数据地址值</li>
</ul></li>
</ul></li>
<li><p>递归方法</p>
<ul>
<li>定义：一个方法体内调用它本身</li>
</ul></li>
<li><p>每日一考</p>
<ul>
<li>什么是方法的重载
<ul>
<li>两同一不同</li>
</ul></li>
<li>说明Java方法中的参数传递机制的具体体现
<ul>
<li>如参数为基本数据类型，则传递的是...</li>
<li>如参数是引用数据类型，则传递的是...</li>
</ul></li>
<li>成员变量和局部变量在声明的位置上、是否有默认初始化值上、是否能有权限修饰符修饰上、内存分配的位置上有何不同
<ul>
<li>成员变量声明在类中，有默认初始化值，可有权限修饰符，内存分配在堆中</li>
<li>局部变量声明在方法中，无默认初始化值，不可有权限修饰符，内存分配在栈中</li>
</ul></li>
<li>谈谈return关键字的使用
<ul>
<li>返回方法执行结果</li>
<li>结束方法执行</li>
</ul></li>
</ul></li>
<li><p>面试题</p>
<ul>
<li>方法的重载与重写的区别？</li>
<li>throws  throw</li>
<li>String  StringBuffer StringBuilder</li>
<li>Collection  Collections</li>
<li>final  finally </li>
<li>...相似的概念或类及方法及时总结</li>
</ul></li>
</ol>
<h2 id="七oop特征之一封装与隐藏">七、<span class="math inline">\(OOP\)</span>特征之一：封装与隐藏</h2>
<ol type="1">
<li>为什么要封装和隐藏？其作用和含义是什么？
<ul>
<li>我们程序设计追求“高内聚，低耦合”。
<ul>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li>低耦合 ：仅对外暴露少量的方法用于使用。</li>
</ul></li>
<li>隐藏对象内部的复杂性，只外公开简单接口。便于外界调用从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。 <strong>这就是封装性的设计思想</strong></li>
</ul></li>
<li>问题的引入：
<ul>
<li>当我们创建一个类的对象后，我们可以通过<code>"对象.属性"</code>的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约，但是除此之外，没有其他制约条件。而在实际问题中，我们往往需要给属性赋值加入额外的限制条件（实际问题的逻辑限制），这个条件不能在属性声明时体现，我们只能通过属性所在类中的方法进行限制条件的添加。</li>
<li>同时，我们需要避免用户再使用<code>"对象.属性"</code>的方式对属性进行无逻辑限制的赋值，因此需要将属性声明为私有的（private）</li>
<li>以上针对属性就体现了封装性</li>
</ul></li>
<li>封装性的体现（不等同于封装性，只是封装性的一个体现）
<ul>
<li>我们将类的属性私有化（private），同时，提供公共（public）的方法来获取（getXxx）和设置（setXxx）此属性的值</li>
</ul></li>
<li>封装性的其他体现：① 如上3；②不对外暴露的私有方法；③ 单例模式；④ 如果不希望类在包外被调用，可将类设置为缺省的。</li>
<li>封装性的体现，需要权限修饰符来配合
<ul>
<li>Java规定了4种权限修饰符（从小到大）：private、缺省、protected、public；四种范围：类内、同一个包内、不同包的字类内、同一工程内 <img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/Chap4.7%20-%201.bmp" alt="4种权限修饰符"></li>
<li>4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类
<ul>
<li><strong>修饰类的话：只能使用缺省、public</strong>【问题：public类可在同一工程中访问，那为什么不同包中重名的类可以同时存在。解答：因为权限修饰符只是表明可见性的大小，调用不同的类可以用包名去区别，public只是表明可以在工程中的任意位置调用，并不限制同名是否可以存在】</li>
</ul></li>
</ul></li>
<li>总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</li>
</ol>
<h2 id="八类的成员之三构造器构造方法constructor">八、类的成员之三：构造器（构造方法，constructor）</h2>
<ol type="1">
<li>构造器的作用（只要造对象就要用构造器）
<ul>
<li>创建对象</li>
<li>初始化对象的信息（属性或方法）</li>
</ul></li>
<li>构造器使用说明
<ul>
<li>如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器（该构造器权限和类的权限是相同的）(一个类中一定有构造器)</li>
<li>定义构造器的格式：权限修饰符 类名(形参列表) { }</li>
<li>一个类中定义的多个构造器，彼此构成重载</li>
<li><strong>一旦显式的定义了类的构造器，系统就不再提供默认的空参构造器</strong></li>
<li>一个类中至少会有一个构造器</li>
</ul></li>
<li>构造器与方法有一定的区别：构造器是用来创建对象的；而方法是由对象进行调用的</li>
<li>属性的赋值过程，赋值顺序为① - ② - ③ - ④，其中① - ② - ③是在对象实例出前执行，只执行一次，而④是可以重复多次执行的
<ul>
<li>① 默认初始化值</li>
<li>② 显式初始化</li>
<li>③ 构造器中初始化</li>
<li>④ 通过“对象.属性”或“对象.方法”进行复制</li>
</ul></li>
</ol>
<h2 id="扩展javabean">扩展：JavaBean</h2>
<p>JavaBean是一种Java语言写成的可重用组件</p>
<ol type="1">
<li>定义：
<ul>
<li>所谓JavaBean是值符合如下标准的Java类：
<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的set和get方法</li>
</ul></li>
</ul></li>
</ol>
<h2 id="扩展uml类图">扩展：UML类图</h2>
<figure>
<img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/Chap4.8%20-%201.bmp" alt="UML类图"><figcaption aria-hidden="true">UML类图</figcaption>
</figure>
<h2 id="九关键字this">九、关键字：<span class="math inline">\(this\)</span></h2>
<ul>
<li>this的使用：可用来调用属性、方法、构造器
<ul>
<li>其中，this可理解为当前<strong>对象</strong>（针对方法） 或 当前正在创建的对象（针对构造器）
<ul>
<li>在类的方法中，可使用“this.属性”或“this.方法”的方式调用当前对象的属性或方法。但是，在通常情况下，我们都省略“this.”。在特殊情况下：例如方法或构造器的形参和类的属性同名时，我们必须显式的使用“this.属性”的方式表明此变量是属性，而非形参。</li>
<li>在类的构造器中，可使用“this.属性”或“this.方法”的方式调用当前正在创建的对象的属性或方法。但是，在通常情况下，我们都省略“this.”。在特殊情况下：例如构造器的形参和类的属性同名时，我们必须显式的使用“this.属性”的方式表明此变量是属性，而非形参。</li>
</ul></li>
<li>this调用构造器的用法
<ul>
<li>在类的<strong>构造器中</strong>，可显式的使用“this(形参列表)”方式，调用本类中指定的其他构造器</li>
<li>构造器中不能通过“this(形参列表)”的方式调用自己</li>
<li>如果一个类中有n个构造器，则最多有n-1构造器中使用了“this(形参列表)”</li>
<li>规定：“this(形参列表)”必须声明在当前构造器的首行</li>
<li>构造器内部，最多只能声明一个“this(形参列表)”用来调用其他的构造器</li>
</ul></li>
</ul></li>
</ul>
<h2 id="十关键字packageimport">十、关键字：<span class="math inline">\(package\)</span>、<span class="math inline">\(import\)</span></h2>
<ol type="1">
<li>package关键字的使用
<ul>
<li>为了更好的实现项目中类的管理，提供了包的概念</li>
<li>使用package声明类或接口所属的包，声明在源文件中的首行</li>
<li>包属于标识符，遵循标识符的命名规则（见名知意）、规范（小写）</li>
<li>每“.”一次，就代表一层文件目录</li>
<li>补充：<strong>同一个包下，不可以命名同名的接口、类；不同包下可命名同名的接口或类</strong></li>
<li>JDK中主要的包介绍 <img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/Chap4.10%20-%201.bmp" alt="JDK中主要的包"></li>
</ul></li>
<li>MVC设计模式 <img src="/2021/11/25/Coding/Java/04%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/Chap4.10%20-%202.bmp" alt="MVC设计模式"></li>
<li>import关键字的使用
<ul>
<li>在源文件中显式的使用import结构导入指定包下的类或接口</li>
<li>声明位置：在源文件中的包声明和类声明之间</li>
<li>如需导入多个结构，则并列写出即可；</li>
<li>可使用xxx.*的方式导入xxx包下的所有结构（类或接口）</li>
<li>如果使用的类或接口是java.lang包下的，则可省略import结构</li>
<li>如果使用的类或接口是本包下的，则可省略import结构</li>
<li>如果在源文件中，使用了不同包下的两个同名类，则必须至少有一个需要以全类名的方式（xxx.xxxx.xx.类名）调用</li>
<li>使用“xxx.*”的方式可以调用xxx包下的所有结构，但如果使用的是xxx子包下的结构则仍需显式使用“xxx.子包”结构导入</li>
<li>import static 可以导入指定类或接口<strong>中</strong>的静态结构（属性或方法）</li>
</ul></li>
</ol>
<h2 id="每日一考构造器thispackageimport">每日一考（构造器、this、package、import）</h2>
<ol type="1">
<li>构造器的作用是什么？使用中有哪些注意点（&gt;= 3条）
<ul>
<li>作用：创建对象、初始化对象信息</li>
<li>注意点：
<ul>
<li>当没有显式声明构造器时，类会提供了一个默认的无参构造器</li>
<li>一个类中定义的多个构造器，彼此构成重载</li>
<li><strong>一旦显式的定义了类的构造器，系统就不再提供默认的空参构造器</strong></li>
</ul></li>
</ul></li>
<li>关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序
<ul>
<li>① 默认值</li>
<li>② 显式初始化</li>
<li>③ 构造器初始化</li>
<li>④ 通过<code>“对象.属性”</code>或<code>“对象.方法”</code>的方式赋值</li>
<li>先后顺序是：① - ② - ③ - ④</li>
</ul></li>
<li>this关键字可用来调用那些结构，简单说明一下其使用
<ul>
<li>this可用来调用属性、方法、构造器</li>
<li>this代表的是 当前使用的对象 或 正在创建的对象。使用“this.属性”或“this.方法”的方式调用正在使用对象中的属性或方法。使用“this(形参列表)”方式调用与其形参列表匹配的构造函数</li>
</ul></li>
<li>java中目前学习涉及到的四种权限修饰符都有什么？并说明各自的权限范围
<ul>
<li>private、缺省、protected、public</li>
<li>private仅能在同一个类中可见</li>
<li>缺省仅能在同一个类或同一包下可见</li>
<li>protected仅能在同一个类、同一包、不同包下的子类中可见</li>
<li>public可在同一个类、同一包、不同包下的子类、同一工程中可见</li>
</ul></li>
</ol>
<h1 id="接下来是项目二">接下来是：项目二</h1>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章 Java数组</title>
    <url>/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="第3章-数组">第3章 数组</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、数组的概述</li>
<li>二、一维数组的使用</li>
<li>三、多维数组的概念</li>
<li>四、二维数组的使用</li>
<li>五、扩展</li>
<li>六、数组中常用的算法</li>
<li>七、Arrays 工具类的使用</li>
<li>八、数组中常见的异常</li>
</ol>
<span id="more"></span>
<h2 id="一数组的概述">一、数组的概述</h2>
<ol type="1">
<li><p>数组，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p></li>
<li><p>数组的常见概念</p>
<ul>
<li>数组名</li>
<li>下标（索引）</li>
<li>元素</li>
<li>数组的长度：元素的个数</li>
</ul></li>
<li><p>数组的特点</p>
<ul>
<li>元素排列是有序的</li>
<li>数组属于<strong>引用数据类型的变量</strong>。元素即可是基本数据类型、也可是引用数据类型</li>
<li>创建数组对象会在内存中开辟一整块连续的空间</li>
<li>数组的长度一旦确定，就不能修改</li>
</ul></li>
<li><p>数组的分类</p>
<ul>
<li>按维数：一维数组、二维数组、...</li>
<li>按元素的类型：基本数据类型元素的数组、引用数据类型元素的数组</li>
</ul></li>
</ol>
<h2 id="二一维数组的使用">二、一维数组的使用</h2>
<ol type="1">
<li><p>一维数组的声明和初始化</p>
<ul>
<li>声明：<code>基本数据类型[ ] 数组名;</code></li>
<li>初始化
<ul>
<li><strong>静态初始化</strong>：数组的初始化和数组元素的赋值操作同时进行
<ul>
<li>例：<code>int[ ] ids; ids = new int[ ]&#123;1001, 1002, 1003, 1004&#125;;</code></li>
</ul></li>
<li><strong>动态初始化</strong>：数组的初始化和数组元素的赋值操作分开进行
<ul>
<li>例：<code>String[ ] names = new String[5];</code></li>
</ul></li>
</ul></li>
<li>错误写法：
<ul>
<li><code>int[] arr1 = new int[];</code></li>
<li><code>int[2] arr2 = new int[2];</code></li>
<li><code>int[] arr3 = new int[3]&#123;1,2,3&#125;;</code></li>
</ul></li>
<li>总结：数组一旦初始化完成，其长度就确定了（初始化完成后需要开辟内存空间）</li>
</ul></li>
<li><p>如何调用数组指定位置的元素：通过角标的方式调用</p>
<ul>
<li>数组的角标（或索引）从0开始，到数组长度-1结束</li>
<li>如需获得String元素类型数组的每个元素中的单个字符，只需对元素调用charAt方法</li>
</ul></li>
<li><p>如何获取数组的长度：属性——length</p>
<ul>
<li>array.length</li>
</ul></li>
<li><p>如何遍历数组: for循环</p></li>
<li><p>数组元素的默认初始化值</p>
<ul>
<li>在分配了数组内存空间后，在没有对数组元素显式赋值时，元素具有默认值</li>
<li>数组元素是整型时：默认值为0</li>
<li>数组元素是浮点型时：默认值为0.0</li>
<li>数组元素是char型时：默认值为0</li>
<li>数组元素是boolean型：默认值为false</li>
<li>数组元素是引用数据类型时：null（关键字）</li>
</ul></li>
<li><p>数组的内存解析（内存结构在JVM规范中有讲解）</p>
<ul>
<li><p>内存简化结构结构有栈（stack）、堆（heap）、方法区（又分为常量池、静态域）</p>
<ul>
<li>栈中主要存放局部变量（放在方法中的变量都是局部变量）</li>
<li>堆中主要存放new出来的结构：对象、数组</li>
<li>常量池主要存放String</li>
<li>静态域主要存放static</li>
</ul></li>
<li><p>对于以下代码 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">String[] arr1 = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">arr1[<span class="number">1</span>] = <span class="string">&quot;刘德华&quot;</span>;</span><br><span class="line">arr1[<span class="number">2</span>] = <span class="string">&quot;张学友&quot;</span>;</span><br><span class="line">arr1 = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p></li>
<li><p>第1行代码执行时内存中的变化为：</p>
<ul>
<li>因为方法中的变量都是局部变量，因此在main方法中声明并初始化的arr变量首先加入到栈中</li>
<li>再经过初始化，就需要给数组分配内存空间。因为数组主要存放在堆中，因此会在堆中开辟一定长度的连续空间，并将这段空间的首地址存入栈中的arr变量，且空间中各元素均为0；之后再将初始化值赋给各元素。</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/55%20Day3%20-%2001.png" alt="第1行代码执行时内存中的变化"><figcaption aria-hidden="true">第1行代码执行时内存中的变化</figcaption>
</figure>
<ul>
<li>第2行代码执行时内存中的变化为：
<ul>
<li>基本和第1行代码执行时变化相同</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/56%20Day3%20-%2002.png" alt="第2行代码执行时内存中的变化"><figcaption aria-hidden="true">第2行代码执行时内存中的变化</figcaption>
</figure>
<ul>
<li>第3行代码执行时内存中的变化为：
<ul>
<li>根据arr1在栈中的值找到堆中的一块空间，在该空间中从首地址开始寻找角标个元素空间即是要调用的值空间。</li>
<li>然后将该空间的值改为指定值即可</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/57%20Day3%20-%2003.png" alt="第3行代码执行时内存中的变化"><figcaption aria-hidden="true">第3行代码执行时内存中的变化</figcaption>
</figure>
<ul>
<li>第4行代码执行时内存中的变化为：
<ul>
<li>栈中的变量仍为arr1，只是需在堆中再次新开辟一块空间，并将新开辟空间的首地址赋值给arr1。因此相当于只更改了栈中arr1的值</li>
<li>此时垃圾回收器将会在之后的一个不确定的时间把之前的数组空间进行回收。垃圾回收使用的算法为引用计数算法，即判断堆中的一块空间是否还有栈空间中的引用指过来。（当main函数执行完后，局部变量都将会依此出栈，垃圾回收器判断堆中的空间是否还有栈中空间引用它，对于出完栈的变量将会把它之前引用的空间释放）</li>
</ul></li>
</ul></li>
<li><p>练习<br> 升景坊单间短期出租4个月 ，550 元/月（水电煤公摊，网费 35 元/月），空调、卫生间厨房齐全。屋内均是 IT 行业人士，喜欢安静。 所以要求来租者最好是同或刚毕的年轻爱干净、行业人士，喜欢安静。所以要求来租者最好是同或刚毕的年轻爱干净、</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用执行程序的方式筛选IT人士</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span> &#125;;</span><br><span class="line">            <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span> &#125;;</span><br><span class="line">            String tel = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">                tel += arr[index[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot; 联系方式： &quot;</span> + tel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从键盘输入学生的成绩，找出最高分，并输出学生的成绩等级：<br> 成绩&gt;=最高分-10分 等级为A<br> 成绩&gt;=最高分-20分 等级为B<br> 成绩&gt;=最高分-30分 等级为C<br> 其他 等级为D</p>
<figure>
<img src="/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/60%20Day3%20-%2006.png" alt="题目程序实现"><figcaption aria-hidden="true">题目程序实现</figcaption>
</figure>
<blockquote>
<p>请输入学生人数：5<br> 请输入5个学生的成绩：<br> 15<br> 20<br> 25<br> 50<br> 70<br> 最高分为:70<br> student 0 score is 15 grade is D<br> student 1 score is 20 grade is D<br> student 2 score is 25 grade is D<br> student 3 score is 50 grade is B<br> student 4 score is 70 grade is A<br></p>
</blockquote></li>
</ol>
<h2 id="三多维数组的概念">三、多维数组的概念</h2>
<p>因为数组为引用数据类型,而数组元素可以是基本数据类型、也可是引用数据类型，引用数据类型的元素可以是引用数据类型，即可看成一维数组arr1作为另一个一维数组arr2的元素就是二维数组。其实，从数组底层的运行机制来看，是没有多维数组的，只是数组名指向的数组中的元素指向的又是一个一维数组。</p>
<h2 id="四二维数组的使用">四、二维数组的使用</h2>
<ol type="1">
<li><p>二维数组的声明和初始化</p>
<ul>
<li>二维数组初始化
<ul>
<li>静态初始化：<code>int[][] arr1 = new int[][]&#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125; &#125;;</code></li>
<li>动态初始化：<code>String[][] arr2 = new String[3] [2];或String[][] arr2 = new String[3] [];</code></li>
<li>其他正确写法：<code>int[] arr1[] = new int[][]&#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125; &#125;;</code>或<code>int arr1[][] = new int[][]&#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125; &#125;;</code>或<code>int arr1[][] = &#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125; &#125;;（叫做类型推断，该用法只能将声明和初始化写在一行时有用，分开写时是错误的）</code></li>
</ul></li>
</ul></li>
<li><p>如何调用数组指定位置的元素：通过角标的方式调用</p>
<ul>
<li>当数组初始化时没有给内层数组初始化，如<code>String[][] arr2 = new String\[3][];</code>若在后面需要调用arr2[1][0]时，需在调用之前再次初始化内层数组：arr2[1] = new String[4];</li>
</ul></li>
<li><p>如何获取数组的长度：属性——length</p>
<ul>
<li>array.length输出第一维数组的长度</li>
<li>array[0].length输出第二维（第1行）的数组长度</li>
</ul></li>
<li><p>如何遍历数组 两层for循环： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; arr[i].length; j++)&#123;</span><br><span class="line">		System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>数组元素的默认初始化值 规定：二维数组分为外层数组元素和内层数组元素，且初始化值一般都说的是动态初始化的元素值</p>
<ul>
<li>外层数组元素
<ul>
<li>在动态初始化后，默认值为地址值：结构为“[类型缩写@地址”，例如int型外层数组元素的值为[I@1586135，int型二维数组名的值为[[I@15618641</li>
<li>当数组在初始化时并没有对内层数组初始化，则外层数组的默认值为null。因为引用数据类型的默认值都为null</li>
</ul></li>
<li>内层数组元素
<ul>
<li>初始化值为声明和初始化时类型的默认值（与一维数组初始化情况相同）</li>
<li>若数组在初始化时并没有对内层数组初始化，则调用内层数组元素时报错（空指针异常）</li>
</ul></li>
</ul></li>
<li><p>数组内存解析 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">arr1[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">30</span>;</span><br></pre></td></tr></table></figure> <img src="/2021/11/24/Coding/Java/03Java%E6%95%B0%E7%BB%84/61%20Day3%20-%2007.png" alt="数组内存解析示意图"></p></li>
<li><p>复习</p></li>
</ol>
<ul>
<li>写出一维数组初始化的两种方式
<ul>
<li>答：分为静态初始化和动态初始化
<ul>
<li>静态初始化：int[] arr1 = new int[]{1, 2, 3};</li>
<li>动态初始化：int[] arr1 = new int[3]; 数组一旦初始化，其长度就是确定的；数组长度一旦是确定的，就不可修改</li>
</ul></li>
</ul></li>
<li>写出二维数组初始化的两种方式
<ul>
<li>答：分为静态初始化和动态初始化
<ul>
<li>静态初始化：<code>int[] [] arr1 = new int\[][]&#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;7&#125; &#125;;</code></li>
<li>动态初始化：<code>int[] [] arr1 = new int[[3] [3];或int[] [] arr1 = new int[3] [];</code></li>
</ul></li>
</ul></li>
<li>如何遍历如下的二维数组 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123; &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>答： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; arr[i].length; j++)&#123;</span><br><span class="line">		System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>不同类型的一维数组元素的默认初始化值各是多少
<ul>
<li>答：分为基本数据类型和引用数据类型
<ul>
<li>对于基本数据类型：byte：0、short：0、char：0、int：0、long：0、boolean：false、float：0.0、double：0.0</li>
<li>对于引用数据类型：（类、数组、接口）都是null</li>
</ul></li>
</ul></li>
<li>一维数组的内存解析 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">strs[<span class="number">2</span>] = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">strs = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="8" type="1">
<li>练习</li>
</ol>
<ul>
<li>使用二维数组打印一个10行杨辉三角</li>
</ul>
<h2 id="五扩展">五、扩展</h2>
<ol type="1">
<li>数据结构：
<ul>
<li>数据与数据之间的逻辑关系：集合、一对一（链表）、一对多（树形结构）、多对多（网络、图）</li>
<li>数据的存储结构：
<ul>
<li>线性表（一对一）：顺序表、链表、栈、队列（堆）</li>
<li>树形结构（一对多）：二叉树、...</li>
<li>图形结构（多对多）：有向、无向图</li>
</ul></li>
</ul></li>
<li>算法：
<ul>
<li>排序算法</li>
<li>搜索算法</li>
</ul></li>
</ol>
<h2 id="六数组中常用的算法">六、数组中常用的算法</h2>
<ol type="1">
<li><p>数组元素的赋值（杨辉三角、回形数等）【笔试考查】：</p>
<p>【拓展之笔试题】：</p>
<ul>
<li><p>创建一个长度为6的int型数组，要求数组元素的值都在1-30之间，且是随机赋值。同时，要求元素的值各不相同</p></li>
<li><p>回形数格式方针的实现</p></li>
</ul></li>
<li><p>求数值型数组中元素的最大值、最小值、平均值、总和等</p>
<ul>
<li>定义一个int型的一维数组，包含10个元素，分别赋一些随机整数，然后求出所有元素的最大值、最小值、和、平均值，并输出。要求：所有随机数都是两位数</li>
</ul>
<p>随机数生成：(int)(Math.random() * (99 - 10 + 1) + 10);</p></li>
<li><p>数组的复制、反转、查找（线性查找、二分查找）【笔试考查】</p>
<ul>
<li><p>复制<br> 使用简单数组<br> (1)创建一个名为ArrayTest的类，在main()方法中声明array1和array2两个变量，他们是int[]类型的数组<br> (2)使用大括号{}，把array1初始化为8个素数：2, 3, 5, 7, 11, 13, 17, 19<br> (3)显示array1的内容<br> (4)赋值array2变量等于array1，修改array2中偶索引元素，使其等于索引值，打印出array1<br> <strong>思考</strong>：array1和array2是什么关系：array1和array2存储的地址值相同，都指向堆空间中的唯一一个数组实体<br> <strong>拓展</strong>：修改题目，实现array2对array1数组的复制</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//数组的复制</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exerc6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//声明array1和array2数组</span></span><br><span class="line">        <span class="keyword">int</span>[] array1, array2;</span><br><span class="line">        <span class="comment">//初始化array1</span></span><br><span class="line">        array1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>&#125;;</span><br><span class="line">        <span class="comment">//显示array1的内容</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.length; i++)&#123;</span><br><span class="line">            System.out.print(array1[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//赋值array2变量等于array1</span></span><br><span class="line">        array2 = array1;</span><br><span class="line">        <span class="comment">//修改array2中偶索引元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                array2[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示array1的内容</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.length; i++)&#123;</span><br><span class="line">            System.out.print(array1[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//array2对array1数组的复制</span></span><br><span class="line">        array2 = <span class="keyword">new</span> <span class="keyword">int</span>[array1.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.length; i++)&#123;</span><br><span class="line">            array2[i] = array1[i];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;DD&quot;</span>, <span class="string">&quot;EE&quot;</span>, <span class="string">&quot;FF&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组的复制</span></span><br><span class="line">        String[] arr1 = <span class="keyword">new</span> String[arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">            arr1[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组的反转</span></span><br><span class="line">        <span class="comment">//方法一</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            String temp = arr[i];</span><br><span class="line">            arr[i] = arr[arr.length - i - <span class="number">1</span>];</span><br><span class="line">            arr[arr.length - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方法二</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = arr.length - <span class="number">1</span>; i &lt; j; i++, j--)&#123;</span><br><span class="line">            String temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找/搜索</span></span><br><span class="line">        <span class="comment">//线性查找</span></span><br><span class="line">        String dest = <span class="string">&quot;BB&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dest.equals(arr[i]))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;找到了，位置是：&quot;</span> + i);</span><br><span class="line">                isFlag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="comment">//前提：所要查找的数组须是有序的</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">98</span>, -<span class="number">34</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">66</span>, <span class="number">79</span>, <span class="number">105</span>, <span class="number">210</span>, <span class="number">333</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dest1 = -<span class="number">34</span>;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>, end = arr2.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isFlag1 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (head + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr2[mid] == dest1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;找到了，位置为：&quot;</span> + mid);</span><br><span class="line">                isFlag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr2[mid] &lt; dest1)&#123;</span><br><span class="line">                head = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>数组元素的排序算法【笔试考查】</p>
<ul>
<li><p>排序算法</p>
<ul>
<li>排序：假设含有n个记录的序列为{R1, R2, ..., Rn}，其相应的关键字序列为{K1, K2, ..., Kn}。将这些记录重新排序为{Ri1, Ri2, ..., Rin}，使得相应的关键字值满足Ki1 &lt;= Ki2 &lt;= ... &lt;= Kin，这样的一种操作称为排序。</li>
<li>通常来说排序的目的是快速查找</li>
<li>衡量排序算法的优劣
<ul>
<li>时间复杂度：关键字的比较次数和记录的移动次数</li>
<li>空间复杂度：算法中需要多少辅助内存</li>
<li>稳定性（专指排序算法）：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。</li>
</ul></li>
<li>排序算法分类：
<ul>
<li>内部排序：整个排序过程不需要借助外部存储器，所有排序操作都在内存中完成</li>
<li>外部排序：参与排序的数据非常多、数据量大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器，外部排序最常见的是多路归并排序，可认为外部排序是由多次内部排序组成的。</li>
</ul></li>
<li>十大内部排序算法：
<ul>
<li>选择排序：直接选择排序，<strong>堆排序</strong>【了解思想】</li>
<li>交换排序：<strong>冒泡排序</strong>、<strong>快速排序</strong>【需会手写】</li>
<li>插入排序：直接插入排序、折半插入排序、Shell排序（希尔排序）</li>
<li><strong>归并排序</strong>【了解思想】</li>
<li>桶式排序</li>
<li>基数排序</li>
</ul></li>
</ul>
<p>冒泡排序（O(<span class="math inline">\(n^2\)</span>)） <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSortTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">43</span>, <span class="number">32</span>, <span class="number">76</span>, -<span class="number">98</span>, <span class="number">0</span>, <span class="number">64</span>, <span class="number">33</span>, -<span class="number">21</span>, <span class="number">32</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = arr.clone();</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="comment">//先找出最大的数，并从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i -<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    isFlag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先找出最小的数，并从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = arr1.length - <span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[j] &lt; arr1[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr1[j];</span><br><span class="line">                    arr1[j] = arr1[j-<span class="number">1</span>];</span><br><span class="line">                    arr1[j-<span class="number">1</span>] = temp;</span><br><span class="line">                    isFlag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr1[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 快速排序（O(<span class="math inline">\(nlog_{2}(n)\)</span>)） <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大话数据结构中的快速排序算法思想（递归章节）和讲到的算法思想区别</span></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ol>
<h2 id="七arrays工具类的使用">七、Arrays工具类的使用</h2>
<p>java.util.Arrays：操作数组的工具类，其中有许多操作数组的方法。具体可查看API文档。</p>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>boolean equals(int[] a, int[] b)</td>
<td>判断两个数组是否相等</td>
</tr>
<tr class="even">
<td>2</td>
<td>String toString(int[] a)</td>
<td>输出数组信息</td>
</tr>
<tr class="odd">
<td>3</td>
<td>void fill(int[] a, int val)</td>
<td>将指定值填充到数组之中</td>
</tr>
<tr class="even">
<td>4</td>
<td>void sort(int[] a)</td>
<td>对数组进行排序</td>
</tr>
<tr class="odd">
<td>5</td>
<td>int binarySearch(int[] a, int key)</td>
<td>对排序后的数组进行二分法检索指定的值</td>
</tr>
</tbody>
</table>
<h2 id="八数组中常见的异常">八、数组中常见的异常</h2>
<ol type="1">
<li><p>数组角标越界异常：<span class="math inline">\(ArrayIndexOutOfBoundsException\)</span></p>
<ul>
<li>索引超过数组索引范围的就属于角标越界异常，负数也是角标越界（python有些区别）</li>
</ul></li>
<li><p>空指针异常：<span class="math inline">\(NullPointerException\)</span></p>
<ul>
<li>情况1：</li>
<li>情况2：</li>
<li>情况3： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayException</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           <span class="comment">//情况1</span></span><br><span class="line">           <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">           arr1 = <span class="keyword">null</span>;</span><br><span class="line">           System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//情况2</span></span><br><span class="line">           <span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">           System.out.println(arr2[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//情况3</span></span><br><span class="line">           String[] arr3 = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;;</span><br><span class="line">           arr3[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line">           System.out.println(arr3[<span class="number">0</span>].toString());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章 Java基本语法</title>
    <url>/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="第2章-基本语法">第2章 基本语法</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、关键字与保留字</li>
<li>二、标识符（identifier）</li>
<li>三、变量</li>
<li>四、每日一考</li>
<li>五、运算符</li>
<li>六、流程控制</li>
<li>七、每日一考</li>
<li>八、补充</li>
</ol>
<span id="more"></span>
<h2 id="一关键字与保留字">一、关键字与保留字</h2>
<p>关键字（keyword）</p>
<ul>
<li>定义：被Java语言赋予了特殊含义，用作专门用途的字符串（单词）</li>
<li>特点：关键字中所有字母都为小写</li>
</ul>
<p><img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/05%20Day2%20-%2001.png" alt="Java关键字"> <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/05%20Day2%20-%2002.png" alt="Java关键字"></p>
<p>保留字（reserved word）</p>
<ul>
<li>Java保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字。例如goto、const</li>
</ul>
<h2 id="二标识符identifier">二、标识符（identifier）</h2>
<ul>
<li>标识符：
<ul>
<li>Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li>
<li>技巧：凡是要起名字的地方就是标识符</li>
</ul></li>
<li><strong>命名规则</strong>：
<ul>
<li>由26个英文字母大小写、0-9、_或$组成</li>
<li>不可以数字开头</li>
<li>不可使用关键字和保留字，但可包含关键字或保留字</li>
<li>Java中严格区分大小写、长度无限制</li>
<li>标识符不能包含空格</li>
</ul></li>
<li>Java中的名称<strong>命名规范</strong>：
<ul>
<li>包名：多单词组成时，所有单词<strong>都小写</strong>（xxyyzz）</li>
<li>类名、接口名：多单词组成时，所有单词首字母大写（XxYyZz）</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写、第二个单词开始每个单词首字母大写（xxYyZz）</li>
<li>常量名：所有字母<strong>都大写</strong>，多单词时每个单词用下划线连接（XX_YY_ZZ）</li>
<li>注意：
<ul>
<li>在起名字时要见名知意</li>
<li>java采用unicode字符集，因此标识符可使用汉字声明，但不建议使用</li>
<li>更多细节详见《代码整洁之道》</li>
</ul></li>
</ul></li>
</ul>
<h2 id="三变量">三、变量</h2>
<ul>
<li>变量的概念：
<ul>
<li>内存中的一个存储区域</li>
<li>该区域内数据可在同一类型范围内不断变化</li>
<li>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值</li>
</ul></li>
<li>变量的作用：
<ul>
<li>用于在内存中保存数据</li>
</ul></li>
<li>使用变量时注意：
<ul>
<li>Java中每个变量必须先声明、后使用</li>
<li>使用变量名来访问这块区域的数据</li>
<li>变量作用域：其定义所在的{}内</li>
<li>同一作用域内不能声明两个同名变量</li>
</ul></li>
<li>变量分类（按数据类型分类）：
<ul>
<li>基本数据类型（primitive type）
<ul>
<li>数值型
<ul>
<li>整数类型（byte、short、int、long）</li>
<li>浮点类型（float、double）</li>
</ul></li>
<li>字符型（char）</li>
<li>布尔型（boolean）</li>
</ul></li>
<li>引用数据类型（reference type）
<ul>
<li>类（class） &lt;-- 字符串在这里</li>
<li>接口（interface）</li>
<li>数组（[ ]）</li>
</ul></li>
</ul></li>
<li>变量分类（按在类中声明的位置分类）：
<ul>
<li>成员变量（在方法体外，类体内声明的变量称为成员变量）
<ul>
<li>实例变量（不以static修饰）</li>
<li>类变量（以static修饰）</li>
</ul></li>
<li>局部变量（在方法体内部声明的变量称为局部变量）
<ul>
<li>形参（方法、构造器中定义的变量）</li>
<li>方法局部变量（在方法内定义）</li>
<li>代码块局部变量（在代码块中定义）</li>
</ul></li>
<li>成员变量和局部变量在初始化值方面的异同
<ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，需显式初始化</li>
</ul></li>
</ul></li>
</ul>
<h3 id="一基本数据类型">（一）基本数据类型</h3>
<h4 id="整数类型byteshortintlong">整数类型：byte、short、int、long</h4>
<ul>
<li>Java中各整数类型<strong>有固定的表数范围和字段长度</strong>，不受OS影响，以保证Java程序的可移植性</li>
<li>Java整型<strong>常量</strong>默认为int，声明long型常量需要在其后加'l'或‘L’</li>
<li>Java中整数类型的位数表（超出对应的类型表数范围 编译报错）：</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类型</th>
<th style="text-align: center;">占用存储空间</th>
<th style="text-align: left;">表数范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">byte</td>
<td style="text-align: center;">1字节</td>
<td style="text-align: left;">-128 ~ 127</td>
</tr>
<tr class="even">
<td style="text-align: center;">short</td>
<td style="text-align: center;">2字节</td>
<td style="text-align: left;">-<span class="math inline">\(2^{15}\)</span> ~ <span class="math inline">\(2^{15}-1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">int</td>
<td style="text-align: center;">4字节</td>
<td style="text-align: left;">-<span class="math inline">\(2^{31}\)</span> ~ <span class="math inline">\(2^{31}-1\)</span>（约21亿）</td>
</tr>
<tr class="even">
<td style="text-align: center;">long</td>
<td style="text-align: center;">8字节</td>
<td style="text-align: left;">-<span class="math inline">\(2^{63}\)</span> ~ <span class="math inline">\(2^{63} - 1\)</span> （声明long型变量也需在初始化值后加'l'或‘L’）</td>
</tr>
</tbody>
</table>
<h4 id="浮点型floatdouble">浮点型：float、double</h4>
<ul>
<li>Java浮点型也<strong>有固定的表数范围和字段长度</strong>，不受OS影响</li>
<li>浮点型常量有2种表示形式：
<ul>
<li>十进制形式：5.12、512.0f、.512</li>
<li>科学计数法形式：5.12E2、512E2、100E-2</li>
</ul></li>
<li>float：单精度，尾数可精确到7位有效数字。多数情况下精度较难满足要求</li>
<li>double：双精度，精度是float的两倍，通常采用此类型</li>
<li>Java中浮点类型常量默认是double型，声明float型常量需在其后加'f'或'F'</li>
</ul>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>float</td>
<td>4字节</td>
<td>-3.403E38 ~ 3.403E38 （定义float变量时，初始化值需要以'f'或'F'结尾）</td>
</tr>
<tr class="even">
<td>double</td>
<td>8字节</td>
<td>-1.798E308 ~ 1.798E308</td>
</tr>
</tbody>
</table>
<h4 id="字符型char">字符型：char</h4>
<ul>
<li>一个字符占据2字节</li>
<li>定义char类型通常使用一对单引号 ‘ ’，且单引号内部只能有一个字符</li>
<li>Java中的<strong>所有字符</strong>都使用Unicode编码，故可存储任何国家的语言的一个字符</li>
<li>char类型表示方式：
<ul>
<li>声明一个字符（char c = 'A'）</li>
<li>转义字符（char c = '\n';）</li>
<li>直接使用Unicode值来表示字符型常量（char c = '\uXXXX'; XXXX代表一个十六进制数）</li>
</ul></li>
<li>char类型也可进行运算，因为每个字符都有对应的Unicode码</li>
<li>win10命令行读取文件默认采用GBK字符集，当文件编码方式不是GBK时某些字符会在输出时乱码。（EditPlus的ANSI即表示GBK编码）</li>
</ul>
<h4 id="布尔型boolean">布尔型：boolean</h4>
<ul>
<li>只能取两个值之一：true、false</li>
<li>用于条件判断</li>
<li>转义字符前再加一个\将会输出该转义字符（如：println( "\\\n") ）；println双引号中需要使用双引号强调某个字符时可在内部双引号前加\（如println( "...\"...\"..." ) ）</li>
</ul>
<h3 id="二基本数据类型转换只有7种类型变量之间的运算不包含boolean类型">（二）基本数据类型转换（只有7种类型变量之间的运算，不包含boolean类型）</h3>
<ul>
<li><p>自动类型提升：</p>
<ul>
<li><strong>自动类型转换</strong>：（不同容量大小的类型变量运算时）容量小的类型自动转换为容量大的数据类型
<ul>
<li>byte、char、short --&gt; int --&gt; long --&gt; float --&gt; double；</li>
<li>此处容量大小指的是表数范围大小</li>
</ul></li>
<li>有多种类型的数据混合运算时，系统首先自动将所有数据转换为容量最大的那种数据类型，然后再进行计算。
<ul>
<li>计算后的数据若不以容量大的类型变量接收，编译报错；</li>
<li>若以浮点型变量接收整形运算结果，输出时会在整数值后加上 .0</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/06%20Day2%20-%2003.png" alt="计算后的数据若不以容量大的类型变量接收，编译报错"><figcaption aria-hidden="true">计算后的数据若不以容量大的类型变量接收，编译报错</figcaption>
</figure>
<ul>
<li><p><strong>注意</strong>：</p></li>
<li><p><strong>byte、short、char</strong>之间<strong>不会相互转换</strong>，他们三者在混合计算或同种类型运算时<strong>首先转换为int类型</strong>（java在做运算时如果操作数均在int范围内，那么一律在int的空间内运算）</p>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/07%20Day2%20-%2004.png" alt="byte、short、char 之间不会相互转换，他们三者在混合计算或同种类型运算时首先转换为 int 类型"><figcaption aria-hidden="true">byte、short、char 之间不会相互转换，他们三者在混合计算或同种类型运算时首先转换为 int 类型</figcaption>
</figure>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/08%20Day2%20-%2005.png" alt="byte、short、char 之间不会相互转换，他们三者在混合计算或同种类型运算时首先转换为 int 类型"><figcaption aria-hidden="true">byte、short、char 之间不会相互转换，他们三者在混合计算或同种类型运算时首先转换为 int 类型</figcaption>
</figure>
<ul>
<li><p>boolean类型不能与其他数据类型运算</p></li>
<li><p>当把任何基本数据类型的值和字符串（String）进行连接运算（+）时，基本数据类型的值将自动转化为字符串（String）类型</p></li>
</ul></li>
</ul></li>
<li><p>强制类型转换：自动类型提升的<strong>逆运算</strong></p>
<ul>
<li>需要使用强转符： ()
<ul>
<li>如：int b1 = (int) d1;</li>
</ul></li>
<li>注意：强制类型转换可能导致精度转换（如double转化为int型时会将小数部分截断）</li>
</ul></li>
</ul>
<h3 id="三字符串类型string">（三）字符串类型：String</h3>
<ul>
<li>String类型不是基本数据类型，属于引用数据类型</li>
<li>使用方式与基本数据类型一致。例如：String str = "abcd";</li>
<li>一个字符串可串接另一个字符串、或直接串接其他类型的数据。运算的结果仍是String类型
<ul>
<li>str = str + "xyz";</li>
<li>int n = 100;</li>
<li>str = str + n; （此处+号为连接运算）</li>
</ul></li>
<li>字符型变量在单引号内必须有且只有1个；而字符串在双引号内可存放任意（包含0）个字符</li>
</ul>
<p>String类型和其他类型<strong>运算</strong>时的注意点：</p>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/09%20Day2%20-%2006.png" alt="String 类型和其他类型运算时的注意点"><figcaption aria-hidden="true">String 类型和其他类型运算时的注意点</figcaption>
</figure>
<h3 id="进制与进制之间的转换">进制与进制之间的转换</h3>
<ul>
<li>对于整数，计算机中有4种表示方式：
<ul>
<li>二进制（binary）：0, 1。以0b或0B开头</li>
<li>十进制（decimal）：0-9</li>
<li>八进制（octal）：0-7。以数字0开头</li>
<li>十六进制（hex）：0-9及A-F。以0x或0X开头，此处A-F不区分大小写</li>
</ul></li>
</ul>
<h4 id="二进制与十进制之间的转换">二进制与十进制之间的转换</h4>
<ul>
<li>二进制：
<ul>
<li>正数的原码、反码、补码都是一致的</li>
<li>负数的原码为其相反数原码且符号位为1；负数的反码为其原码除符号位取反；负数的补码为其反码+1（或 负数的补码为其相反数的原码取反+1）</li>
<li>计算机的底层都以<strong>补码</strong>的方式存储数据</li>
</ul></li>
<li>十进制转二进制：除2取余的逆</li>
</ul>
<h4 id="二进制与八进制十六进制之间的转换">二进制与八进制、十六进制之间的转换</h4>
<ul>
<li>二进制与八进制之间转换：每3位二进制数表示1位八进制数；每1位八进制数表示3位二进制数</li>
<li>二进制与十六进制转换：每4位二进制数表示1位十六进制数；每1位十六进制数表示4位二进制数</li>
</ul>
<h2 id="四每日一考">四、每日一考</h2>
<ol type="1">
<li><p>标识符的命名规则有哪些？</p>
<blockquote>
答：
<ul>
<li>标识符可由26个英文字母、0-9数字和_以及$组成，且不能以数字开头</li>
<li>不可使用关键字和保留字，但可包含关键字或保留字</li>
<li>Java中严格区分大小写、长度无限制</li>
<li>标识符不能包含空格</li>
</ul>
</blockquote></li>
<li><p>标识符的命名规范有哪些？</p>
<blockquote>
答：
<ul>
<li>包名：所有单词小写</li>
<li>类名和接口名：首字母大写</li>
<li>变量和方法：第一个单词全部小写，从第二个单词开始首字母大写</li>
<li>常量：全部大写，多个单词使用下划线连接</li>
<li>注意：
<ul>
<li>在起名字时要见名知意</li>
<li>java采用unicode字符集，因此标识符可使用汉字声明，但不建议使用</li>
<li>更多细节详见《代码整洁之道》</li>
</ul></li>
</ul>
</blockquote></li>
<li><p>Java变量按照数据类型怎么划分？并指出Java的基本数据类型有哪8种，并指出各自占用的内存大小</p>
<blockquote>
答：
<ul>
<li>基本数据类型
<ul>
<li>数值型
<ul>
<li>整数型【byte(1字节)、short(2字节)、int(4字节)、long(8字节)】</li>
<li>浮点型【float(4字节)、double(8字节)】</li>
</ul></li>
<li>字符型【char(2字节)】</li>
<li>布尔型【boolean】</li>
</ul></li>
<li>引用数据类型
<ul>
<li>类（class）</li>
<li>接口（interface）</li>
<li>数组（[ ]）</li>
</ul></li>
</ul>
</blockquote></li>
<li><p>说明基本数据类型变量之间自动类型提升的运算规则</p>
<blockquote>
答：
<ul>
<li>在多种类型变量混合运算时，容量小的先转换为容量大的类型，结果为容量最大的类型</li>
<li>byte、short、char类型变量混合运算或其中单一类型变量运算时，需首先转换为int类型再进行运算，结果为int类型</li>
<li>byte、char、short --&gt; int --&gt; long --&gt; float --&gt; double；</li>
</ul>
</blockquote></li>
<li><p>说明基本数据类型变量之间强制类型转换的使用规则和强转可能出现的问题</p>
<blockquote>
答：
<ul>
<li>当容量大的类型转换为容量小的类型时需要使用强制类型转换，强制类型转换使用方式：类型A 变量v = (类型A)变量b;</li>
<li>强转可能会损失数据精度</li>
</ul>
</blockquote></li>
</ol>
<h2 id="五运算符">五、运算符</h2>
<p>运算符是一种特殊符号，用以表示数据的运算、赋值、比较等。 分类：</p>
<ul>
<li>算术运算符</li>
<li>赋值运算符</li>
<li>比较运算符（关系运算符）</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>三元运算符</li>
</ul>
<h3 id="一算术运算符">（一）算术运算符</h3>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/10%20Day2%20-%2007.png" alt="Java中的算数运算符"><figcaption aria-hidden="true">Java中的算数运算符</figcaption>
</figure>
<ul>
<li>取模（%）运算结果的符号与被模数的符号一致，与模数符号无关</li>
<li>自增1 / 自减1
<ul>
<li>前++：先自增1，再运算（包括赋值）</li>
<li>后++：先运算（包括赋值），后自增1</li>
<li><strong>自增不会改变变量的数据类型（short b = 1; b++; 中b的类型不会变）</strong></li>
<li>前--和后--类似</li>
<li>自增或自减不能连续使用（num++++; 或 (num++)++; 或 ++num++;），否则会报错</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/11%20Day2%20-%2008.png" alt="前++和后++测试"><figcaption aria-hidden="true">前++和后++测试</figcaption>
</figure>
<h3 id="二赋值运算符">（二）赋值运算符</h3>
<ul>
<li>符号：=</li>
<li>扩展：+=，-=，*=，/=，%=；<strong>这些运算不会改变结果的数据类型（short i = 2; i += 1; 不会报错，与i = i + 1还是有区别的）</strong></li>
<li>用法：
<ul>
<li>可连续赋值：i1 = j1 =10;</li>
<li>共同使用一个类型：int i1 = 10, i2 = 9;</li>
<li>i1 += 2 等价于 i1 = i1 + 2;（其他类似）</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/12%20Day2%20-%2009.png" alt="赋值运算与++运算符混合运算测试"><figcaption aria-hidden="true">赋值运算与++运算符混合运算测试</figcaption>
</figure>
<h3 id="三比较运算符">（三）比较运算符</h3>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/13%20Day2%20-%2010.png" alt="Java中的比较运算符"><figcaption aria-hidden="true">Java中的比较运算符</figcaption>
</figure>
<ul>
<li>比较运算符的结果都是boolean型</li>
<li>&lt; &gt; &gt;= &lt;=只能用于数值类型数据之间</li>
<li>== 和 !=：不仅可以使用在数值类型数据之间，还可使用在其他引用类型变量之间(例如new的两个对象比较)</li>
</ul>
<h3 id="四逻辑运算符">（四）逻辑运算符</h3>
<p>​ &amp;：逻辑与；|：逻辑或；!：逻辑非；<br> ​ &amp;&amp;：短路与；||：短路或；^：逻辑异或</p>
<ul>
<li>逻辑运算符只能用于boolean变量或boolean常量，且结果也为boolean型</li>
<li>短路与/短路或 至少可判断一个boolean量（只要左边boolean能够判断出来最终结果，将不再计算右边的量），而逻辑与/逻辑或需要执行左右两边的boolean量（和左边boolean值无关，都要计算）</li>
</ul>
<h3 id="五位运算符">（五）位运算符</h3>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/14%20Day2%20-%2011.png" alt="Java中的位运算符"><figcaption aria-hidden="true">Java中的位运算符</figcaption>
</figure>
<ul>
<li><p>位运算符操作的都是整型的数据</p></li>
<li><p>左右移位：</p>
<ul>
<li><p>左移（&lt;&lt;）：在<strong>一定范围内</strong>，无论正负数，每向左移一位，整个数据相当于*2，且右侧补0。超过范围会出现正负数转换</p></li>
<li><p>右移（&gt;&gt;）时左侧空出来的位使用原来最高位（符号位）补</p></li>
<li><p>无符号右移（&gt;&gt;&gt;）是指无论原数是正数还是负数，最高位都以0补</p>
<blockquote>
<p>面试题： 最高效计算2*8？</p>
<ul>
<li>答：2&lt;&lt;3 或 8&lt;&lt;1</li>
</ul>
<p>交换2个变量值的方法： <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/15%20Day2%20-%2012.png" alt="使用位运算符交换2个变量值的方法"></p>
</blockquote></li>
</ul></li>
<li><p>&amp; | ^：操作左右两侧整型量的对应的二进制数</p></li>
</ul>
<h3 id="六三元运算符">（六）三元运算符</h3>
<ul>
<li>格式：
<ul>
<li><strong>(条件表达式)? 表达式1 : 表达式2;</strong></li>
<li>若条件为真，则执行表达式1；否则执行表达式2</li>
</ul></li>
<li>三元运算符和if-else异同：
<ul>
<li>三元运算符可简化为if-else语句，都可以嵌套使用</li>
<li>三元运算符必须返回一个结果</li>
<li>if后代码块可有多个语句</li>
</ul></li>
</ul>
<h3 id="七运算符优先级">（七）运算符优先级</h3>
<p>考试需要记，但优先级表较为难记，只需在编程中把想要优先运算的用小括号括起来即可。</p>
<h2 id="六流程控制">六、流程控制</h2>
<h3 id="一基本流程结构">（一）基本流程结构：</h3>
<ul>
<li>顺序结构</li>
<li>分支结构
<ul>
<li>根据条件，选择性的执行某段代码
<ul>
<li>有if-else和switch-case两种分支结构
<ul>
<li>if-else三种结构 <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/16%20Day2%20-%2013.png" alt="if-else三种结构"></li>
<li>switch-case结构 <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/22%20Day2%20-%2019.png" alt="switch-case结构"></li>
</ul></li>
</ul></li>
</ul></li>
<li>循环结构
<ul>
<li>根据循环条件，重复性执行某段代码</li>
<li>有while、do...while、for三种循环语句</li>
<li>注：JDK1.5提供了foreach循环，方便遍历集合、数组元素</li>
</ul></li>
</ul>
<h3 id="二分支结构">（二）分支结构</h3>
<h4 id="if-else结构">if-else结构</h4>
<ul>
<li>else结构是可选的</li>
<li>对于条件表达式
<ul>
<li>如果多个条件表达式之间是互斥的关系，各个条件表达式的顺序无所谓</li>
<li>否则，应根据实际情况考虑应将哪个条件置于前面、哪个置于后面</li>
</ul></li>
</ul>
<h4 id="switch-case结构">switch-case结构</h4>
<p>格式： <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/22%20Day2%20-%2019.png" alt="switch-case结构"></p>
<ul>
<li>根据switch表达式的值，依次匹配各个case中的常量，一旦匹配成功，则进入相应的case结构中，调用其执行语句，调用完执行语句后仍继续向下执行，直到遇到break或switch-case结尾</li>
<li>switch表达式<strong>只能是6种数据类型之一：byte、short、int、char、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）</strong></li>
<li>case之后只能声明常量，不能是表达式</li>
<li>default结构是可有可无的，且位置灵活（置于case前面时也是在所有case不匹配时调用，且该结构仍需先判断各个case）</li>
<li>凡是使用switch-case的结构，都可转换为if-else结构。反之不成立；当写分支结构时，两者都可使用情况下，优先使用switch-case，因为switch-case执行效率稍高</li>
</ul>
<h3 id="三循环结构">（三）循环结构</h3>
<h4 id="循环结构分类">循环结构分类</h4>
<ul>
<li>循环语句的四个组成部分：
<ul>
<li>① 初始化部分（init_statement）</li>
<li>② 循环条件部分（test_exp）</li>
<li>③ 循环体部分（body_statement）</li>
<li>④ 迭代部分（alter_statement）</li>
</ul></li>
</ul>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/23%20Day2%20-%2020.png" alt="循环语句的四个组成部分"><figcaption aria-hidden="true">循环语句的四个组成部分</figcaption>
</figure>
<ul>
<li>for循环结构：
<ul>
<li>格式：for(①; ②; ④) { ③ }</li>
<li>执行过程（满足②执行循环体）：① ② ③ ④ ② ③ ④ ... ② ③ ④ ②</li>
<li>意义：条件满足时执行循环体</li>
</ul></li>
<li>while循环结构：
<ul>
<li>格式：①; while(②) { ③; ④; }</li>
<li>执行过程（满足②执行循环体）：① ② ③ ④ ② ③ ④ ... ② ③ ④ ②</li>
<li>for循环和while循环可相互转换</li>
<li>意义：当条件满足时执行循环体</li>
</ul></li>
<li>do-while循环结构：
<ul>
<li>格式：①; do { ③; ④; }while(②);</li>
<li>执行过程（满足②执行循环体）：① ③ ④ ② ③ ④ ... ② ③ ④ ②</li>
<li>意义：执行 循环体，直到条件不满足（直译：执行(do)...在...时(while)）</li>
<li>需要注意：while(②)后需要加上分号</li>
</ul></li>
<li>while(true) {...} 等价于 for(; ; ;) {...}</li>
</ul>
<h4 id="嵌套循环">嵌套循环</h4>
<ul>
<li>嵌套循环：将一个循环结构A置于另一个循环结构B的循环体中，就构成嵌套循环</li>
<li>外层循环：循环结构B相对于循环结构A为外层循环；内层循环：循环结构A相对于循环结构B为内层循环；</li>
<li>例子：输出100以内的所有质数。（质数或素数为 只能被1和它自己整除的自然数） <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/25%20Day2%20-%2022.png" alt="输出 100 以内的所有质数"></li>
</ul>
<h4 id="特殊关键字使用breakcontinue">特殊关键字使用（break、continue）</h4>
<ul>
<li>break与continue
<ul>
<li>break：适用在switch-case 或 循环结构中</li>
<li>continue：适用于循环结构中</li>
<li>两者在循环中作用：break在循环中使用为 结束当前循环；continue在循环中为结束当次循环。两者之后都不能<strong>直接</strong>声明其他语句</li>
</ul></li>
<li>带标签的break和continue
<ul>
<li>不带标签的break执行后默认跳出包裹此关键词的最近的一个循环；不带标签的continue类似</li>
<li>带标签的break执行后会跳出该标签指明的那一层循环；带标签的continue类似 <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/26%20Day2%20-%2023.png" alt="带标签的break和continue测试"></li>
<li>使用带标签的break或continue输出100内所有的质数 <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/27%20Day2%20-%2024.png" alt="使用带标签的 break 或 continue 输出 100 内所有的质数"></li>
</ul></li>
</ul>
<h2 id="七每日一考">七、每日一考</h2>
<ol type="1">
<li><p>&amp; 和 &amp;&amp; 的异同</p>
<blockquote>
<p>答：&amp;为逻辑与，&amp;&amp;为短路与。逻辑与两侧的表达式都需计算并判断，而短路与在一侧表达式变量使得整个结果成立时即可不再计算并判断右侧表达式</p>
</blockquote></li>
<li><p>程序输出 <img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/17%20Day2%20-%2014.png" alt="题目"></p>
<blockquote>
<p>答：输出44</p>
</blockquote></li>
<li><p>定义三个int型变量并赋值，使用三元运算符或者if-else获取这三个数中的较大数的实现</p>
<blockquote>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/18%20Day2%20-%2015.png" alt="代码实现"><figcaption aria-hidden="true">代码实现</figcaption>
</figure>
</blockquote></li>
<li><p>编写程序，声明2个double型变量并赋值。判断第一个数大于10.0，且第2个数小于20.0，打印两数之和。否则，打印两者的乘积</p>
<blockquote>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/19%20Day2%20-%2016.png" alt="代码实现"><figcaption aria-hidden="true">代码实现</figcaption>
</figure>
</blockquote></li>
<li><p>交换两个值的代码实现</p>
<blockquote>
<p>答：前文中有3种解决方案</p>
</blockquote></li>
<li><p>switch后面的表达式可以是哪些数据类型</p>
<blockquote>
<p>答：switch后表达式可跟 6种类型变量：byte、char、short、int、String和枚举类型</p>
</blockquote></li>
<li><p>谈谈你对三元运算符、if-else和switch-case结构使用场景的理解</p>
<blockquote>
<p>答：三元运算符为一个运算符，常应用在简单的判断上，并且必须返回一个数据；if-else为流程控制结构，用于控制程序的运行，常应用于在不同范围内的变量执行不同操作的逻辑中，用于判断的表达式必须为boolean类型；switch-case结构也为流程控制结构，常用于变量具有某几个确定值的逻辑中，表达式类型只能取6种类型之一 凡是能使用三元运算符的、switch-case结构的，都能转换为if-else；反之，则不成立。三者都能使用时，优先使用三元运算符或者switch-case结构</p>
</blockquote></li>
<li><p>如何从控制台获取String和int类型的变量，并输出？使用代码实现</p>
<blockquote>
答：
<ul>
<li>首先导包：import java.util.Scanner;</li>
<li>然后实例化对象：Scanner scan = new Scanner(System.in);</li>
<li>通过查询手册，获取String类型变量：String str = scan.next();</li>
<li>通过查询手册，获取int类型变量：int i = scan.nextInt();</li>
</ul>
</blockquote></li>
<li><p>使用for循环遍历100以内的奇数，并计算所有的奇数的和并输出</p>
<blockquote>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/24%20Day2%20-%2021.png" alt="代码实现"><figcaption aria-hidden="true">代码实现</figcaption>
</figure>
</blockquote></li>
<li><p>循环结构是如何最后退出循环的，有哪些不同的情况请说明。</p>
<blockquote>
答：
<ul>
<li>不满足循环条件情况下，退出循环</li>
<li>break关键字强制退出循环</li>
<li>在方法中可使用return关键字强制停止循环执行</li>
</ul>
</blockquote></li>
<li><p>带标签的break和continue意义</p>
<blockquote>
答：
<ul>
<li>带标签的break被执行后，将会退出该标签指定的循环结构</li>
<li>带标签的continue被执行后，将会跳过本次该标签指定的循环</li>
</ul>
</blockquote></li>
<li><p>一个数如果恰好等于她的因子之和，这个数就称为”完数“。例如6=1+2+3。编程找出1000以内的所有完数。（因子：除去这个数本身的其他约数）</p>
<blockquote>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/28%20Day2%20-%2025.png" alt="代码实现"><figcaption aria-hidden="true">代码实现</figcaption>
</figure>
</blockquote></li>
<li><p>说明break和continue使用上的相同点和不同点</p>
<blockquote>
答：
<ul>
<li>break和continue都可用于循环语句中，而break还可用于switch-case语句中</li>
<li>break为退出循环，而continue为跳过该次循环，直接执行下一次循环</li>
<li>两者语句之后不能直接声明执行语句。</li>
</ul>
</blockquote></li>
</ol>
<h2 id="八补充">八、补充</h2>
<p>从键盘获取输入数据：</p>
<figure>
<img src="/2021/11/23/Coding/Java/02Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/20%20Day2%20-%2017.png" alt="从键盘获取输入数据代码实现"><figcaption aria-hidden="true">从键盘获取输入数据代码实现</figcaption>
</figure>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章 Java语言概述</title>
    <url>/2021/11/22/Coding/Java/01Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="第1章-java语言概述">第1章 Java语言概述</h1>
<h2 id="目录">目录</h2>
<ol type="1">
<li>一、软件开发介绍</li>
<li>二、计算机编程语言介绍</li>
<li>三、Java 语言概述</li>
<li>四、Java 语言运行机制及运行过程</li>
<li>五、Java 的环境搭建</li>
<li>六、开发体验 ——helloworld &amp; 常见的问题及解决方法</li>
<li>八、注释（comment）</li>
<li>九、Java API 文档</li>
<li>对第一个程序的总结</li>
<li>十、良好的编程风格</li>
<li>十一、常用的 Java 编程工具</li>
<li>每日一考 <span id="more"></span></li>
</ol>
<h2 id="一软件开发介绍">一、软件开发介绍</h2>
<ul>
<li>软件：一系列按照特定顺序组织的计算机数据和指令的集合
<ul>
<li>软件分为系统软件和应用软件</li>
</ul></li>
<li>人机交互方式
<ul>
<li>图形化界面（Graphical User Interface, GUI）</li>
<li>命令行方式（Command Line Interface, CLI）</li>
</ul></li>
<li>常用Dos指令：
<ul>
<li>dir：列出当前目录下的文件及文件夹</li>
<li>md：创建目录</li>
<li>rd：删除目录</li>
<li>cd：进入指定目录</li>
<li>cd..：退回到上一级目录</li>
<li>cd：退回到根目录</li>
<li>del：删除文件</li>
<li>exit：退出Dos命令行</li>
<li>补充：echo javase&gt;1.doc</li>
</ul></li>
</ul>
<h2 id="二计算机编程语言介绍">二、计算机编程语言介绍</h2>
<ul>
<li>第一代语言：机器语言</li>
<li>第二代语言：汇编语言：使用助记符表示一条机器指令</li>
<li>第三代语言：高级语言
<ul>
<li>C、Pascal、Fortran面向过程的语言</li>
<li>C++面向过程/面向对象</li>
<li>Java跨平台的纯面向对象语言</li>
<li>.NET跨语言的平台</li>
<li>Python、Scala...</li>
</ul></li>
</ul>
<h2 id="三java语言概述">三、Java语言概述</h2>
<p>后台开发：Java（大型）、PHP、Python（头条后台使用python）、Go（宣传具有java开发效率、具有C/C++执行效率）、Node.js（做前端的学习）</p>
<p>Java语言简史：</p>
<ul>
<li>2004年，发布里程碑式版本JDK1.5，为突出重要性更名为JDK5.0。后续版本中只要是1.X其实就是JDK X.0（例如JDK1.6等同于JDK6.0）</li>
<li>2005年，J2SE-更名-&gt;JavaSE，J2EE-更名-&gt;JavaEE，J2ME-更名-&gt;JavaME</li>
<li>2014年，发布JDK8.0，是继JDK5.0以来变化最大的版本。通常目前公司使用版本一定是1.5以后的，一般是6.0、7.0、8.0</li>
<li>2018年3月，发布JDK10.0，版本号以时间命名：18.3</li>
</ul>
<p>Java体系平台</p>
<ul>
<li>Java SE（Java Standard Edition）标准版：主要用于开发桌面级应用。现在一般不再用Java写桌面级应用了</li>
<li>java EE（Java Enterprise Edition）企业版：为企业环境下开发应用程序，后台</li>
<li>Java ME（Java Micro Edition）小型版 &amp; Java Card：为移动终端开发应用程序</li>
</ul>
<p>Java应用领域</p>
<ul>
<li><strong>企业级应用</strong>：后台开发</li>
<li><strong>Android平台应用</strong>：作为Android开发语言出现</li>
<li><strong>大数据平台开发</strong>：后台大都基于Java后台，<strong>大数据</strong>自然要开放Java接口。各类框架有Hadoop、spark、storm、flink，各种中间件如flume、kafka、sqoop</li>
<li>移动领域</li>
</ul>
<p>Java是由C语言和C++继承而来的：</p>
<ul>
<li>java是一个纯粹的面向对象的语言；</li>
<li>Java舍弃了C语言中容易引起错误的指针（使用 引用 来取代）；</li>
<li>Java增加了垃圾回收器功能</li>
</ul>
<h2 id="四java语言运行机制及运行过程">四、Java语言运行机制及运行过程</h2>
<p>Java语言特点：</p>
<ul>
<li>特点一：面向对象
<ul>
<li>两个基本概念：类、对象</li>
<li>三大特性：封装、继承、多态</li>
</ul></li>
<li>特点二：健壮性
<ul>
<li>吸收了C/C++语言优点，但去掉了影响程序健壮性的部分（指针、内存申请及释放），提供了一个相对安全的内存管理和访问机制。</li>
</ul></li>
<li>特点三：跨平台性
<ul>
<li>跨平台性：Java语言编写的程序在不同的系统上都可以运行</li>
<li>原理：只需在需要运行Java应用的操作系统上安装Java虚拟机（Java Virtual Machine, JVM）即可。由JVM负责Java程序在该系统的运行。</li>
</ul></li>
</ul>
<p>核心机制——垃圾回收</p>
<ul>
<li>不使用的内存空间应当被回收——垃圾回收
<ul>
<li>C/C++中，由程序员负责回收无用内存</li>
<li>Java提供了一种系统级线程跟踪存储空间的分配情况，在JVM空闲时，检查并释放可被释放的内存空间</li>
</ul></li>
<li>垃圾回收在Java程序的运行过程中自动进行，程序员无法精确控制和干预</li>
<li>但Java程序仍然会有可能出现<strong>内存泄漏和内存溢出</strong>的问题</li>
</ul>
<h2 id="五java的环境搭建">五、Java的环境搭建</h2>
<p>JDK后续版本向下兼容，高版本与低版本之间关系为包含关系（如果换用了新版本并且改掉了旧版本内容会造成原先能运行的程序无法运行，故新版本是旧版本的添加）</p>
<p><strong>JDK及JRE</strong>：</p>
<ul>
<li>JDK：Java Development Kit Java开发工具包。JDK中包括<strong>Java开发工具（编译工具javac.exe，打包工具jar.exe）</strong>和<strong>JRE</strong>。Java开发必需。</li>
<li>JRE：Java Runtime Environment java运行环境。JRE包括<strong>Java虚拟机（JVM）</strong>和<strong>Java程序所需的核心类库</strong>。Java程序运行必需。</li>
<li>jdk-8u131-win.....exe中：u代表update，131表示在jdk8.0版本上已经更新到131了</li>
</ul>
<figure>
<img src="/2021/11/22/Coding/Java/01Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/01%20JDK-JRE-JVM.png" alt="JDK-JRE-JVM关系"><figcaption aria-hidden="true">JDK-JRE-JVM关系</figcaption>
</figure>
<p>JDK目录结构：</p>
<figure>
<img src="/2021/11/22/Coding/Java/01Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/02%20JDK%20Directory%20Architecture.png" alt="JDK目录结构"><figcaption aria-hidden="true">JDK目录结构</figcaption>
</figure>
<ul>
<li>bin目录：开发工具，包括编译工具javac.exe、文档生成工具javadoc.exe</li>
<li>db目录：java写的数据库</li>
<li>include目录：C语言编写的头文件，jni.h代表Java Native Interface</li>
<li>jre目录：JRE运行时环境</li>
<li>lib目录：jar包库文件</li>
<li>src压缩文件：java源码和开源类库</li>
</ul>
<p>配置环境变量：</p>
<ul>
<li>PC中环境变量path代表 Windows系统执行命令时要搜寻的路径</li>
<li>改进：把\bin目录的上层目录放到一个新的自定义变量中（例如JAVA_HOME），之后再将这个变量名动态的引用（例如%JAVA_HOME%;）。改进的原因是 之后搭建服务器时需要寻找JAVA_HOME环境变量，从而获得并使用一些库文件，因此需要配置JAVA_HOME</li>
</ul>
<h2 id="六开发体验helloworld-常见的问题及解决方法">六、开发体验——helloworld &amp; 常见的问题及解决方法</h2>
<p>步骤</p>
<ol type="1">
<li>将java代码写入到扩展名为.java的文件中。</li>
<li>通过javac命令将java文件进行编译，生成.class文件。<strong>生成的.class文件文件名为.java文件中类的类名</strong>。（由于Windows目录下不区分大小写，使用javac ---.java可以不区分大小写）</li>
<li>通过java命令对生成的.class文件进行运行。（运行命令时.class扩展名无需写）</li>
<li>每次修改.java文件，运行时都需要重新编译（运行时区分大小写，因为此时回到了java层面，查找的是类）</li>
</ol>
<h2 id="八注释comment">八、注释（comment）</h2>
<ul>
<li><p>用于注解说明解释程序的文字就是注释</p></li>
<li><p>Java中的注释类型：</p>
<ul>
<li><p>单行注释：//</p></li>
<li><p>多行注释：/* */</p></li>
<li><p>文档注释：<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 指定java程序的作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure> 注释的内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档</p>
<p>操作方法：javadoc -d mydoc -author -version HelloWorld.java</p></li>
</ul></li>
<li><p>一般先将自己的思想通过注释整理出来，再用代码实现</p></li>
</ul>
<h2 id="九java-api文档">九、Java API文档</h2>
<ul>
<li>API（Application Programming Interface, 应用程序编程接口）是Java提供的基本编程接口。通俗来说就是<strong>Java提供的一系列类库</strong>。</li>
</ul>
<h2 id="对第一个程序的总结">对第一个程序的总结</h2>
<ol type="1">
<li><p>Java程序编写-编译-运行的过程<br> 编写：将编写的java代码保存在以.java结尾的源文件中<br> 编译：使用javac.exe命令编译.java源文件。格式：javac 源文件名.java<br> 运行：使用java命令解释运行字节码文件。格式：java 类名<br></p></li>
<li><p>在一个Java源文件中可以声明多个类。但是只能最多有一个类被声明为public，且只能加到与文件名一致的类上，否则编译不通过</p></li>
</ol>
<p>实际上先有的 类名要与文件名一致，public只能加到与文件名一致的类上是结果</p>
<blockquote>
<p>为什么Java源文件中只能最多有一个public类？</p>
<p>答：每个编译单元（java源文件）都只能有一个public类，这表示每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果某个编译单元包含多个public类或者public类名与编译单元名不同，都会产生编译错误。（——《java编程思想 第四版》）</p>
<p>总结：一个编译单元可以存在多个类，在编译时产生多个不同的.class文件，.class文件即是程序运行的数据来源。Java将public类作为每个编译单元的数据接口，只能有一个，不然不能处理存在多个public类的Java文件。当一个编译单元有多个非public类时，运行时需要对数据来源进行选择。</p>
</blockquote>
<ol start="3" type="1">
<li><p>程序的入口是main方法，格式是固定的</p></li>
<li><p>输出语句：<br> System.out.println();<br> System.out.print();</p></li>
<li><p>编译的过程： 编译后会生成一个或多个字节码文件。字节码文件名与Java源文件中的类名相同（一个源文件有几个类就会在编译后生成几个字节码文件）</p></li>
<li><p>运行： 运行包含程序入口的字节码文件即可。 如果生成了多个字节码文件（一个源文件中有多个类）并且想要运行其他字节码文件就需要在其他类中定义程序入口main</p></li>
</ol>
<h2 id="十良好的编程风格">十、良好的编程风格</h2>
<ul>
<li><p>大括号可以是首尾式 public class HelloWorld {</p>
<p>}</p></li>
<li><p>大括号可以是单独一行 public class HelloWorld <br> {</p>
<p>}</p></li>
<li><p>适当位置加空格：a = b + c * d;</p></li>
</ul>
<h2 id="十一常用的java编程工具">十一、常用的Java编程工具</h2>
<ol type="1">
<li>文本编辑工具
<ul>
<li>记事本</li>
<li>UltraEdit</li>
<li>EditPlus</li>
<li>TextPad</li>
<li>NotePad</li>
</ul></li>
<li>集成开发环境（Integrated Development Environment，IDE）
<ul>
<li>NetBeans</li>
<li>Eclipse</li>
<li>IDEA</li>
</ul></li>
</ol>
<h2 id="每日一考">每日一考</h2>
<ol type="1">
<li><p>JDK，JRE，JVM三者之间的关系，以及JDK、JRE包含的主要结构有哪些？</p>
<blockquote>
<p>答：JDK、JRE、JVM三者为包含关系。JDK包含JRE和一些Java开发工具，JRE包含JVM和Java程序运行的核心类库</p>
</blockquote></li>
<li><p>为什么要配置path环境变量？如何配置？</p>
<blockquote>
<p>答：</p>
<ul>
<li>配置path环境变量是因为(可以不在工具所在目录)可在任何文件目录即可调用并运行该工具</li>
<li>在我的电脑 - 属性 - 高级 - 环境变量；建立JAVA_HOME环境变量，path中只需动态调用JAVA_HOME、再加上</li>
</ul>
</blockquote></li>
<li><p>常用的几个命令行操作都有哪些？（至少4个）</p>
<blockquote>
<p>答：</p>
<ul>
<li>cd</li>
<li>md</li>
<li>dir</li>
<li>del</li>
<li>rd</li>
</ul>
</blockquote></li>
<li><p>创建如下的类，使得运行时能够输出：</p>
<blockquote>
<p>公众号：百家全匠</p>
<p>英文名：Encyclopedia Master 用途：获得资源、增长知识、学习技能……</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficialAccount</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;公众号：百家全匠\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;英文名：Encyclopedia Master&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;用途：获得资源、增长知识、学习技能……&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编译和运行上述代码的指令</p></li>
</ol>
<figure>
<img src="/2021/11/22/Coding/Java/01Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/03%20Day1%20-%2002.png" alt="alt"><figcaption aria-hidden="true">alt</figcaption>
</figure>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
